<!DOCTYPE html>
<html lang="en">
<head>
	<title>Master Defender</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	
	<meta name="mobile-web-app-capable" content="yes">
	<meta name="apple-mobile-web-app-capable" content="yes">
	<meta name="apple-mobile-web-app-status-bar-style" content="black">
	
	<meta property="og:title" content="Master Defender">
	<meta property="og:description" content="Defend your ground by planes and soldiers!">
	
	<script src="three.js"></script>
	<!--<script src="OrbitControls.js"></script>-->

	<link type="text/css" href="jquery/jquery-ui.css" rel="Stylesheet" />
	<script type="text/javascript" src="jquery/jquery.min.js"></script>
	<script type="text/javascript" src="jquery/jquery-ui.min.js"></script>
	
	<script src="riffwave.js"></script>
	<script src="sfxr.js"></script>
	


<style>

html, body {
    margin: 0;
    padding: 0;
    height: 100%;
    width: 100%;
}




#loading_container {
    margin: 0;
    padding: 0;
    height: 100%;
    width: 100%;
	

	text-shadow: rgba(0,0,0,0.5) 0px 0px 1.5px, rgba(0,0,0,0.2) 0px 0px 5px, rgba(0,0,0,0.15) 0px 0px 10px;
}

#loading_container {
    display: table;
	position:absolute;
	background: rgb(27,48,110);
	
	background: radial-gradient(circle, rgba(0,0,0,0.5) 0%, rgba(0,198,196,0.5) 13%, rgba(0,255,252,0.5) 15%, rgba(39,255,244,0.5) 17%, rgba(240,18,17,0.5) 65%, rgba(255,0,0,0.5) 100%), linear-gradient(0deg, rgba(27,48,110,1) 10%, rgba(106,125,255,1) 55%, rgba(137,219,122,1) 60%, rgba(3,3,10,1) 83%, rgba(0,0,0,1) 100%);
	
	background-size: 100% 100%;
	background-position: 50% 50%;
	
	animation: gradient 3s ease infinite;
}

@keyframes gradient {
	0% {
		background-size: 100% 100%;
	}
	50% {
		background-size: 200% 200%;
	}
	100% {
		background-size: 100% 100%;
	}
}


#loading_container_inner {
    display: table-cell;
    margin: 0;
    padding: 0;

    text-align: center;
    vertical-align: middle;
}

#loading_text {
	font:40px verdana;
	margin: auto;
	color:#000;
}

#loading_desc {
	font:12px verdana;
	color:#000;
}




/* Pure CSS Loaders: https://loading.io/css/ */

.lds-ellipsis {
  display: inline-block;
  position: relative;
  width: 80px;
  height: 80px;
  top:40px;
}
.lds-ellipsis div {
  position: absolute;
  top: 33px;
  width: 8px;
  height: 8px;
  border-radius: 50%;
  background: #000;
  
  box-shadow: rgba(0,0,0, 0.5) 0px 0px 1px, rgba(0,0,0, 0.5) 0px 0px 8px, rgba(0,0,0, 0.3) 0px 0px 16px;
}
.lds-ellipsis div:nth-child(1) {
  left: 8px;
  animation: lds-ellipsis1 0.6s infinite;
}
.lds-ellipsis div:nth-child(2) {
  left: 8px;
  animation: lds-ellipsis2 0.6s infinite;
}
.lds-ellipsis div:nth-child(3) {
  left: 32px;
  animation: lds-ellipsis2 0.6s infinite;
}
.lds-ellipsis div:nth-child(4) {
  left: 56px;
  animation: lds-ellipsis3 0.6s infinite;
}
@keyframes lds-ellipsis1 {
  0% {
    transform: scale(0);
  }
  100% {
    transform: scale(1);
  }
}
@keyframes lds-ellipsis3 {
  0% {
    transform: scale(1);
  }
  100% {
    transform: scale(0);
  }
}
@keyframes lds-ellipsis2 {
  0% {
    transform: translate(0, 0);
  }
  100% {
    transform: translate(24px, 0);
  }
}





/* Pure CSS Loaders: https://loading.io/css/ */

.lds-ellipsis-left {
  display: inline-block;
  position: relative;
  width: 80px;
  height: 80px;
  top:40px;
}
.lds-ellipsis-left div {
  position: absolute;
  top: 33px;
  width: 8px;
  height: 8px;
  border-radius: 50%;
  background: #000;
  
  box-shadow: rgba(0,0,0, 0.5) 0px 0px 1px, rgba(0,0,0, 0.5) 0px 0px 8px, rgba(0,0,0, 0.3) 0px 0px 16px;
}
.lds-ellipsis-left div:nth-child(1) {
  left: 8px;
  animation: lds-ellipsis-left1 0.6s infinite;
}
.lds-ellipsis-left div:nth-child(2) {
  left: 8px;
  animation: lds-ellipsis-left2 0.6s infinite;
}
.lds-ellipsis-left div:nth-child(3) {
  left: 32px;
  animation: lds-ellipsis-left2 0.6s infinite;
}
.lds-ellipsis-left div:nth-child(4) {
  left: 56px;
  animation: lds-ellipsis-left3 0.6s infinite;
}
@keyframes lds-ellipsis-left1 {
  0% {
    transform: scale(1);
  }
  100% {
    transform: scale(0);
  }
}
@keyframes lds-ellipsis-left3 {
  0% {
    transform: scale(0);
  }
  100% {
    transform: scale(1);
  }
}
@keyframes lds-ellipsis-left2 {
  0% {
    transform: translate(24px, 0);
  }
  100% {
    transform: translate(0, 0);
  }
}


</style>
<script>

/*
todo:
- visible_size = 8192/6 <--- make all repetitive map backgrounds defineable in a way that you give the scale of the texture compared to map size,
  so it will always be relative to map size.
- playerSpriteTest sprite should be 1-2px wider to prevent texture bleeding caused by offset change which was done to render rotation better.
*/



/*
var YoutubeEmbed = function(id, x, y, z, rx){
	var div = document.createElement('div');
	div.style.width = '480px';
	div.style.height = '360px';
	div.style.backgroundColor = '#000';
	var iframe = document.createElement('iframe');
	iframe.style.width = '480px';
	iframe.style.height = '360px';
	iframe.style.border = '0px';
	iframe.src = ['https://www.youtube.com/embed/', id, '?rel=0&autoplay=1&mute=0'].join('');
	div.appendChild(iframe);
	var object = new CSS3DObject(div);
	object.position.set(x, y, z);
	object.rotation.x = rx;
	return object;
};
*/





function decodeRGBA(argb){
	this.a = (argb >> 24) & 255;
	this.r = (argb >> 16) & 255;
	this.g = (argb >> 8) & 255;
	this.b = argb & 255;
}

function encodeRGBA(a,r,g,b){
	return ((a << 24) | (r << 16) | (g << 8) | b) >>> 0; // ">>> 0" converts to 32bit unsigned integer
}

function valueBetween(from, to, percent){
	return (to-from)*percent+from;
}

function intBetween(from, to, percent){
	return Math.round(valueBetween(from, to, percent));
}

// gives gradient color value at specific point of the gradient line.
function colorBetweenRGBA(from, to, percent){
	let c1 = new decodeRGBA(from);
	let c2 = new decodeRGBA(to);
	return encodeRGBA(
		intBetween(c1.a, c2.a, percent),
		intBetween(c1.r, c2.r, percent),
		intBetween(c1.g, c2.g, percent),
		intBetween(c1.b, c2.b, percent)
	);
}

function colorBetweenRGBA_array(arr, percent){
	let len = arr.length;
	let total_gradients = len-1; // 2 colors have 1 gradient, 3 have 2. etc.
	let step = 1.0/total_gradients;
	let c1 = Math.floor(percent/step);
	let c2 = c1+1;
	if(c2 > len-1){
		c2 = len-1;
	}
	let percent_between = (percent/step)-c1;
	return colorBetweenRGBA(arr[c1], arr[c2], percent_between);
}







var PARAMS = new Params();
var SOUND;
var SOUND_VOL = 0.1068; // see sfxr.js (var volume) for volume adjusting for browser. this changes the wav file but doesnt work well because it clips the sounds at too loud or low volumes.
var SAMPLE_RATE = 44100;
var SAMPLE_SIZE = 8;
var CURRENT_TYPE = "";
var LOCKED = {};









</script>

<style>
* {
	box-sizing: border-box;
	cursor:default;
}
body {
	background:#000;
	color:#fff;
	padding:0;
	margin:0;
	overflow:hidden;
	font-family:courier;
	text-align:left;
	font-size:1.5vmax;
}
#gui {
	display:none;
}

#fps {
	position:absolute;
	top:0;
	left:0;
	font:1vmax courier;
	padding:4px 4px 4px 10px;
	background-color:rgba(0,0,0, 0.5);
	text-shadow: 0 0 3px #000000, 0 0 2px #000000, 0 0 1px #000000;
	border-bottom-right-radius:10px;
}
#info {
	position: absolute;
	bottom:0;
	left:0;
	width: 100%;
	font:1vmax courier;
	padding:4px 4px 4px 10px;
	background-color:rgba(0,0,0, 0.5);
	text-shadow: 0 0 3px #000000, 0 0 2px #000000, 0 0 1px #000000;
}
.elem {
	float:left;
	padding-right:30px;
}

#players {
	text-align:left;
	position:absolute;
	right:0;
	top:0;
	max-width:30vmax;
	padding:0.5vmax;
	background-color:rgba(0,0,0, 0.5);
	border-bottom-left-radius:1vmax;
	font:1vmax courier;
}



#players-ending-scores {
	text-align:left;
	position:absolute;
	left:50%;
	top:15%;
	margin-left:-18vmax;
	margin-top:0;
	width:36vmax;
	padding:10px 10px 10px 10px;
	background-color:rgba(0,0,0, 0.85);
	border-radius:1.5vmax;
	font-size:2vmax;
}


#countdown {
	padding-top:15px;
	width:100%;
	text-align:center;
}

.hidden {
	display:none;
}


#ending-score-table {
	width:100%;
}

#ending-score-table .num {
	width:2vmax;
	padding-left:0.25vmax;
	padding-right:0.25vmax;
	text-align:right;
}
#ending-score-table .nam {
	padding-left:0.5vmax;
	padding-right:10px;
}
#ending-score-table .sco {
	width:3vmax;
	padding-left:0.5vmax;
	padding-right:1vmax;
}
#ending-score-table .ext {
	width:3vmax;
	padding-left:1vmax;
	padding-right:0.25vmax;
	color:rgba(255,255,255, 0.5);
}



</style>
</head>
<body>




<style>
#blocker {
	position: absolute;
	top: 0px;
	left: 0px;
	width: 100%;
	height: 100%;
}
</style>

<div id="container"></div>
<div id="blocker"></div>



	
<script>
/*jshint esversion: 6 */
//credit: https://gist.github.com/banksean/304522#file-perlin-noise-simplex-js
class Perlin {
	constructor() {
		this.grad3 = [[1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0], [1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1], [0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1]]; 
		this.p = []; for (var i=0; i<256; i++) { this.p[i] = Math.floor(Math.random()*256);}
		this.perm = []; for(i=0; i<512; i++) { this.perm[i]=this.p[i & 255];} 
		this.simplex = [[0,1,2,3],[0,1,3,2],[0,0,0,0],[0,2,3,1],[0,0,0,0],[0,0,0,0],[0,0,0,0],[1,2,3,0],[0,2,1,3],[0,0,0,0],[0,3,1,2],[0,3,2,1],[0,0,0,0],[0,0,0,0],[0,0,0,0],[1,3,2,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[1,2,0,3],[0,0,0,0],[1,3,0,2],[0,0,0,0],[0,0,0,0],[0,0,0,0],[2,3,0,1],[2,3,1,0],[1,0,2,3],[1,0,3,2],[0,0,0,0],[0,0,0,0],[0,0,0,0],[2,0,3,1],[0,0,0,0],[2,1,3,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[2,0,1,3],[0,0,0,0],[0,0,0,0],[0,0,0,0],[3,0,1,2],[3,0,2,1],[0,0,0,0],[3,1,2,0],[2,1,0,3],[0,0,0,0],[0,0,0,0],[0,0,0,0],[3,1,0,2],[0,0,0,0],[3,2,0,1],[3,2,1,0]]; 
	}
	dot(g, x, y){ return g[0]*x + g[1]*y;}
	noise(xin, yin) { 
		var n0, n1, n2;var F2 = 0.5*(Math.sqrt(3.0)-1.0); var s = (xin+yin)*F2;var i = Math.floor(xin+s); var j = Math.floor(yin+s); var G2 = (3.0-Math.sqrt(3.0))/6.0; var t = (i+j)*G2; var X0 = i-t;var Y0 = j-t; var x0 = xin-X0;var y0 = yin-Y0; var i1, j1; if(x0>y0) {i1=1; j1=0;} else {i1=0; j1=1;} var x1 = x0 - i1 + G2;var y1 = y0 - j1 + G2; var x2 = x0 - 1.0 + 2.0 * G2;var y2 = y0 - 1.0 + 2.0 * G2; var ii = i & 255; var jj = j & 255; var gi0 = this.perm[ii+this.perm[jj]] % 12; var gi1 = this.perm[ii+i1+this.perm[jj+j1]] % 12; var gi2 = this.perm[ii+1+this.perm[jj+1]] % 12; var t0 = 0.5 - x0*x0-y0*y0; if(t0<0) n0 = 0.0; else { t0 *= t0; n0 = t0 * t0 * this.dot(this.grad3[gi0], x0, y0);} var t1 = 0.5 - x1*x1-y1*y1; if(t1<0) n1 = 0.0; else { t1 *= t1; n1 = t1 * t1 * this.dot(this.grad3[gi1], x1, y1); }var t2 = 0.5 - x2*x2-y2*y2; if(t2<0) n2 = 0.0; else { t2 *= t2; n2 = t2 * t2 * this.dot(this.grad3[gi2], x2, y2); } return 70.0 * (n0 + n1 + n2);
	}
}
</script>



<style>
.checkmark {
	min-width:20px;
	width:20px;
	font:bold 14px verdana;
	margin-right:5px;
}

.but_play, .but_new {
	width:78px;
}






#pause_container {
	text-shadow: 0 -1px 4px #FFF, 0 -2px 10px #ff0, 0 -18px 40px #F00;

    margin: 0;
    padding: 0;
    height: 100%;
    width: 100%;
	display:none;

	position:absolute;
	background: rgba(0,0,0, 0.7);
	

	background: radial-gradient(circle, rgba(0,0,0,0.4654236694677871) 0%, rgba(0,0,0,0.8939950980392157) 36%, rgba(0,0,0,1) 59%, rgba(0,0,0,1) 100%);

	
	background-size: 100% 100%;
	background-position: 50% 50%;
	
	--animation: gradient 3s ease infinite;
}

@keyframes gradient {
	0% {
		background-size: 100% 100%;
	}
	50% {
		background-size: 200% 200%;
	}
	100% {
		background-size: 100% 100%;
	}
}


#pause_container_inner {
    display: table-cell;
    margin: 0;
    padding: 0;

    text-align: center;
    vertical-align: middle;
}

#pause_text {
	font:40px verdana;
	margin: auto;
	color: #000;
}

#pause_desc {
	font:12px verdana;
	color: #000;
}
#pause_container .lds-ellipsis-left div {
	--background: #FFF;
}
#pause_container .lds-ellipsis div {
	--background: #FFF;
}


</style>

<div id="loading_container"><div id="loading_container_inner">
<div id="loading_text">

<div class="lds-ellipsis-left"><div></div><div></div><div></div><div></div></div>Loading<div class="lds-ellipsis"><div></div><div></div><div></div><div></div></div>

</div>
<div id="loading_desc">Working...</div>

</div></div>




<div id="pause_container"><div id="pause_container_inner">
<div id="pause_text">

GAME PAUSED

</div>
<div id="pause_desc">Press ENTER to unpause</div>

</div></div>




<div id="gui">

	<div id="fps">
	FPS: 0
	</div>

	<div id="info">
		<div class="elem">
			X: <span id="player-x">0</span>
		</div>
		<div class="elem">
			Y: <span id="player-z">0</span>
		</div>
		<div class="elem">
			Z: <span id="player-y">0</span>
		</div>
		<div class="elem">
			Deg: <span id="player-angle">0</span>
		</div>
	</div>

	<div id="players">
		<div id="scores" style="display:none">
		</div>
	</div>

	<div id="players-ending-scores" class="hidden">
		<div id="ending-scores">
		</div>
		<div id="countdown"></div>
	</div>
</div>

<script>
"use strict";



let INTERNAL_ZOOM = 1;
let ZOOM_MULTI = 1.08;


var ortho = true;
let camstyle = 1; // 1 = ortho, 0 = 3d
if(!ortho){
	camstyle = 0;
}
var smoothRender = 1;

let game_paused = false;
let game_paused_by_enter = false;

var globalFilter = smoothRender ? THREE.LinearFilter : THREE.NearestFilter;


var contextmenu_enabled = false;

var window_focus = true;

let loading_start_time = 0;


var SHOW_WAVE_BG = false;
var SHOW_RAIN_BG = false; // rain enabled/disabled
var SHOW_MAP_BG = true;
var SHOW_NIGHTSKY_BG = false;
var NIGHTSKY_STYLE = 0; // 0 = night, 1 = sunset (bright yellow).
var turrets_enabled = true;


var fade_dir = 0;
var night_fade_dir = 0; // 0 = night disabled.
var skyopacity = 0; // 0 if day mode.

var plane_flipped = false; // 0 = not upside down. 1 = upside down.
var flip_dir = 0; // which direction animation is going. 0 = nowhere, 1 = to flip dir, 2 = to unflip dir.
var planeFrameNum = 0;
var planeFrameNumX = 0;



///////////////////////////////////////////////////////
// z-indexes for different layers of objects:
// from furthest to nearest (in the order of rendering; first in this list = smallest number = first to render).
//
var ZINSTEP = 100;
if(!ortho){
	ZINSTEP = 1;
}
var ZIN = -ZINSTEP*2; // current z-index
// create new Z-index value
function NEWZIN(){
	ZIN += ZINSTEP;
	return ZIN-ZINSTEP;
}

var Z_SKYBOX = NEWZIN(); // night sky (skybox).

var Z_CLOUDS = NEWZIN(); // clouds parallax


var Z_MAP_WATER_BACK = NEWZIN();

var Z_MAP_WATERDROPS = NEWZIN();

var Z_MAP_BG = NEWZIN(); // map texture (back layer / map background parallax).




var Z_MAP_BEHIND = NEWZIN(); // map sprites layer

var Z_MAP_BEHIND_FRONT = NEWZIN(); // on front of the behind items.

var Z_TURRET_BARREL = NEWZIN();

var Z_TURRET = NEWZIN(); //  turrets behind every other object.




var Z_MAP_BOMBS = NEWZIN();
var Z_MAP_SHOTS = NEWZIN();

var Z_BOMBER = NEWZIN(); // enemy planes basically.
var Z_PLANE = NEWZIN(); // airplanes.
var Z_SOLDIER = NEWZIN(); // soldiers.




var Z_MAP_EXPLOSIONS = NEWZIN();


var Z_MAP_DECALS = NEWZIN(); // decals (bushes to hide behind)

var Z_MAP_FRONT = NEWZIN(); // map sprites layer

var Z_MAP_COLLISION = NEWZIN(); // main map texture.

var Z_MAP_COLLISION_FRONT = NEWZIN(); // when on front "lane"





var Z_MAP_WATER_FRONT = NEWZIN();

var Z_MAP_SPLASHES = NEWZIN();

var Z_MAP_VISUALS = NEWZIN(); // explosion glows etc.


var Z_PORTAL = NEWZIN();


var Z_RAIN = NEWZIN(); // rain texture.
//
////////////////////////////////////////////////////







var urlprefix = ""; // possibly used when using server to host files: "https://md.com/" etc.

var map_name = "highmap";
var map_data_url = urlprefix+'maps/'+map_name+'/settings.json';



function texture_path(name){
	return urlprefix+TEXTURES[name].path;
}


let default_texture_config = {
	// stuff like linear filter, repeat, offset... etc.
};


var TEXTURES = {
	'splash_sprite_url': 		{path: 'sprites/splash.png', 
								config: default_texture_config},
								
	'glowsprite_url': 			{path: 'sprites/glow2b.png', 
								config: default_texture_config},
								
	'map_bg_parallax_url':		{path: 'maps/parallax.png', 
								config: default_texture_config},
								
	'santa_sprite_url': 		{path: "sprites/SantaSleigh.png", 
								config: default_texture_config},
								
	'santa_lights_sprite_url': 	{path: "sprites/SantaSleigh-lights3c.png", 
								config: default_texture_config},
								
	'plane_sprite_url': 		{path: "sprites/AirplaneFullSpin-scaled.png", 
								config: default_texture_config},
								
	'plane_lights_sprite_url': 	{path: "sprites/AirplaneFullSpin-scaled-lights2.png", 
								config: default_texture_config},
								
	'helicopter_test_url': 		{path: "sprites/helicopter_2x.png", 
								config: default_texture_config},
								
	'helicopter_lights_sprite_url': {path: "sprites/helicopter_2x-lights.png", 
								config: default_texture_config},
								
	'bomber_sprite_url': 		{path: 'sprites/bomber_c47_2x.png', 
								config: default_texture_config},
								
	'bomber_lights_sprite_url': {path: 'sprites/bomber_c47_2x-lights2.png', 
								config: default_texture_config},
								
	'fighters_url': 			{path: "sprites/fighter_planes.png", 
								config: default_texture_config},
								
	'map_water_url': 			{path: 'textures/water2.jpg', 
								config: default_texture_config},
								
	'map_waterdrops_url': 		{path: 'textures/raindrop-ripples-oneliner2.png', 
								config: default_texture_config},
								
	'clouds_back_url': 			{path: "textures/clouds/cloud-bg.jpg", 
								config: default_texture_config},
								
	'clouds_front_url': 		{path: 'textures/clouds/cloud-layer.png', 
								config: default_texture_config},
								
	'nightsky_url': 			{path: "textures/clouds/stars.png", 
								config: default_texture_config},
								
	'bg2_url': 					{path: 'textures/rainfall.png', 
								config: default_texture_config},
								
	'map_url': 					{path: 'maps/'+map_name+'/collision.png', 
								config: default_texture_config},
								
	'map_behind_url': 			{path: 'maps/'+map_name+'/behind.png', 
								config: default_texture_config},
								
	'map_behind_lights_url': 	{path: 'maps/'+map_name+'/behind-lights.png', 
								config: default_texture_config},
								
	'map_front_url': 			{path: 'maps/'+map_name+'/front.png', 
								config: default_texture_config},
								
	'explosion_sprites_url': 	{path: 'sprites/explosions-big1.png', 
								config: default_texture_config},
								
	'bombs_sprite_url': 		{path: 'sprites/bomb.png', 
								config: default_texture_config},
								
	'shots_sprite_url': 		{path: 'sprites/shot2.png', 
								config: default_texture_config},
								
	'shots_lights_sprite_url': 	{path: 'sprites/shot2-lights.png', 
								config: default_texture_config},
								
	'stream_sprite_url': 		{path: 'sprites/stream.png', 
								config: default_texture_config},
								
	'turret_sprite_url': 		{path: 'sprites/turrets_3x.png', 
								config: default_texture_config},
								
	'mario_sprite_url': 		{path: 'sprites/mario_3x.png', 
								config: default_texture_config},
								
	'soldier_sprite_url': 		{path: 'sprites/soldier-3x.png', 
								config: default_texture_config},
};



// frames are order from the beginning. must be converted to sprite sheet coordinate.
var SPRITES = {
	'soldier': {
		/*
		added at initialize_sprite:
		sprite['w'] = w;
		sprite['h'] = h;
		sprite['sheet_w'] = sheet_w;
		sprite['sheet_h'] = sheet_h;
		sprite['frames_x'] = frames_x; // total frames horizontally in the sheet.
		sprite['anims_coords'] = {}; // calculated texcoords.
		*/
		'anims': {
			'stand_idle': [1], // 31 identical
			'prone_idle': [25],
			'crouch_idle': [21],
			'jump_start': [2,3,4],
			'jump_spin': [5,6,7,8],
			'jump_land': [9,10,11],
			'running': [12,13,14,15,16,17],
			'stand_prone': [18,19,20,21,22,23,24,25],
			'crouch_prone':      [20,21,22,23,24,25],
			'prone_shoot': [26,27,28,29,30],
			'stand_shoot': [32,33,34,35,36,37],
			'crouch_shoot': [38,39,40,41,42,43],
			'swim_idle': [44,45,46,47,48,49,50,51,52,53,54,55],
			'swim_slow': [56,57,58,59,60,61],
			'swim_fast': [62,63,64,65,66,67,68,69],
			'dead': [70],
			'standing': [71],
			'floating': [72],
			'dive_start': [73,74,75,76,77],
			'basic_swim': [78,79,80,81,82,83,84,85,86],
			'basic_swim': [78,79,80,81,82,83,84,85,86],
			'sit': [87],
			'shit': [88],
		},
	},
	// each key is initialized at the image loader.
	// = each key handles one image texture coords.
	'turret': {
		'anims': {
			// antiair:
			'aa_idle': [1],
			'aa_dead': [2],
			'aa_barrel': [3],
			'bomber_idle': [5],
			'bomber_dead': [6],
			'bomber_barrel': [7],
			
			// ground turret:
			// ?
		},
	},
	'mario': {
		'anims': {
			'stand_idle': [1],
			'walk': [1,2,3,2],
		},
	},
};




// returns frame coordinate from sprite index: (only works left to right, top to bottom).
function get_xy(pos, w, h, frames_x){
	let xf = pos % frames_x;
	let yf = Math.floor(pos/frames_x);
	this.x = xf*w;
	this.y = yf*h;
}



// returns frame offset as texture coordinates:
// get_frame get_animation_frame
function frame_offset(spriteName, animName, frameIndex){
	if(typeof SPRITES[spriteName] === "undefined"){
		console.log("UNKNOWN sprite['"+spriteName+"']");
		return {x:-1,y:-1};
	}else if(typeof SPRITES[spriteName]['anims_coords'][animName] === "undefined"){
		console.log("UNKNOWN sprite['"+spriteName+"']['"+animName+"']");
		return {x:-1,y:-1};
	}else if(typeof SPRITES[spriteName]['anims_coords'][animName][frameIndex] === "undefined"){
		console.log("UNKNOWN sprite['"+spriteName+"']['"+animName+"']["+frameIndex+"]");
		return {x:-1,y:-1};
	}else{
		return SPRITES[spriteName]['anims_coords'][animName][frameIndex]; // {x,y}
	}
}



function initialize_sprite(spriteName, w, h, sheet_w, sheet_h, frames_x){
	let sprite = SPRITES[spriteName];
	// add new values:
	sprite['w'] = w;
	sprite['h'] = h;
	sprite['sheet_w'] = sheet_w;
	sprite['sheet_h'] = sheet_h;
	sprite['frames_x'] = frames_x; // total frames horizontally in the sheet.
	sprite['anims_coords'] = {};

	let spriteAnims = sprite.anims;
	for(var animName in spriteAnims) {
		if(spriteAnims.hasOwnProperty(animName)){
			let anim = spriteAnims[animName];
			sprite['anims_coords'][animName] = [];
			for(let i = 0; i < anim.length; i++){
				// index starts from 1, so -1:
				let pos = new get_xy(anim[i]-1, w, h, frames_x);
				sprite['anims_coords'][animName].push({
					x: pos.x/sheet_w, // translate to texture coordinates offset values
					y: pos.y/sheet_h,
				});
			}
		}
	}
}




/*
function cache_all_sprite_anims(){
	for(var spriteName in SPRITES){
		if(SPRITES.hasOwnProperty(spriteName)){
			let sprite = SPRITES[spriteName];
			if(!sprite.hasOwnProperty('anims_coords')){
				sprite['anims_coords'] = [];
			}
			let spriteAnims = sprite.anims;
			for(var animName in spriteAnims) {
				if(spriteAnims.hasOwnProperty(animName)){
					let anim = spriteAnims[animName];
					if(!sprite['anims_coords'].hasOwnProperty(animName)){
						sprite['anims_coords'][animName] = [];
					}
					for(let i = 0; i < anim.length; i++){
						let pos = new get_xy(anim[i], sprite.w, sprite.h, sprite.frames_x);
						sprite['anims_coords'][animName].push(pos);
					}
				}
			}
		}
	}
	console.log(SPRITES);
}
*/




// checks if xy coord on map is ground or not
// hits_ground
function is_ground(x,y){
	let dx = Math.round(x+MAP_W/2);
	let dy = Math.round(y+MAP_H/2);
	
	if(dx >= 0 && dx < MAP_W && dy >= 0 && dy < MAP_H){
		if(MAP_DATA[dy*MAP_W+dx] > 40){
			return true;
		}
	}
	return false;
}






var skyboxColor = 0xFFFFFF;
var skyboxColorRain = 0xDDDDDD;

var cloudsColor = 0xFFFFFF;
var cloudsColorRain = 0x444444;


var rainMaxOpacity = 0.7; // values greater than 1 possible.
var raindropsMaxOpacity = 1; // values greater than 1 possible.

var nightskyMaxOpacity = 1.0;
var min_ambient_light = 0.25;
var max_ambient_light = 1.0;
var min_cloud_opa = 0.2;


var cloudColorFrom = cloudsColor; // will be initialized on rain switch.
var cloudColorTo = cloudsColorRain;

var skyboxColorFrom = skyboxColor; // will be initialized on rain switch.
var skyboxColorTo = skyboxColorRain;

var mapCollisionTex;
var mapParallaxTex;
var mapBehindTex;
var mapBehindEmissiveTex;
var mapFrontTex;
var mapTexWater;
var mapTexWaterDrops;

var bgTexImg1;
var bgTexImg2;
var cloudsFrontTex;
var cloudsBackTex;
var nightskyTex;






var playerSpriteTest;
var planeEmissiveTex;
var helicopterSpriteTest;
var helicopterEmissiveTex;
var santaSpriteTest;
var santaEmissiveTex;
var bomberEmissiveTex;
var soldierSpriteTest;
var explosionSpriteTest;
var splashSpriteTest;
var glowspriteTex;
var bombSpriteTest;
var shotSpriteTest;
var shotlightsTex;
var bomberSpriteTest;
var turretSpriteTest;
var streamSpriteTest;




var KEYS = {};

// key_pressed
function key_down(keyCode){
	if(KEYS.hasOwnProperty(keyCode)){
		return KEYS[keyCode];
	}
	return false;
}

var CANVAS_W = 1; // debug values. initialized at init()
var CANVAS_H = 1;

var MOUSE_X = -1; // -1 = not set.
var MOUSE_Y = -1;

var MOUSE_OFFSET_X = 0;
var MOUSE_OFFSET_Y = 0;

var prevBombTime = 0;
var bombStartTime = 0;
var bombingStarted = false;

let continuous_shoot_delay = 300; // continuous shooting starts after this time.
let planegun_delay = 80;
let bombgun_delay = 30;

let rainspeed = 1.4*1.6;
let rain_fade_speed = 0.01;
var night_fade_speed = 0.01;

let ambient_light = 1;


let GRAVITY_CONSTANT = 0.1; // was 0.06
let BUOYANCY_CONSTANT = 0.01; // force to player making him rise up from water.
// todo: shot prediction does not work with air resistance yet.
let AIR_RESISTANCE = 1;//0.995; // kx multiplied by this on air.
let WATER_RESISTANCE = 0.97; // kx multiplied by this in water.

let MAX_TARGET_DISTANCE = 1200; // how far turrets can shoot by default.

let MAX_TEX_SIZE = 1024; // will be initialized at pre_init

let antialiasing = false;

var MAP_DATA = null;
var COLLISION_DATA = {}; // all collideable sprites images are stored as 8bit per pixel data here for collision detection.

let map_defaults = {}; // default map settings which will be combined with map settings.json.
let mapinfo = {};


var OWNER_AI = -1; // ai owner id.


// player types:
var TYPE_PLANE = 0; // wind/air affected. not flipped.
var TYPE_SOLDIER = 1; // gravity/air affected. flipped in x axis when moving to other direction.
var TYPE_BOAT = 2; // water/air affected. flipped in x axis when moving to other direction.
var TYPE_SANTA = 3; // nothing affected? flipped in x axis when moving to other direction.
var TYPE_HELI = 4; // helicopter. flipped in x axis.

// player weapons:
var WEAPON_PLANEGUN = 0;
var WEAPON_SHOTGUN = 1;
var WEAPON_BOMB = 2;

// explosion types:
var EXPLOSION_ROUND = 0; // generic explosion anywhere since its circular shape.
var EXPLOSION_FLAT = 1; // explosion for buildings etc that are on flat surface.

// explosion sizes:
var EXPLOSION_TINY = 0;
var EXPLOSION_SMALL = 1;
var EXPLOSION_MEDIUM = 2;
var EXPLOSION_LARGE = 3; // explosion_big
var EXPLOSION_HUGE = 4;
var EXPLOSION_HUGE2 = 5;
var EXPLOSION_HUGE3 = 6;
var EXPLOSION_SHOTGUN = 7;

// splash sizes:
var SPLASH_TINY = 0;
var SPLASH_SMALL = 1;
var SPLASH_MEDIUM = 2;
var SPLASH_LARGE = 3;
var SPLASH_HUGE = 4;
var SPLASH_HUGE2 = 5;


// bomber plane types:
var PLANE_BOMBER = 0;
var PLANE_HORNET = 1;
var PLANE_UFO = 2;


// turret types:
var TURRET_ANTIAIR = 0; // turret shooting airplanes.
var TURRET_BOMBER = 1; // shooting bombs.
var TURRET_GROUND = 2; // turret shooting ground units.






var gameLoadedVar = false;

// list of things loaded or not. game wont start until all are loaded.
var loaded = {
	map_settings: false,
	glowsprite: false,
	nightsky: false,
	map: false,
	map_bg: false,
	map_behind: false,
	map_behind_lights: false,
	map_front: false,
	santa: false,
	santa_lights: false,
	plane: false,
	plane_lights: false,
	skybox: false,
	clouds: false,
	rain: false,
	water: false,
	waterdrops: false,
	explosions: false,
	bombs: false,
	splashes: false,
	shots: false,
	shots_lights: false,
	bomber: false,
	stream: false,
	turret: false,
	soldier: false,
	helicopter: false,
	helicopter_lights: false,
};






function load_textures(){
	for(let i = 0; i < TEXTURES.length; i++){
	/*
		soldierSpriteTest = new THREE.TextureLoader().load(texture_path('soldier_sprite_url'), function(tex){
			tex.image = correct_texture_size(tex.image);
			loaded.soldier = true;
			set_loading_desc("Soldier loaded");
			
			let scale = 3;
			let frameW = 52*scale;
			let frameH = 43*scale;
			let frames_x = 6;
			

		
			initialize_sprite('soldier', frameW, frameH, tex.image.width, tex.image.height, frames_x);
			console.log(SPRITES);

			soldierSpriteTest.minFilter = globalFilter;
			soldierSpriteTest.magFilter = globalFilter;
			soldierSpriteTest.repeat.x = frameW/tex.image.width;
			soldierSpriteTest.repeat.y = frameH/tex.image.height;
			soldierSpriteTest.offset.x = 0;
			soldierSpriteTest.offset.y = 0;
			soldierSpriteTest.flipY = false;
		});
		*/
	}
}





	
function rescale_skybox(){
	let aspect = CANVAS_W/CANVAS_H;
	nightskyTex.repeat.x = 1.3*aspect;
	nightskyTex.repeat.y = 1.3;
}


var rainfallMesh;
var behindMesh;
var cloudsMesh;
var skyboxMesh;
var nightskyMesh;

var waterDownBack;
var waterDownFront
var waterdropsMesh;

var mapMesh;
var mapMeshFlipped;

let sprites = {};
let spriteData = {};
let animations = {};




var controls, camera, scene, renderer;

var guivisible = 0;

// constants:
var fadetime = 2.0; // fadetime in secs to red color when time is up.
var gameMaxTimeSecs = fadetime; // in secs. should be same as fadetime.
var countdownTimeMax = 8; // in secs time to show the endscores.



var crystalCount = 80;


var defaultBoostTime = 1000000; // for players.


var framesPerFps = 20; // interval of frames how often fps is updated.

var mapsize = 10000;
var terrainVerts = 128;

var MAP_W = 1000; // will be initialized later. 
var MAP_H = 1000; // map height should be 50-100% longer than the map image height.

var maptex_w;
var maptex_h;




let edgePadX = 1750*3; // padding areas after which player would teleport
let edgePadY = 3300;




// state vars:
var countdownTimeStart = -1;

var myPlayer = 0;
let santaPlayer = 0;
let soldierPlayer = 0;

var gameStartTime = -1;

var gameEnding = false;
var gameEnded = false; // someone won now.
var prevEndingState = -1;




var players = [];

var lights = [];
var bombs = [];
var shots = [];
var explosions = [];
var splashes = [];
var bombers = [];
var turrets = []; // can be antiair or regular turret.
var visuals = []; // glow sprites etc... works same way as explosions basically.



var prevFpsTime = 0;

var ambient;
var light1;
var terrain;


var cameraCube, sceneCube;
var textureCube;
var texturePlayerCube;
var textureSpaceCube;
var textureCrystalCube;






function getTimeMillis(){
	var d = new Date();
	return d.getTime();
}


function startCountdownTimer(){
	countdownTimeStart = getTimeMillis();
}

function displayEndingScores(){
	$('#players-ending-scores').removeClass("hidden");
	$('#players').addClass("hidden");
}

function hideEndingScores(){
	$('#players-ending-scores').addClass("hidden");
	$('#players').removeClass("hidden");
}


function getPlayerScale(playerIndex){
	var scale = 1+players[playerIndex].score/10.0;
	if(scale > 3){
		scale = 3;
	}
	return scale;
}



function get_dist_2d(p1x, p1y, p2x, p2y){
	return Math.sqrt((p2x-p1x)*(p2x-p1x)+(p2y-p1y)*(p2y-p1y));
}


function point_inside_circle(px, py, cx, cy, radius){
	return (get_dist_2d(px, py, cx, cy) < radius);
}


function point_inside_rect(x, y,  x1, y1, x2, y2){
	if(x < x1) return false;
	if(x > x2) return false;
	if(y < y1) return false;
	if(y > y2) return false;
	return true;
}


function get_kxy_angle(angle){
	this.x = Math.sin((angle-90.0)*(Math.PI/180.0));
	this.z = Math.cos((angle-90.0)*(Math.PI/180.0));
}


function get_rads(angle){
	return angle*(Math.PI/180.0);
}


function get_kxy(from_x, from_y, to_x, to_y){
	var angle = (Math.atan2(to_y-from_y, from_x-to_x)/Math.PI)*180.0;
	this.x = Math.sin((angle-90.0)*(Math.PI/180.0));
	this.z = Math.cos((angle-90.0)*(Math.PI/180.0));
}

function get_angle(from_x, from_y, to_x, to_y){
	return (Math.atan2(to_y-from_y, from_x-to_x)/Math.PI)*180.0;
}

function get_angle_kxy(from_x, from_y, to_x, to_y, angle){
	var angle = (Math.atan2(to_y-from_y, from_x-to_x)/Math.PI)*180.0;
	this.x = Math.sin((angle-90.0)*(Math.PI/180.0));
	this.z = Math.cos((angle-90.0)*(Math.PI/180.0));	
}




var colorList = [0xFF9595, 0xFF95BD, 0xFF95E0, 0xFF65FA, 0xCAC1FF, 0x79B8FF, 0x19C1FF, 0x01EAFF, 0x01FFCC, 0x8BD783, 0x5CD050, 0xF8FF3F, 0xFBFF99, 0xFDFFCF, 0xFFE9CF, 0xFFC581, 0xFFA281];

var colorListHtml = ["#FF9595", "#FF95BD", "#FF95E0", "#FF65FA", "#CAC1FF", "#79B8FF", "#19C1FF", "#01EAFF", "#01FFCC", "#8BD783", "#5CD050", "#F8FF3F", "#FBFF99", "#FDFFCF", "#FFE9CF", "#FFC581", "#FFA281"];

function randomColor(){
	var ran = Math.floor(Math.random()*colorList.length);
	this.color = colorList[ran];
	this.colorHtml = colorListHtml[ran];
}


var randomWords = ["soldier", "admiral", "general", "lieutenant"];


function randomNick(){
	return randomWords[Math.floor(Math.random()*randomWords.length)];
}



function set_loading_desc(text){
	$("#loading_desc").text(text);
	console.log("LOADER: "+text);
}

pre_init();
animate();




function sort_by_score(a, b){
	if (a.score < b.score) return 1;
	if (a.score > b.score) return -1;
	return 0;
}

function updateScoreTable(){
	var html = "";
	var scoretable = [];
	for(var i = 0; i < players.length; i++){
		var playerName = players[i].nick;
		var playerScore = players[i].score;
		var bgStyle = "";
		if(i == myPlayer){
			bgStyle = '; border:1px dashed rgba(255,255,255, 0.25); margin:-1px';
		}
		scoretable.push({
			'name': playerName,
			'score': playerScore,
			'style': 'color:'+players[i].color+bgStyle,
		});
	}

	scoretable.sort(sort_by_score);
	var html = '<table id="ending-score-table" cellspacing="0" cellpadding="0" border="0">';
	for(var i = 0; i < scoretable.length; i++){
		var num = i+1;
		html += '<tr style="'+scoretable[i].style+'"><td class="num">'+num+'.</td><td class="nam" style="'+scoretable[i].style+'">'+scoretable[i].name+'</td><td class="sco">'+scoretable[i].score+'</td></tr>';
	}
	html += '</table>';
	
	$('#scores').html(html);
	$('#ending-scores').html(html);
}



function updateInfo(){
	let curplayer = players[myPlayer];
	let xpos = Math.round(curplayer.mesh.position.x*10)/10;
	let ypos = Math.round(curplayer.mesh.position.y*10)/10;
	let zpos = Math.round(curplayer.mesh.position.z*10)/10;
	let angle = Math.round(curplayer.angle*10)/10;
	$('#player-x').html(xpos.toFixed(1));
	$('#player-y').html(ypos.toFixed(1));
	$('#player-z').html(zpos.toFixed(1));
	$('#player-angle').html(angle.toFixed(1));
}
function updateScoreCount(){
	$('#player-y').html(players[myPlayer].score);
}


// set_speed
function setSpeed(i, speed){
	if(speed < 0) speed = 0;
	if(speed > 150) speed = 150;
	
	players[i].internal_speed = speed;
	let real_speed = Math.sqrt(speed*speed*5)/10;
	players[i].speed = real_speed;
}

// set_angle
function setAngle(i, angle){
	players[i].angle = angle;
}

function setShootAngle(i, angle){
	players[i].shoot_angle = angle;
}


// addscore()
function addPlayerScore(playerIndex, score){
	var prevScore = players[playerIndex].score;
	players[playerIndex].score += score;
	
	
	if(players[playerIndex].score < 0){
		players[playerIndex].score = 0;
	}
	//var scale = getPlayerScale(playerIndex);
	//players[playerIndex].mesh.scale.set(scale,scale,scale);
	
	if(playerIndex == myPlayer){
		updateScoreCount();
	}
	
	updateScoreTable();
}








function getGameTimeLeft(){
	if(gameStartTime == -1){
		return gameMaxTimeSecs;
	}
	var retval = gameMaxTimeSecs-((getTimeMillis()-gameStartTime)/1000.0);
	if(retval < 0){
		retval = 0;
	}
	return retval;
}



function initTimer(){
	gameStartTime = getTimeMillis();
	prevFpsTime = getTimeMillis();
}

function init_gui(){

	set_loading_desc("Initializing GUI");
	
	updateScoreTable();
}


function resetVars(){
	countdownTimeStart = -1;

	gameStartTime = -1;
	
	gameEnding = false;
	gameEnded = false; // someone won now.
	prevEndingState = -1;

	
	

	init_gui();
}




function add_player(mesh, type){
	if(typeof type === "undefined"){
		type = TYPE_PLANE;
	}
	let owner = players.length;
	var weapons1 = [
		WEAPON_PLANEGUN,
		WEAPON_SHOTGUN,
		WEAPON_BOMB,
	];
	var weapons2 = [
		WEAPON_BOMB,
		WEAPON_PLANEGUN,
	];
	
	players.push({
		'nick': randomNick(),
		'color': "#FFFFFF",
		'mesh': mesh, // includes our position also.
		'angle': 0,
		'shoot_angle': 0,
		'speed': 0,
		'speed_x': 0, // used for helicopters etc.
		'speed_z': 0,
		'internal_speed': 0,
		'score': 0,
		'boostTime': defaultBoostTime, // each frame takes 10 amount of boost. 1 is gained each frame.
		'boost': false, // if true, then boost is enabled.
		
		'kx': 0, // unused
		'kz': 0, // unused
		
		'x': mesh.position.x, // todo: stop using mesh position as player position.
		'z': mesh.position.z,
		'lane': 0, // -1, 0, 1 possible.
		'ammo': 1000000,
		'bombs': 1000000,
		'fuel': 1000000,
		'type': type, // 0 = TYPE_PLANE, 1 = TYPE_SOLDIER, 2 = TYPE_BOAT, 2 = TYPE_SANTA
		'underwater': false,
		'hit_time': -1,
		'health': 1000,
		'alive': true,
		'owner': owner,
		// primary weapons:
		'weapons1': weapons1, // list of weapons used by click (machinegun etc).
		'current1': 0, // current selected weapon from that list.
		// secondary weapons:
		'weapons2': weapons2, // list of weapons used by space (bombs etc).
		'current2': 0,
	});
	return players.length-1;
}









var SOUNDS = {
	// sounds last element is sound volume.

	//plane_flip:       [1,1,0,0.234,0.343,0.504,0.296,0,-0.241009,0,0.267,0.07778,0,0,0.365,0,0.718354,0,0,1,0,0,0,0,0.332],
	plane_flip: [1,3,0.164,0.243,0,0.383,0.358,0,0.249,-0.035681,0.049863,0.004714,-0.081,-0.007549,1,-0.05378,1,-0.377,-0.07,1.040697,-0.011889,0.015896,0.116385,0.030281,0.176],
	explosion_plane:  [1,3,0,0.354736,0.590014,0.775,0.074,0,0,0,0,0,0.295512,0.676919,0,0,0,0.176156,-0.054911,1,0,0,0,0,0.1068],
	explosion_bomb:   [1,3,0,0.287594,0.51717,0.855,0.117312,0,0,0,0.652,0.66,0,0,0,0,0,-0.146964,-0.004699,    1,0,0,0,0,0.25],
	//exp_2:          [1,3,0,0.287594,0.51717,0.855,0.117312,0,0,0,0.652,0.66,0,0,0,0,0,-0.146964,-0.004699,0.214,0,0,0,0,0.25],
					  
	explosion_bullet: [1,3,0,0.209,0.389,0.58,0.117312,0,0,0,0.652,0.66,0,0,0,0,0,-0.146964,-0.004699,0.717,-0.057,0,0,0,0.15],
	shotgun_bullet:   [1,3,0,0.017927,0,0.445,0.482781,0,-0.312528,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0.033],
	plane_machinegun: [1,3,0,0.373,0.413,0.521,0.078499,0,0.069127,0,0,0,0,0,0,0,0,-0.202749,-0.23743,0.883,-0.237,0,0,0,0.18],
	antiair_gun:      [1,3,0,0.294,0.355,0.494,0.053,0,0.192,0,0,0,0,0,0,0,0,-0.202749,-0.23743,0.883,-0.237,0,0,0,0.13],
	//superspeed:       [1,3,0,0.37668,0.751589,0.93,0.078499,0,0.069127,0,0,0,0,0,0,0,0,-0.202749,-0.23743,1,0,0,0,0,0.1068],
	bomb_drop:        [1,1,0,0.291667,0,1,0.898,0,-0.094,-0.066,0,0,0,0,0.26295,0,0,0,0,1,0,0,0,0,0.031068],
	bomb_splash:      [1,3,0,0.210467,0,0.554,0.279,0,0.167627,0,0,0,0,0,0.187778,0,0,0,0,1,0,0,0,0,0.107],
	plane_splash:     [1,3,0,0.538,0.365,0.68,0.194,0,0.167627,0,0,0,0,0,0.187778,0,0,0,0,1,0,0,0,0,0.113],
	bullet_splash:    [1,3,0,0.12,0,0.437,0.279,0,0.167627,0,0,0,0,0,0.187778,0,0,0,0,1,0,0,0,0,0.107],
	shotgun_splash:   [1,3,0,0.12,0,0.437,0.279,0,0.167627,0,0,0,0,0,0.187778,0,0,0,0,1,0,0,0,0,0.025],
	/*
	epic_shot: [1,3,0,0.287594,0.242,0.971,0.87,0,-0.567,-0.519,0.652,0.66,-0.46,0,0,0,0.545,0.509,-0.236,1,-0.46,0.653,0,0.214,0.25],
	weird: [1,0,0.010329,0.368026,0.267228,0.399649,0.167153,0,0.14828,0.107487,0.352807,-0.240237,-0.039997,-0.01731,0.78035,0.001718,-0.427861,-0.085225,0.305644,0.838106,-0.080457,0.031704,-0.174818,-0.016129,0.414],
	*/
	
	//////////
	// one-dimensional sounds only: no distance adjustments at all:
	// must start with underscore.
	_blip: [1,1,0,0.005078,0.532665,0.439482,0.614439,0,0,0,0,0,0.554557,0.53357,0,0,0,0,0,1,0,0,0,0,0.1068],
	_blip2: [1,1,0,0.084824,0.429053,0.351,0.391,0,0,0,0,0,-0.355,0.455,0,0,0,0,0,1,0,0,0,0,0.081],
	//_morse_beep_long: [1,1,0,0.431,0,0.177,0.529172,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0.1,0,0.1068],
	//_morse_beep_long_failure: [1,1,-0.058058,0.431,-0.030879,0.196496,0.529172,0,-0.056779,-0.035681,0.049863,0.004714,0.005416,-0.007549,1,-0.05378,0.012392,-0.0199,-0.028047,1.040697,-0.011889,0.015896,0.116385,0.030281,0.1068],
	//_morse_beep_short: [1,1,0,0.286,0,0.177,0.529172,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0.1,0,0.1068],
};






function uint32_to_array(val){
	let uint32val = (val >>> 0); // just in case convert to uint32
	return [
		uint32val & 255, 
		(uint32val >> 8) & 255, 
		(uint32val >> 16) & 255, 
		(uint32val >> 24) & 255, 
	];
}

function array_to_uint32(arr){
	return (arr[0] | (arr[1] << 8) | (arr[2] << 16) | (arr[3] << 24)) >>> 0;
}




function download_all_sounds(){

	function download(data, filename, type){
		// binary: "application/octet-stream"
		// text: "text/plain"
		// png: "image/png"
		var file = new Blob([data], {type: type});
		if(window.navigator.msSaveOrOpenBlob){ // IE10+
			window.navigator.msSaveOrOpenBlob(file, filename);
		}else{ // Others
			var a = document.createElement("a"), url = URL.createObjectURL(file);
			a.href = url;
			a.download = filename;
			document.body.appendChild(a);
			a.click();
			setTimeout(function(){
				document.body.removeChild(a);
				window.URL.revokeObjectURL(url);
			}, 0);
		}
	}
	
	let plaindata = [];
	
	for(let soundName in CACHED_SOUND_EFFECTS){
		let sound = CACHED_SOUND_EFFECTS[soundName].sound;
		// store soundname length and soundname string:
		let soundname_arr = uint32_to_array(soundName.length);
		for(let i = 0; i < soundName.length; i++){
			soundname_arr.push(soundName.charCodeAt(i));
		}
		plaindata = plaindata.concat(soundname_arr);

		for(let i = 0; i < sound.length; i++){
			let sound_data = sound[i].wav;
			plaindata = plaindata.concat(uint32_to_array(sound_data.length).concat(sound_data));
		}
	}
	
	download(Uint8Array.from(plaindata), "cached_sounds.dat", "application/octet-stream");
}






var CACHED_SOUND_EFFECTS = {};
// max_sounds max sounds

let sounds_detail = 1;
var MAX_SOUND_ALTS; // good for without downloading sound caches.
let param_step;
let param_min_val;

if(sounds_detail == 1){
	MAX_SOUND_ALTS = 4; // good for dev mode.
	param_step = 2.8;
	param_min_val = 0.08;
}else if(sounds_detail == 2){
	MAX_SOUND_ALTS = 13; // good for without downloading sound caches.
	param_step = 1.3;
	param_min_val = 0.08;
}else if(sounds_detail == 3){
	MAX_SOUND_ALTS = 64;
	param_step = 1.05;
	param_min_val = 0.06;
}




// load_sounds loading sounds generating_sounds generating sounds
function generate_sounds(){
	let i = 1;
	for(var soundName in SOUNDS) {
		if(SOUNDS.hasOwnProperty(soundName)){
			set_loading_desc("Generating sound "+i);
			i++;
			generate_sound_caches(soundName);
		}
	}
	
	console.log("CACHED_SOUND_EFFECTS");
	console.log(CACHED_SOUND_EFFECTS);
}


function generate_sound_caches(soundName){
	let newPARAMS = SOUNDS[soundName];
	
	if(newPARAMS[0] != 1){
		console.log("unknown sound version '"+newPARAMS[0]+"'");
		console.log(newPARAMS);
		return;
	}
	
	let order = ['jsfxr_version', 'wave_type', 'p_env_attack','p_env_sustain','p_env_punch','p_env_decay','p_base_freq','p_freq_limit','p_freq_ramp','p_freq_dramp','p_vib_strength','p_vib_speed','p_arp_mod','p_arp_speed','p_duty','p_duty_ramp','p_repeat_speed','p_pha_offset','p_pha_ramp','p_lpf_freq','p_lpf_ramp','p_lpf_resonance','p_hpf_freq','p_hpf_ramp','sound_vol'];
	
	let output = {};
	output['oldParams'] = true;
	output['sample_rate'] = 44100;
	output['sample_size'] = 8;

	for(let i = 1; i < order.length; i++){
		output[order[i]] = newPARAMS[i];
	}
	
	PARAMS.fromJSON(output);

	if(typeof CACHED_SOUND_EFFECTS[soundName] === "undefined"){
		CACHED_SOUND_EFFECTS[soundName] = {};
	}
	
	let max_sounds_gen = MAX_SOUND_ALTS;
	
	let distant_sounds = (soundName[0] !== '_') ? true : false; // non-distant sounds have underscore at start of name.
	if(!distant_sounds){
		max_sounds_gen = 1;
	}
	
	let step = (PARAMS['p_lpf_freq']-param_min_val)/MAX_SOUND_ALTS;
	
	for(let i = 0; i < max_sounds_gen; i++){
		SOUND = new SoundEffect(PARAMS).generate();
		if(typeof CACHED_SOUND_EFFECTS[soundName]['sound'] === "undefined"){
			CACHED_SOUND_EFFECTS[soundName]['sound'] = [];
		}
		CACHED_SOUND_EFFECTS[soundName]['sound'].push(SOUND);
		CACHED_SOUND_EFFECTS[soundName]['params'] = PARAMS;
	
		PARAMS['p_lpf_freq'] /= param_step; // aka "cutoff frequency"
		//PARAMS['p_lpf_freq'] -= step;
		if(PARAMS['p_lpf_freq'] <= param_min_val) PARAMS['p_lpf_freq'] = param_min_val;
	}
}


function play_sound(soundName, sound_x, sound_z){
	if(typeof CACHED_SOUND_EFFECTS[soundName] === "undefined"){
		return;
	}
	
	let play_sound = true;
	let dist_sound = 0;
	let is_distant_sound = (soundName[0] !== '_') ? true : false; // starting with underscore = single sound.
	
	if(is_distant_sound){
		let px = players[myPlayer].mesh.position.x;
		let pz = players[myPlayer].mesh.position.z;
		let dist = get_dist_2d(px, pz, sound_x, sound_z);
		
		let max_audible_dist = 3000;

		if(dist > 3000){
			play_sound = false;
		}else{
			if(dist > max_audible_dist){
				dist = max_audible_dist;
			}
			dist_sound = Math.round((dist/max_audible_dist)*(MAX_SOUND_ALTS-1));
			let total_sounds = CACHED_SOUND_EFFECTS[soundName]['sound'].length;
			if(dist_sound < 0) dist_sound = 0;
			if(dist_sound > total_sounds-1) dist_sound = total_sounds-1;
		}
	}
	if(play_sound){
		//console.log("dist_sound = "+dist_sound);
		SOUND = CACHED_SOUND_EFFECTS[soundName]['sound'][dist_sound];
		SOUND.getAudio().play();
	}
}



// generate_collision_data generate collision data
function generate_hit_data(tex){
	let data_w = tex.image.width;
	let data_h = tex.image.height;
	
	let outData = new Uint8Array(data_w*data_h);
	
	const tempCanvas = document.createElement('canvas');
	tempCanvas.width = data_w;
	tempCanvas.height = data_h;

	const tempCtx = tempCanvas.getContext('2d');
	tempCtx.drawImage(tex.image, 0, 0);

	const imageData = tempCtx.getImageData(0, 0, data_w, data_h);
	
	for(let y = 0; y < data_h; y++){
		for(let x = 0; x < data_w; x++){
			outData[y*data_w+x] = imageData.data[y*data_w*4+x*4+3]; // +3 = alpha channel.
		}
	}
	
	return outData;
}



function correct_texture_size(image){
	const canvas = document.createElement('canvas');
	const context = canvas.getContext('2d');

	let widthPow = 5;
	while(image.width > Math.pow(2, widthPow)){
		widthPow++;
	}
	let heightPow = 5;
	while(image.height > Math.pow(2, heightPow)){
		heightPow++;
	}

	canvas.width = Math.pow(2, widthPow);
	canvas.height = Math.pow(2, heightPow);
	context.drawImage(image, 0, 0);

	return canvas;
}


// if rect outside data area, then rect size and position changed accordingly.
// zero width means it is outside of data area.
function get_clamped_rect(data_w, data_h, x, y, w, h){
	if(x < 0){
		w = w+x;
		x = 0;
	}else if(x > data_w-1){
		w = 0;
		h = 0;
	}else if(x > data_w-w){
		w = data_w-x;
	}
	if(y < 0){
		h = h+y;
		y = 0;
	}else if(y > data_h-1){
		w = 0;
		h = 0;
	}else if(y > data_h-h){
		h = data_h-y;
		
	}
	return {'x':x, 'y':y, 'w':w, 'h':h};
}



function is_imagedata_empty(data, data_w, data_h){
	for(let y = 0; y < data_h; y++){
		for(let x = 0; x < data_w; x++){
			if(data[y*data_w*4+x*4+3] > 0){ // if not fully transparent; then visible.
				return false;
			}
		}
	}
	return true;
}



function is_area_empty(data, data_w, data_h, xp, yp, w, h){
	let rect = get_clamped_rect(data_w, data_h, xp, yp, w, h);
	if(!rect.w){
		return true; // was outside data area = empty.
	}
	let x1 = rect.x;
	let y1 = rect.y;
	let x2 = x1+rect.w;
	let y2 = y1+rect.h;
	for(let y = y1; y < y2; y++){
		for(let x = x1; x < x2; x++){
			if(data[y*data_w*4+x*4+3] > 0){ // if not fully transparent; then visible.
				return false;
			}
		}
	}
	return true;
}





// should generate it from bottom to top or the pieces are weirdly cut at bottom since the piece size is
function generate_compressed_map(tex){
	let image_w = tex.image.width;
	let image_h = tex.image.height;
	
	 // used to avoid texture bleeding when using mipmaps.
	 // edge pixels are repeated this many times.
	let padding = 0;
	
	// image split into blocksize-padding size squares.
	// this should be a power of 2 since mipmaps work that way too.
	let blockSize = 64;
	

	//let outData = new Uint8Array(data_w*data_h);
	
	const tempCanvas = document.createElement('canvas');
	tempCanvas.width = image_w;
	tempCanvas.height = image_h;
	const tempCtx = tempCanvas.getContext('2d');
	tempCtx.drawImage(tex.image, 0, 0);
	
	let out = "";
	
	let totalBlocks = 0;
	
	let blocks_x = Math.ceil(image_w/blockSize);
	let blocks_y = Math.ceil(image_h/blockSize);
	let maxBlocks = blocks_x*blocks_y;
	

	for(let y = 0; y < image_h; y+=blockSize){
		for(let x = 0; x < image_w; x+=blockSize){
			let imageData = tempCtx.getImageData(x, y, blockSize, blockSize);
			let empty = is_imagedata_empty(imageData.data, blockSize, blockSize);
			if(!empty){
				totalBlocks++;
			}
			out += empty ? '-' : 'O';
		}
		out += "\n";
	}
	
	let sq = Math.sqrt(totalBlocks);
	let sqblocks = Math.ceil(sq);
	let out_w = sqblocks*blockSize;
	let out_h = sqblocks*blockSize;
	let output_blocks = sqblocks*sqblocks;
	let compression_ratio = output_blocks/maxBlocks;
	
	//console.log(out);
	console.log("blocks required = "+totalBlocks);
	console.log("output texture blocks = "+output_blocks);
	console.log("maxBlocks = "+maxBlocks);
	console.log("out size = "+out_w+"x"+out_h);
	console.log("compression_ratio = "+(1/compression_ratio));
	


	/*
--------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------OOOOOOOOOOOOO----------------------------------------------------
---------------------------------------------------------------OOOOOOOOOOOOO----------------------------------------------------
-----------------------------------------------------------------OOOOOOOOOO-----------------------------------------------------
------------------------------------------------------------------OOOOOOO-------------------------------------------------------
------OOO----------------------------------------------------------OOOOO----------------------------------------------OOOO------
-----OOOO----------------------------------------------------------OOOO-----------------------------------------------OOOOO-----
-----OOOO----------------------------------------------------------OOOO-----------------------------------------------OOOOO-----
-----OOOO----------------------------------------------------------OOOO------------------------------------------------OOOO-----
-----OOOO----------------------------------------------------------OOOO-----------------------------------------------OOOOO-----
-----OOOO----------------------------------------------------------OOOO-----------------------------------------------OOOOO-----
----OOOOOO----------------------------OO--------------------------------------------------------OO--------------------OOOOOO----
----OOOOOOO--------------------------OOOOO-------------------------OOOO-----------------------OOOOOOO---------------OOOOOOOOOO--
--OOOOOOOOOOO----OOO-------------OOOOOOOOOOOO-------------------OOOOOOOOOO------------------OOOOOOOOOOO-----------OOOOOOOOOOOOOO
OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO
	*/
	/*
	const outputCanvas = document.createElement('canvas');
	outputCanvas.width = data_w;
	outputCanvas.height = data_h;
	const outputCtx = outputCanvas.getContext('2d');

	
	/*
	for(let y = 0; y < data_h; y++){
		for(let x = 0; x < data_w; x++){
			outData[y*data_w+x] = imageData.data[y*data_w*4+x*4];
		}
	}
	
	return outData;
	*/
}



// todo: find automatic places for random turrets.
function generate_placement_array(){
	let step = 64; // probably should be half the size of the object we want to place.
	let arr_w = Math.ceil(MAP_W/step);
	let arr_h = Math.ceil(MAP_H/step);
	for(let y = 0; y < MAP_H; y+=step){
		for(let x = 0; x < MAP_W; x+=step){
			// if opacity of pixel is large enough to be treated as ground:
			if(MAP_DATA[y*MAP_W+x] > 40){
				// ground found
			}else{
				// air found
				
			}
		}
	}
}





function load_units(units){
	for(let i = 0; i < units.length; i++){
		let unit = units[i];
		let type = -1;
		if(unit.type == "antiair"){
			type = TURRET_ANTIAIR;
		}else if(unit.type == "bomber"){
			type = TURRET_BOMBER;
		}
		if(type != -1){
			spawn_turret(unit.owner, unit.x, unit.y, type);
		}
	}
}





function show_texture_loading_warning(err){
	console.warn("Could not load texture: \""+err.path[0].currentSrc+"\", ignoring it.");
}



// f_(top) etc: if null, no fading (top), otherwise fading length.
function create_fading_plane_mesh(plane_w, plane_h, material, f_top, f_bottom, f_left, f_right){
	if(typeof f_top === "undefined") f_top = null;
	if(typeof f_bottom === "undefined") f_bottom = null;
	if(typeof f_left === "undefined") f_left = null;
	if(typeof f_right === "undefined") f_right = null;
	
	

	var geometry = new THREE.PlaneBufferGeometry(plane_w, plane_h, 3, 3);
	var count = geometry.attributes.position.count;
	let BPP = 4;
	geometry.addAttribute('color', new THREE.BufferAttribute(new Float32Array(count*BPP), BPP));
	
	let mesh = new THREE.Mesh(geometry, material);
	mesh.visible = SHOW_WAVE_BG;
	mesh.rotation.x = -Math.PI / 2;
	

	var peak = 8;
	var smoothing = 600;
	var vertices = mesh.geometry.attributes.position.array;
	var colors = mesh.geometry.attributes.color.array;
	
	console.log(colors.length);
	console.log(colors);

	//mesh.geometry.attributes.position.needsUpdate = true;
	//mesh.geometry.computeVertexNormals();
	
	
	//for(let y = 0; y < Y_VERT; y++){}
	/*
	for(var i = 0, c = 0; i <= vertices.length; i += 3, c+=BPP){
		vertices[i+2] = Z_SKYBOX+5;
	
		// default color to white:
		colors[c+0] = 1;
		colors[c+1] = 1;
		colors[c+2] = 1;
		colors[c+3] = 1;

	}
	*/
	mesh.geometry.attributes.position.needsUpdate = true;
	
	//console.log("mesh.geometry.attributes");
	//console.log(mesh.geometry.attributes);
	mesh.geometry.attributes.color.needsUpdate = true;
	return mesh;
}




function pre_init(){

	loading_start_time = getTimeMillis();

	console.log("GAME LOADING STARTED");


	CANVAS_W = window.innerWidth;
	CANVAS_H = window.innerHeight;

	
	console.log("CANVAS SIZE = "+CANVAS_W+"x"+CANVAS_H);	
	
	// DATA FILES:
	
	$.getJSON(map_data_url, function(json){
		loaded.map_settings = true;
		
		console.log("MAP SETTINGS:");
		console.log(json);
		
		// combine map_defaults with map settings.json:
		mapinfo = Object.assign(map_defaults, json);
	}).fail(function(){
		console.error("ERROR: Could not read file: '"+map_data_url+"'! File may be missing or incorrectly formatted (JSON is strict format, commas cannot be in end of lines unless another item comes after. All keys must be surrounded by double quotes, and all strings must be surrounded by double quotes).");
	});
	
	
	////////////////////////////
	// CAMERAS
	if(ortho){
		camera = new THREE.OrthographicCamera( -CANVAS_W/2, CANVAS_W/2, CANVAS_H/2, -CANVAS_H/2, 1, 1000000 );
		camera.zoom = INTERNAL_ZOOM;
	}else{
		camera = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 1, 100000);
	}
	
	camera.position.set(0, 300, 0);
	cameraCube = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 1, 100000);

	//////////////////////
	// CONTROLS FOR CAMERA
	//controls = new THREE.OrbitControls(camera);
	//controls.minDistance = 500;
	//controls.maxDistance = 25000;

	/////////////////////////////
	// SCENE
	scene = new THREE.Scene();
	sceneCube = new THREE.Scene();

	/////////////////////////////
	// Lights
	ambient = new THREE.AmbientLight(0xffffff);
	scene.add(ambient);
	


	
	
	
	// Textures
	//var r = urlprefix+"textures/landscape.png";
	var r = urlprefix+"textures/clouds/cloud-bg.jpg";
	var urls = [r, r, r, r, r, r];
	

	// reflective bumpy cloud mapping:
	textureCube = new THREE.CubeTextureLoader().load(urls);
	textureCube.format = THREE.RGBFormat;
	textureCube.mapping = THREE.CubeReflectionMapping;




	// load main map texture: (map_path map_plane) load_map
	set_loading_desc("Loading map");
	mapCollisionTex = new THREE.TextureLoader().load(texture_path('map_url'), function ( tex ) {
		tex.image = correct_texture_size(tex.image);
		loaded.map = true;
		set_loading_desc("Map loaded");
		
		// tex and texture are the same in this example, but that might not always be the case
		maptex_w = tex.image.width;
		maptex_h = tex.image.height;
		
		MAP_W = maptex_w;
		MAP_H = maptex_h;

		// make texture pixelized (min and mag needed both!):
		//let filter = THREE.NearestFilter;
		let filter = globalFilter;
		mapCollisionTex.minFilter = filter;
		mapCollisionTex.magFilter = filter;
		
		set_loading_desc("Creating map data");
		
		MAP_DATA = new generate_hit_data(tex);
		generate_placement_array();
		
		generate_compressed_map(tex);
		
		
		
		set_loading_desc("Map data created");
		

		
		// create playable map plane:
		{
		
			console.log("mapCollisionTex = "+maptex_w+"x"+maptex_h);
			let geometry = new THREE.PlaneGeometry(maptex_w, maptex_h);


			
			{
				let material = new THREE.MeshPhongMaterial({map: mapCollisionTex, color: 0xFFFFFF});  
				material.transparent = true;
				material.side = THREE.DoubleSide;
				material.alphaTest = 0.5;
				mapMesh = new THREE.Mesh(geometry, material);
				//let mscale = 1;
				mapMesh.rotation.x = -Math.PI/2;
				mapMesh.position.x = 0;
				mapMesh.position.y = Z_MAP_COLLISION;
				mapMesh.position.z = 0;
				//mapMesh.scale.set(mscale,mscale,mscale);
				scene.add(mapMesh);
			}
			{	
				let material = new THREE.MeshPhongMaterial({map: mapCollisionTex, color: 0xBBBBBB});  
				material.transparent = true;
				material.opacity = 0.2;
				material.side = THREE.DoubleSide;		
				mapMeshFlipped = new THREE.Mesh(geometry, material);
				let mscale = 1;
				mapMeshFlipped.rotation.x = -Math.PI/2;
				mapMeshFlipped.position.x = 0;
				mapMeshFlipped.position.y = Z_MAP_COLLISION;
				mapMeshFlipped.position.z = maptex_h;
				mapMeshFlipped.scale.set(mscale,-mscale,mscale);
				scene.add(mapMeshFlipped);
			}
		}
		
		
		
		// load map water layer (comes under the flipped map)
		mapTexWater = new THREE.TextureLoader().load(texture_path('map_water_url'), function ( tex ) {
			tex.image = correct_texture_size(tex.image);
			loaded.water = true;
			set_loading_desc("Water loaded");
			
			mapTexWater.minFilter = THREE.LinearFilter;
			mapTexWater.magFilter = THREE.LinearFilter;
			mapTexWater.repeat.x = 0.5*2;
			mapTexWater.repeat.y = 2*3.333;

			mapTexWater.wrapS = THREE.RepeatWrapping;
			mapTexWater.wrapT = THREE.RepeatWrapping;
			
			{
				let geometry = new THREE.PlaneGeometry(maptex_w*4, maptex_h*10);

				
				{
					let material = new THREE.MeshPhongMaterial({map: mapTexWater, color: 0xDDDDDD});  
					material.transparent = true;
					material.opacity = 0.4;
					material.side = THREE.DoubleSide;

					waterDownBack = new THREE.Mesh(geometry, material);
					waterDownBack.visible = true;
					let mscale = 1;
					waterDownBack.position.x = 0;
					waterDownBack.position.y = Z_MAP_WATER_BACK;
					waterDownBack.position.z = maptex_h*4+maptex_h*1.5;
					
					waterDownBack.rotation.x = -Math.PI/2;
					waterDownBack.scale.set(mscale,mscale,mscale); // outwards
					scene.add(waterDownBack);
				}
				{
					let material = new THREE.MeshPhongMaterial({map: mapTexWater, color: 0xDDDDDD});  
					material.transparent = true;
					material.opacity = 0.6;
					material.side = THREE.DoubleSide;
					
					waterDownFront = new THREE.Mesh(geometry, material);
					waterDownFront.visible = true;
					let mscale = 1;
					waterDownFront.position.x = 0;
					waterDownFront.position.y = Z_MAP_WATER_FRONT;
					waterDownFront.position.z = maptex_h*4+maptex_h*1.5;
					
					waterDownFront.rotation.x = -Math.PI/2;
					waterDownFront.scale.set(mscale,-mscale,mscale); // inwards
					scene.add(waterDownFront);
				}
			}
		});
		
		
		// load map water layer (comes under the flipped map)
		mapTexWaterDrops = new THREE.TextureLoader().load(texture_path('map_waterdrops_url'), function ( tex ) {
			tex.image = correct_texture_size(tex.image);
			loaded.waterdrops = true;
			set_loading_desc("Waterdrops loaded");
			
			mapTexWaterDrops.minFilter = THREE.LinearFilter;
			mapTexWaterDrops.magFilter = THREE.LinearFilter;
			mapTexWaterDrops.repeat.x = 4*2*0.66;
			mapTexWaterDrops.repeat.y = (4096/128)*5*0.66;

			mapTexWaterDrops.wrapS = THREE.RepeatWrapping;
			mapTexWaterDrops.wrapT = THREE.RepeatWrapping;
			
			{
				let geometry = new THREE.PlaneGeometry(maptex_w*4, maptex_h*10);

				
				{
					let material = new THREE.MeshPhongMaterial({map: mapTexWaterDrops, color: 0xDDDDDD});  
					material.transparent = true;
					material.opacity = SHOW_RAIN_BG ? raindropsMaxOpacity : 0;
					material.side = THREE.DoubleSide;
					//material.blending = THREE.AdditiveBlending;
				
					waterdropsMesh = new THREE.Mesh(geometry, material);
					waterdropsMesh.visible = SHOW_RAIN_BG;
					let mscale = 1;
					waterdropsMesh.position.x = 0;
					waterdropsMesh.position.y = Z_MAP_WATERDROPS;
					waterdropsMesh.position.z = maptex_h*4+maptex_h*1.5;
					
					waterdropsMesh.rotation.x = -Math.PI/2;
					waterdropsMesh.scale.set(mscale,mscale,mscale);
					scene.add(waterdropsMesh);
				}
			}
		});
		
		
		
		// load map sprites background layer:
		mapBehindEmissiveTex = new THREE.TextureLoader().load(texture_path('map_behind_lights_url'), function ( tex ) {
			tex.image = correct_texture_size(tex.image);
			loaded.map_behind_lights = true;
			set_loading_desc("Map behind lights loaded");
			
			mapBehindEmissiveTex.minFilter = globalFilter;
			mapBehindEmissiveTex.magFilter = globalFilter;
		}, null, function(err){
			loaded.map_behind_lights = true;
			show_texture_loading_warning(err);
		});
		
		
		// load map sprites background layer:
		mapBehindTex = new THREE.TextureLoader().load(texture_path('map_behind_url'), function ( tex ) {
			tex.image = correct_texture_size(tex.image);
			loaded.map_behind = true;
			set_loading_desc("Map behind loaded");
			
			mapBehindTex.minFilter = globalFilter;
			mapBehindTex.magFilter = globalFilter;

			{
				let geometry = new THREE.PlaneGeometry(maptex_w, maptex_h);
				let material = new THREE.MeshPhongMaterial({map: mapBehindTex, color: 0xFFFFFF});  
				material.transparent = true;
				material.opacity = 1;
				material.alphaTest = 0.5;
				material.side = THREE.DoubleSide;
				material.emissive.set(0xFFFFFF);
				material.emissiveMap = mapBehindEmissiveTex;
				material.emissiveIntensity = 0;
					
				behindMesh = new THREE.Mesh(geometry, material);
				behindMesh.visible = SHOW_MAP_BG;
				let mscale = 1;
				behindMesh.position.x = 0;
				behindMesh.position.y = Z_MAP_BEHIND;
				behindMesh.position.z = 0;
				
				behindMesh.rotation.x = -Math.PI/2;
				behindMesh.scale.set(mscale,mscale,mscale);
				scene.add(behindMesh);
			}
		}, null, function(err){
			loaded.map_behind = true;
			show_texture_loading_warning(err);
		});
		
		
		
		mapFrontTex = new THREE.TextureLoader().load(texture_path('map_front_url'), function ( tex ) {
			tex.image = correct_texture_size(tex.image);
			loaded.map_front = true;
			set_loading_desc("Map front loaded");
			
			mapFrontTex.minFilter = globalFilter;
			mapFrontTex.magFilter = globalFilter;

			{
				let geometry = new THREE.PlaneGeometry(maptex_w, maptex_h);
				let material = new THREE.MeshPhongMaterial({map: mapFrontTex, color: 0xFFFFFF});  
				material.transparent = true;
				material.opacity = 1;
				material.alphaTest = 0.5;
				material.side = THREE.DoubleSide;
					
				let mapobj2 = new THREE.Mesh(geometry, material);
				mapobj2.visible = SHOW_MAP_BG;
				let mscale = 1;
				mapobj2.position.x = 0;
				mapobj2.position.y = Z_MAP_FRONT;
				mapobj2.position.z = 0;
				
				mapobj2.rotation.x = -Math.PI/2;
				mapobj2.scale.set(mscale,mscale,mscale);
				scene.add(mapobj2);
			}
		}, null, function(err){
			loaded.map_front = true;
			show_texture_loading_warning(err);
		});


		
		
		// load second background layer (parallax):
		mapParallaxTex = new THREE.TextureLoader().load(texture_path('map_bg_parallax_url'), function ( tex ) {
			tex.image = correct_texture_size(tex.image);
			loaded.map_bg = true;
			set_loading_desc("Map background loaded");
			
			mapParallaxTex.minFilter = THREE.LinearFilter; // makes rain more crispy looking (=better).
			mapParallaxTex.magFilter = THREE.LinearFilter;
			
			{
				let geometry = new THREE.PlaneGeometry(maptex_w, maptex_h);
				let material = new THREE.MeshPhongMaterial({map: mapParallaxTex, color: 0x666666});  
				material.transparent = true;
				material.opacity = 1;
				material.side = THREE.DoubleSide;
					
				let mapobj2 = new THREE.Mesh(geometry, material);
				mapobj2.visible = SHOW_MAP_BG;
				let mscale = 1;
				mapobj2.position.x = 0;
				mapobj2.position.y = Z_MAP_BG;
				mapobj2.position.z = 0;
			
				mapobj2.rotation.x = -Math.PI/2;
				mapobj2.scale.set(mscale,mscale,mscale);
				scene.add(mapobj2);
			}
		}, null, function(err){
			loaded.map_bg = true;
			show_texture_loading_warning(err);
		});
		
		
		
		// load "skybox" parallax:
		cloudsBackTex = new THREE.TextureLoader().load(texture_path('clouds_back_url'), function ( tex ) {
			tex.image = correct_texture_size(tex.image);
			loaded.skybox = true;
			set_loading_desc("Sky loaded");
			
			cloudsBackTex.minFilter = THREE.LinearFilter;
			cloudsBackTex.magFilter = THREE.LinearFilter;
			
			cloudsBackTex.repeat.x = 20.8;
			cloudsBackTex.repeat.y = 17.3316;
			
			cloudsBackTex.wrapS = THREE.RepeatWrapping;
			cloudsBackTex.wrapT = THREE.RepeatWrapping;

			{
			
				let geometry = new THREE.PlaneGeometry(maptex_w*4, maptex_h*20);
				let material = new THREE.MeshPhongMaterial({map: cloudsBackTex, color: skyboxColor});
				material.transparent = true;
				material.opacity = SHOW_NIGHTSKY_BG ? 0 : 1;
				material.side = THREE.DoubleSide;
					
				skyboxMesh = new THREE.Mesh(geometry, material);
				let mscale = 1;
				skyboxMesh.visible = !SHOW_NIGHTSKY_BG;
				skyboxMesh.position.x = 0;
				skyboxMesh.position.y = Z_SKYBOX;
				skyboxMesh.position.z = 0;

				skyboxMesh.rotation.x = -Math.PI/2;
				skyboxMesh.scale.set(mscale,mscale,mscale);
				scene.add(skyboxMesh);
			}
		});
		
		

		// load "skybox" parallax:
		nightskyTex = new THREE.TextureLoader().load(texture_path('nightsky_url'), function ( tex ) {
			tex.image = correct_texture_size(tex.image);
			loaded.nightsky = true;
			set_loading_desc("Nightsky loaded");
			
			nightskyTex.minFilter = THREE.LinearFilter;
			nightskyTex.magFilter = THREE.LinearFilter;
			
			rescale_skybox();
			
			nightskyTex.wrapS = THREE.RepeatWrapping;
			nightskyTex.wrapT = THREE.RepeatWrapping;
			/*

			{
				let geometry = new THREE.PlaneGeometry(maptex_w*4, maptex_h*20);
				let material = new THREE.MeshBasicMaterial({map: nightskyTex, color: skyboxColor});
				material.transparent = true;
				material.opacity = SHOW_NIGHTSKY_BG ? nightskyMaxOpacity : 0;
				material.side = THREE.DoubleSide;
					
				nightskyMesh = new THREE.Mesh(geometry, material);
				let mscale = 1;
				nightskyMesh.visible = SHOW_NIGHTSKY_BG;
				nightskyMesh.position.x = 0;
				nightskyMesh.position.y = Z_SKYBOX;
				nightskyMesh.position.z = 0;
			
				nightskyMesh.rotation.x = -Math.PI/2;
				nightskyMesh.scale.set(mscale,mscale,mscale);
				scene.add(nightskyMesh);
				
			}
			*/
		});
		
		
		scene.background = nightskyTex; // add skybox. this simple!
		
		
		
		// load clouds parallax:
		cloudsFrontTex = new THREE.TextureLoader().load(texture_path('clouds_front_url'), function ( tex ) {
			tex.image = correct_texture_size(tex.image);
			loaded.clouds = true;
			set_loading_desc("Clouds loaded");
			
			// make texture pixelized (min and mag needed both!):
			cloudsFrontTex.minFilter = THREE.LinearFilter;
			cloudsFrontTex.magFilter = THREE.LinearFilter;
			cloudsFrontTex.repeat.x = 20*0.26*2;
			cloudsFrontTex.repeat.y = 5*0.26*6.666;
			
			cloudsFrontTex.wrapS = THREE.RepeatWrapping;
			cloudsFrontTex.wrapT = THREE.RepeatWrapping;

			{
				let material = new THREE.MeshPhongMaterial({map: cloudsFrontTex, color: cloudsColor});
				material.transparent = true;
				material.opacity = 0.9;
				material.side = THREE.DoubleSide;

				let geometry = new THREE.PlaneGeometry(maptex_w*4, maptex_h*20);
				cloudsMesh = new THREE.Mesh(geometry, material);
				// TODO: needs buildAlphaMaterial() to work.
				//cloudsMesh = create_fading_plane_mesh(maptex_w*4, maptex_h*20, material, 1024);

				cloudsMesh.position.x = 0;
				cloudsMesh.position.y = Z_CLOUDS;
				cloudsMesh.position.z = 0;
				
				cloudsMesh.rotation.x = -Math.PI/2;

				scene.add(cloudsMesh);
			}
		});


		

		// load rain rainfall:
		bgTexImg2 = new THREE.TextureLoader().load(texture_path('bg2_url'), function ( tex ) {
			tex.image = correct_texture_size(tex.image);
			loaded.rain = true;
			set_loading_desc("Rain loaded");
			
			// make texture pixelized (min and mag needed both!):
			bgTexImg2.minFilter = THREE.NearestFilter; // makes rain more crispy looking (=better).
			bgTexImg2.magFilter = THREE.NearestFilter;
			bgTexImg2.repeat.x = 20*2*(5/10)*2;
			bgTexImg2.repeat.y = 20*2*(3/10)*6.666;
			
			bgTexImg2.wrapS = THREE.RepeatWrapping;
			bgTexImg2.wrapT = THREE.RepeatWrapping;
			
			// create playable map plane:
			{
			
				let geometry = new THREE.PlaneGeometry(maptex_w*4, maptex_h*20);
				let material = new THREE.MeshPhongMaterial({map: bgTexImg2, color: 0xFFFFFF});  
				material.transparent = true;
				material.opacity = SHOW_RAIN_BG ? rainMaxOpacity : 0;
				//material.blending = THREE.AdditiveBlending;
				material.side = THREE.DoubleSide;
					
				rainfallMesh = new THREE.Mesh(geometry, material);
				rainfallMesh.visible = SHOW_RAIN_BG; 
				let mscale = 1;
				rainfallMesh.position.x = 0;
				rainfallMesh.position.y = Z_RAIN;
				rainfallMesh.position.z = 0;
				
			
				rainfallMesh.rotation.x = -Math.PI/2;
				rainfallMesh.scale.set(mscale,mscale,mscale);
				scene.add(rainfallMesh);
				
				//console.log(rainfallMesh);
				
				//console.log(bgTexImg2);
				
			}
		});
		
		
	});
	
	
	
	
	
	/*
	
	marioSpriteTest = new THREE.TextureLoader().load(texture_path('mario_sprite_url'), function(tex){
		tex.image = correct_texture_size(tex.image);
		loaded.antiair = true;
		set_loading_desc("Antiair loaded");
		
		let frameW = 28;
		let frameH = 19;
		let frames_x = 2;
	
		initialize_sprite('antiair', frameW, frameH, tex.image.width, tex.image.height, frames_x);
		//console.log(SPRITES);

		marioSpriteTest.minFilter = THREE.NearestFilter;//globalFilter;
		marioSpriteTest.magFilter = THREE.NearestFilter;//globalFilter;
		marioSpriteTest.repeat.x = frameW/tex.image.width;
		marioSpriteTest.repeat.y = frameH/tex.image.height;
		marioSpriteTest.offset.x = 0;
		marioSpriteTest.offset.y = 0;
		marioSpriteTest.flipY = false;
		
		{
			let geometry = new THREE.PlaneGeometry(frameW,frameH);
			let material = new THREE.MeshPhongMaterial({map: marioSpriteTest, color: 0xFFFFFF});  			
			material.color.set(0xFFFFFF);
			material.transparent = true;
			material.side = THREE.DoubleSide;

			let mesh = new THREE.Mesh(geometry, material);
			let mscale = 1;
			mesh.position.x = 300;
			mesh.position.y = Z_SOLDIER;
			mesh.position.z = 330;

			mesh.rotation.x = -Math.PI/2;
			mesh.scale.set(mscale,mscale,mscale);
			
			var i = add_player(mesh, TYPE_SOLDIER);
			scene.add(players[i].mesh);
		}
		
	});
	*/
	
	// antiair_sprite antiairSprite
	turretSpriteTest = new THREE.TextureLoader().load(texture_path('turret_sprite_url'), function(tex){
		tex.image = correct_texture_size(tex.image);
		loaded.turret = true;
		set_loading_desc("Turret loaded");
		
		let frameW = 32*3;
		let frameH = 19*3;
		let frames_x = 2;
	
		initialize_sprite('turret', frameW, frameH, tex.image.width, tex.image.height, frames_x);
		//console.log(SPRITES);

		turretSpriteTest.minFilter = globalFilter;
		turretSpriteTest.magFilter = globalFilter;
		turretSpriteTest.repeat.x = frameW/tex.image.width;
		turretSpriteTest.repeat.y = frameH/tex.image.height;
		turretSpriteTest.offset.x = 0;
		turretSpriteTest.offset.y = 0;
		turretSpriteTest.flipY = false;

	});

	
	
	
	soldierSpriteTest = new THREE.TextureLoader().load(texture_path('soldier_sprite_url'), function(tex){
		tex.image = correct_texture_size(tex.image);
		loaded.soldier = true;
		set_loading_desc("Soldier loaded");
		
		let scale = 3;
		let frameW = 52*scale;
		let frameH = 43*scale;
		let frames_x = 6;
		
	
		initialize_sprite('soldier', frameW, frameH, tex.image.width, tex.image.height, frames_x);
		console.log(SPRITES);

		soldierSpriteTest.minFilter = globalFilter;
		soldierSpriteTest.magFilter = globalFilter;
		soldierSpriteTest.repeat.x = frameW/tex.image.width;
		soldierSpriteTest.repeat.y = frameH/tex.image.height;
		soldierSpriteTest.offset.x = 0;
		soldierSpriteTest.offset.y = 0;
		soldierSpriteTest.flipY = false;
		
		{
			let geometry = new THREE.PlaneGeometry(frameW/scale,frameH/scale);
			let material = new THREE.MeshPhongMaterial({map: soldierSpriteTest, color: 0xFFFFFF});  			
			material.color.set(0xFFFFFF);
			material.transparent = true;
			material.alphaTest = 0.5;
			material.side = THREE.DoubleSide;

			let mesh = new THREE.Mesh(geometry, material);
			let mscale = 1;
			mesh.position.x = -941;
			mesh.position.y = Z_SOLDIER;
			mesh.position.z = 450;

			mesh.rotation.x = -Math.PI/2;
			mesh.scale.set(mscale,mscale,mscale);
			
			var i = add_player(mesh, TYPE_SOLDIER);
			soldierPlayer = i;
			scene.add(players[i].mesh);
		}
		
	});
	
	

	bomberEmissiveTex = new THREE.TextureLoader().load(texture_path('bomber_lights_sprite_url'), function(tex){
		tex.image = correct_texture_size(tex.image);
		loaded.bomber_lights = true;
		set_loading_desc("Bomber lights loaded");
		
		let w = 1024;
		let h = 256;

		bomberEmissiveTex.minFilter = THREE.LinearFilter;//globalFilter;
		bomberEmissiveTex.magFilter = THREE.LinearFilter;//globalFilter;
		bomberEmissiveTex.repeat.x = w/tex.image.width;
		bomberEmissiveTex.repeat.y = h/tex.image.height;
		bomberEmissiveTex.offset.x = 0;
		bomberEmissiveTex.offset.y = 0;
		bomberEmissiveTex.flipY = false;
	});
	
	
	
	bomberSpriteTest = new THREE.TextureLoader().load(texture_path('bomber_sprite_url'), function(tex){
		tex.image = correct_texture_size(tex.image);
		loaded.bomber = true;
		set_loading_desc("Bomber loaded");
		
		let w = 1024;
		let h = 256;

		bomberSpriteTest.minFilter = THREE.LinearFilter;//globalFilter;
		bomberSpriteTest.magFilter = THREE.LinearFilter;//globalFilter;
		bomberSpriteTest.repeat.x = w/tex.image.width;
		bomberSpriteTest.repeat.y = h/tex.image.height;
		bomberSpriteTest.offset.x = 0;
		bomberSpriteTest.offset.y = 0;
		bomberSpriteTest.flipY = false;
		
		set_loading_desc("Creating hit data");
		
		COLLISION_DATA['bomber'] = new generate_hit_data(tex);
		
		set_loading_desc("Hit data created");
		
	});
	
	
	
	
	loaded.stream = true;
/*
	streamSpriteTest = new THREE.TextureLoader().load(texture_path('stream_sprite_url'), function(tex){
		tex.image = correct_texture_size(tex.image);
		loaded.stream = true;
		set_loading_desc("Stream loaded");
		
		let w = 256;
		let h = 32;

		streamSpriteTest.minFilter = THREE.LinearFilter;//globalFilter;
		streamSpriteTest.magFilter = THREE.LinearFilter;//globalFilter;
		streamSpriteTest.repeat.x = w/tex.image.width;
		streamSpriteTest.repeat.y = h/tex.image.height;
		streamSpriteTest.offset.x = 0;
		streamSpriteTest.offset.y = 0;
		streamSpriteTest.flipY = false;
	});
	*/
	

	shotSpriteTest = new THREE.TextureLoader().load(texture_path('shots_sprite_url'), function(tex){
		tex.image = correct_texture_size(tex.image);
		loaded.shots = true;
		set_loading_desc("Shots loaded");
		
		let w = 64;
		let h = 16;

		shotSpriteTest.minFilter = THREE.LinearFilter;
		shotSpriteTest.magFilter = THREE.LinearFilter;
		shotSpriteTest.repeat.x = w/tex.image.width;
		shotSpriteTest.repeat.y = h/tex.image.height;
		shotSpriteTest.offset.x = 0;
		shotSpriteTest.offset.y = 0;
		shotSpriteTest.flipY = false;
		
		shotlightsTex = new THREE.TextureLoader().load(texture_path('shots_lights_sprite_url'), function(tex){
			tex.image = correct_texture_size(tex.image);
			loaded.shots_lights = true;
			set_loading_desc("Shots loaded");
			
			let w = 64;
			let h = 16;

			shotlightsTex.minFilter = THREE.LinearFilter;
			shotlightsTex.magFilter = THREE.LinearFilter;
			shotlightsTex.repeat.x = w/tex.image.width;
			shotlightsTex.repeat.y = h/tex.image.height;
			shotlightsTex.offset.x = 0;
			shotlightsTex.offset.y = 0;
			shotlightsTex.flipY = false;
		});
	});
	
	
	
	
	bombSpriteTest = new THREE.TextureLoader().load(texture_path('bombs_sprite_url'), function(tex){
		tex.image = correct_texture_size(tex.image);
		loaded.bombs = true;
		set_loading_desc("Bombs loaded");
		
		let w = 25;
		let h = 17;

		bombSpriteTest.minFilter = globalFilter;
		bombSpriteTest.magFilter = globalFilter;
		bombSpriteTest.repeat.x = w/tex.image.width;
		bombSpriteTest.repeat.y = h/tex.image.height;
		bombSpriteTest.offset.x = 0;
		bombSpriteTest.offset.y = 0;
		bombSpriteTest.flipY = false;
	});
	
	
	
	
	splashSpriteTest = new THREE.TextureLoader().load(texture_path('splash_sprite_url'), function(tex){
		tex.image = correct_texture_size(tex.image);
		loaded.splashes = true;
		set_loading_desc("Splash loaded");
		
		let w = 128;
		let h = 128;

		splashSpriteTest.minFilter = globalFilter;
		splashSpriteTest.magFilter = globalFilter;
		splashSpriteTest.repeat.x = w/tex.image.width;
		splashSpriteTest.repeat.y = h/tex.image.height;
		splashSpriteTest.offset.x = 0;
		splashSpriteTest.offset.y = 0;
		splashSpriteTest.flipY = false;
	});
	




	glowspriteTex = new THREE.TextureLoader().load(texture_path('glowsprite_url'), function(tex){
		tex.image = correct_texture_size(tex.image);
		loaded.glowsprite = true;
		set_loading_desc("Glowsprite loaded");
		
		let w = 128;
		let h = 128;

		glowspriteTex.minFilter = globalFilter;
		glowspriteTex.magFilter = globalFilter;
		glowspriteTex.repeat.x = w/tex.image.width;
		glowspriteTex.repeat.y = h/tex.image.height;
		glowspriteTex.offset.x = 0;
		glowspriteTex.offset.y = 0;
		glowspriteTex.flipY = false;
	});
	
	
	
	explosionSpriteTest = new THREE.TextureLoader().load(texture_path('explosion_sprites_url'), function(tex){
		tex.image = correct_texture_size(tex.image);
		loaded.explosions = true;
		set_loading_desc("Explosions loaded");
		
		let w = 128;
		let h = 128;

		explosionSpriteTest.minFilter = globalFilter;
		explosionSpriteTest.magFilter = globalFilter;
		explosionSpriteTest.repeat.x = w/tex.image.width;
		explosionSpriteTest.repeat.y = h/tex.image.height;
		explosionSpriteTest.offset.x = 0;
		explosionSpriteTest.offset.y = 0;
		explosionSpriteTest.flipY = false;
	});
	
	
	
	
	santaSpriteTest = new THREE.TextureLoader().load(texture_path('santa_sprite_url'), function(tex){
		tex.image = correct_texture_size(tex.image);
		loaded.santa = true;
		set_loading_desc("Santa loaded");
		
		let w = 167;
		let h = 58;

		santaSpriteTest.minFilter = globalFilter;
		santaSpriteTest.magFilter = globalFilter;
		santaSpriteTest.repeat.x = w/tex.image.width;
		santaSpriteTest.repeat.y = h/tex.image.height;
		santaSpriteTest.offset.x = 0;
		santaSpriteTest.offset.y = 0;
		santaSpriteTest.flipY = false;
		
		
		santaEmissiveTex = new THREE.TextureLoader().load(texture_path('santa_lights_sprite_url'), function(tex){
			tex.image = correct_texture_size(tex.image);
			loaded.santa_lights = true;
			set_loading_desc("Santa lights loaded");
			
			let w = 167;
			let h = 58;

			santaEmissiveTex.minFilter = globalFilter;
			santaEmissiveTex.magFilter = globalFilter;
			santaEmissiveTex.repeat.x = w/tex.image.width;
			santaEmissiveTex.repeat.y = h/tex.image.height;
			santaEmissiveTex.offset.x = 0;
			santaEmissiveTex.offset.y = 0;
			santaEmissiveTex.flipY = false;
			


			
			let geometry = new THREE.PlaneGeometry(w, h);
			let material = new THREE.MeshPhongMaterial({map: santaSpriteTest, color: 0xFFFFFF});  			
			material.color.set(0xFFFFFF);
			material.transparent = true;
			material.alphaTest = 0.5;
			material.side = THREE.DoubleSide;
			material.emissive.set(0xFFFF88);
			material.emissiveMap = santaEmissiveTex;
			material.emissiveIntensity = 0.9;

			let mesh = new THREE.Mesh(geometry, material);
			let mscale = 1;

			mesh.position.x = 335;
			mesh.position.y = Z_PLANE;
			mesh.position.z = -380;

			mesh.rotation.x = -Math.PI/2;
			mesh.scale.set(mscale,mscale,mscale);
			
			var i = add_player(mesh, TYPE_SANTA);
			santaPlayer = i;
			scene.add(players[i].mesh);
		});
	});
	
	



	helicopterSpriteTest = new THREE.TextureLoader().load(texture_path('helicopter_test_url'), function(tex){
		tex.image = correct_texture_size(tex.image);
		loaded.helicopter = true;
		set_loading_desc("Helicopter loaded");
		
		let image_scale = 2;
		
		let sprite_w = 268; //tex.image.width;
		let sprite_h = 98; // tex.image.height;
		
		let object_w = sprite_w/image_scale;
		let object_h = sprite_h/image_scale;
				
		helicopterSpriteTest.minFilter = globalFilter;
		helicopterSpriteTest.magFilter = globalFilter;
		helicopterSpriteTest.repeat.x = sprite_w/tex.image.width;
		helicopterSpriteTest.repeat.y = sprite_h/tex.image.height;
		helicopterSpriteTest.offset.x = 0;
		helicopterSpriteTest.offset.y = 0;
		helicopterSpriteTest.flipY = false;
		
		
		

		helicopterEmissiveTex = new THREE.TextureLoader().load(texture_path('helicopter_lights_sprite_url'), function(tex){
			tex.image = correct_texture_size(tex.image);
			loaded.helicopter_lights = true;
			set_loading_desc("Helicopter lights loaded");

			let image_scale = 2;
			
			let sprite_w = 268; //tex.image.width;
			let sprite_h = 98; // tex.image.height;
			
			let object_w = sprite_w/image_scale;
			let object_h = sprite_h/image_scale;

			helicopterEmissiveTex.minFilter = globalFilter;
			helicopterEmissiveTex.magFilter = globalFilter;
			helicopterEmissiveTex.repeat.x = sprite_w/tex.image.width;
			helicopterEmissiveTex.repeat.y = sprite_h/tex.image.height;
			helicopterEmissiveTex.offset.x = 0;
			helicopterEmissiveTex.offset.y = 0;
			helicopterEmissiveTex.flipY = false;


			let geometry = new THREE.PlaneGeometry(object_w, object_h);
			let material = new THREE.MeshPhongMaterial({map: helicopterSpriteTest, color: 0xFFFFFF});  			
			material.color.set(0xFFFFFF);
			material.transparent = true;
			material.alphaTest = 0.5;
			material.side = THREE.DoubleSide;
			material.emissive.set(0xFFFFFF);
			material.emissiveMap = helicopterEmissiveTex;
			material.emissiveIntensity = 0.6;

			let mesh = new THREE.Mesh(geometry, material);
			let mscale = 1;
			mesh.position.x = 94;
			mesh.position.y = Z_PLANE;
			mesh.position.z = -387;
			
			mesh.rotation.x = -Math.PI/2;
			mesh.scale.set(mscale,mscale,mscale);
			
		
			var i = add_player(mesh, TYPE_HELI);
			scene.add(players[i].mesh);
		});
	});
	
	

	
	
	playerSpriteTest = new THREE.TextureLoader().load(texture_path('plane_sprite_url'), function(tex){
		tex.image = correct_texture_size(tex.image);
		loaded.plane = true;
		set_loading_desc("Plane loaded");
		
		let image_scale = 2;
		
		let sprite_w = 98*2; //tex.image.width;
		let sprite_h = 54*2; // tex.image.height;
		
		let object_w = sprite_w/image_scale;
		let object_h = sprite_h/image_scale;
				
		playerSpriteTest.minFilter = globalFilter;
		playerSpriteTest.magFilter = globalFilter;
		playerSpriteTest.repeat.x = sprite_w/tex.image.width;
		playerSpriteTest.repeat.y = sprite_h/tex.image.height;
		playerSpriteTest.offset.x = 0;
		playerSpriteTest.offset.y = 0;
		playerSpriteTest.flipY = false;
		
		planeEmissiveTex = new THREE.TextureLoader().load(texture_path('plane_lights_sprite_url'), function(tex){
			tex.image = correct_texture_size(tex.image);
			loaded.plane_lights = true;
			set_loading_desc("Plane lights loaded");
			
			let image_scale = 2;
			
			let sprite_w = 98*2; //tex.image.width;
			let sprite_h = 54*2; // tex.image.height;
			
			let object_w = sprite_w/image_scale;
			let object_h = sprite_h/image_scale;
					
			planeEmissiveTex.minFilter = globalFilter;
			planeEmissiveTex.magFilter = globalFilter;
			planeEmissiveTex.repeat.x = sprite_w/tex.image.width;
			planeEmissiveTex.repeat.y = sprite_h/tex.image.height;
			planeEmissiveTex.offset.x = 0;
			planeEmissiveTex.offset.y = 0;
			planeEmissiveTex.flipY = false;
			
			


			let geometry = new THREE.PlaneGeometry(object_w, object_h);
			let material = new THREE.MeshPhongMaterial({map: playerSpriteTest, color: 0xFFFFFF});  			
			material.color.set(0xFFFFFF);
			material.transparent = true;
			material.alphaTest = 0.5;
			material.side = THREE.DoubleSide;
			material.emissive.set(0xFFFF55);
			material.emissiveMap = planeEmissiveTex;
			material.emissiveIntensity = 1;
			
			let mesh = new THREE.Mesh(geometry, material);
			let mscale = 1;
			mesh.position.x = 1884;
			mesh.position.y = Z_PLANE;
			mesh.position.z = -186;

			mesh.rotation.x = -Math.PI/2;
			mesh.scale.set(mscale,mscale,mscale);
		
			var i = add_player(mesh, TYPE_PLANE);
			change_player(i);
			scene.add(players[i].mesh);
		});
	
	

	});

	
	// todo: add rgba possibility here...
	function buildAlphaMaterial(params){
		const material = new THREE.MeshLambertMaterial(params);
		
		material.onBeforeCompile = function ( shader ) {
			shader.uniforms.time = { value: 0 };
			shader.vertexShader = 'uniform float time;\n' + shader.vertexShader;
			shader.vertexShader = shader.vertexShader.replace(
				'#include <begin_vertex>',
				[
					`float theta = sin( time + position.y ) / 2;`,
					'float c = cos( theta );',
					'float s = sin( theta );',
					'mat3 m = mat3( c, 0, s, 0, 1, 0, -s, 0, c );',
					'vec3 transformed = vec3( position ) * m;',
					'vNormal = vNormal * m;'
				].join( '\n' )
			);
			material.userData.shader = shader;
		};

		// Make sure WebGLRenderer doesnt reuse a single program
		//material.customProgramCacheKey = function () {
		//	return amount;
		//};

		return material;
	}


	// create map plane:
	{
		set_loading_desc("Generating reflection layer");
		
		var mapMaterial = new THREE.MeshLambertMaterial( { envMap: textureCube } );
		mapMaterial.color.set(0xffffff);
		mapMaterial.vertexColors = THREE.VertexColors;
		
		var geometry = new THREE.PlaneBufferGeometry( mapsize, mapsize, terrainVerts, terrainVerts );
		var count = geometry.attributes.position.count;
	
		let BPP = 4; // need buildAlphaMaterial() finished to alpha channel to work.
		geometry.addAttribute('color', new THREE.BufferAttribute(new Float32Array(count*BPP), BPP));
		
		terrain = new THREE.Mesh(geometry, mapMaterial);
		terrain.visible = SHOW_WAVE_BG;
		terrain.rotation.x = -Math.PI / 2;
		
		var peak = 8;
		var smoothing = 600;
		var vertices = terrain.geometry.attributes.position.array;
		var perlin = new Perlin();
		for(var i = 0; i <= vertices.length; i += 3){
			vertices[i+2] = peak * perlin.noise(
				(terrain.position.x + vertices[i+0])/smoothing, 
				(terrain.position.z + vertices[i+1])/smoothing
			);
		}
		terrain.geometry.attributes.position.needsUpdate = true;
		terrain.geometry.computeVertexNormals();
		
		// flatten the terrain:
		vertices = terrain.geometry.attributes.position.array;
		var colors = terrain.geometry.attributes.color.array;
		for(var i = 0, c = 0; i <= vertices.length; i += 3, c+=BPP){
			vertices[i+2] = Z_SKYBOX+5;
		
			// default color to white:
			colors[c+0] = 1.16;//1.2+(Math.random())*0.5;//Math.random()*3;
			colors[c+1] = 1.16;//1.2+(Math.random())*0.5;//Math.random()*3;
			colors[c+2] = 1.10;//1.2+(Math.random())*0.5;
			
			// stretch edge + fade to black:
			if(vertices[i+0] <= -mapsize/2){
				vertices[i+0] = -mapsize;
				colors[c+0] = 0;
				colors[c+1] = 0;
				colors[c+2] = 0;
			}
			if(vertices[i+0] >= mapsize/2){
				vertices[i+0] = mapsize;
				colors[c+0] = 0;
				colors[c+1] = 0;
				colors[c+2] = 0;
			}
			if(vertices[i+1] <= -mapsize/2){
				vertices[i+1] = -mapsize;
				colors[c+0] = 0;
				colors[c+1] = 0;
				colors[c+2] = 0;
			}
			if(vertices[i+1] >= mapsize/2){
				vertices[i+1] = mapsize;
				colors[c+0] = 0;
				colors[c+1] = 0;
				colors[c+2] = 0;
			}
		}
		terrain.geometry.attributes.position.needsUpdate = true;
		//console.log("terrain.geometry.attributes");
		//console.log(terrain.geometry.attributes);
		//terrain.geometry.attributes.color.needsUpdate = true;
		
		
		scene.add(terrain);
		
		set_loading_desc("Reflection layer loaded");
	}
	

	
	renderer = new THREE.WebGLRenderer( { antialias: antialiasing });
	renderer.autoClear = false;
	renderer.setPixelRatio(window.devicePixelRatio);
	renderer.setSize(window.innerWidth, window.innerHeight);
	document.body.appendChild(renderer.domElement);
	
	MAX_TEX_SIZE = renderer.capabilities.maxTextureSize;
	
	console.log("maxTextureSize = "+MAX_TEX_SIZE);
		
		/*
		
	{
		var container = document.getElementById( 'container' );

		camera2 = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 5000 );
		camera2.position.set( 500, 350, 750 );

		scene2 = new THREE.Scene();

		renderer2 = new CSS3DRenderer();
		renderer2.setSize( window.innerWidth, window.innerHeight );
		container.appendChild( renderer2.domElement );
		
		// Block iframe events when dragging camera

		var blocker = document.getElementById('blocker');
		blocker.style.display = 'none';

		document.addEventListener('mousedown', function (){
			blocker.style.display = '';
		});
		document.addEventListener('mouseup', function (){
			blocker.style.display = 'none';
		});
	}
*/
	//var container = document.getElementById( 'container' );
	
	//renderer2 = new CSS3DRenderer();
	//renderer2.setSize( window.innerWidth, window.innerHeight );
	//container.appendChild( renderer2.domElement );

/*
	var group = new THREE.Group();
	group.add( new YoutubeEmbed( 'TlLijkYQjlw', 0, 0, 240, 0 ) );
	group.add( new YoutubeEmbed( 'RbtgTFGDkxA', 240, 0, 0, Math.PI / 2 ) );
	group.add( new YoutubeEmbed( 'fuyZFMRtXGs', 0, 0, - 240, Math.PI ) );
	group.add( new YoutubeEmbed( 'uqj9j-qz4AE', - 240, 0, 0, - Math.PI / 2 ) );
	scene.add( group );
*/
	//controls = new TrackballControls( camera, renderer.domElement );
	//controls.rotateSpeed = 4;


	

	window.addEventListener('resize', onWindowResize, false);

	
	
	set_loading_desc("Initialization done");
		
	init_gui();
}





function onWindowResize() {
	CANVAS_W = window.innerWidth;
	CANVAS_H = window.innerHeight;
	rescale_skybox();

	camera.aspect = window.innerWidth / window.innerHeight;

	camera.left = window.innerWidth * camera.aspect / -2;
    camera.right = window.innerWidth * camera.aspect / 2;
	
	camera.top = window.innerHeight * camera.aspect / 2;
    camera.bottom = window.innerHeight * camera.aspect / -2;
	
	camera.updateProjectionMatrix();
	
	renderer.setSize(window.innerWidth, window.innerHeight);
	
	console.log("window new size: "+window.innerWidth+"x"+window.innerHeight);

}




$(window).focus(function() {
    window_focus = true;
	play_sound("_blip2");
	if(!game_paused_by_enter){
		game_paused = false;
		game_paused_by_enter = false;
		update_pause_screen();
	}
}).blur(function() {
    window_focus = false;
	play_sound("_blip2");
	if(!game_paused_by_enter){
		game_paused = true;
		game_paused_by_enter = false;
		update_pause_screen();
	}
});




function animate() {
	let f = requestAnimationFrame(animate); // pauses when window not visible.
	render(f);
}








function updateFPS(){
	if(prevFpsTime == 0){
		prevFpsTime = getTimeMillis();
		return;
	}
	let ms = getTimeMillis()-prevFpsTime;
	let fps = 1000/(ms/framesPerFps);
	$('#fps').html("FPS: "+fps.toFixed(1));
	prevFpsTime = getTimeMillis();
}






// returns null if no intersection.
// returns [x,y] if intersects.
function line_intersect_line(x1, y1, x2, y2, x3, y3, x4, y4) {
	if ((x1 === x2 && y1 === y2) || (x3 === x4 && y3 === y4)){ // Check if none of the lines are of length 0
		return null;
	}
	denominator = ((y4-y3)*(x2-x1)-(x4-x3)*(y2-y1));	
	if(denominator === 0){ // Lines are parallel
		return null;
	}
	let ua = ((x4-x3)*(y1-y3)-(y4-y3)*(x1-x3)) / denominator;
	let ub = ((x2-x1)*(y1-y3)-(y2-y1)*(x1-x3)) / denominator;
	if(ua < 0 || ua > 1 || ub < 0 || ub > 1){ // is the intersection along the segments
		return null;
	}
	// Return a object with the x and y coordinates of the intersection
	return [x1+ua*(x2-x1), y1+ua*(y2-y1)];
}




let portals = [];


/*
	spawn_portal({
		'size': 200.0,
		'shape': 1, // 0 = circle, 1 = line. todo: use ellipse
		'unidirectional': true, // can the object go in from both ends.
		'preserve_position': true, // does object come out of other end at same relative position to portal it came in it?
		'preserve_angle': true, // is the incoming object rotated to the outgoing portal angle?
		'points' = [
			{ // startpoint
				'x': 327,
				'y': -770,
				'angle': 126.0,
			},
			{ // endpoint
				'x': 211,
				'y': -51,
				'angle': 256.0,
			},
		],
*/

// todo: process portals.
function spawn_portal(portal){

	for(let i = 0; i < 2; i++){
		let x = portal.points[i].x;
		let z = portal.points[i].y;
		let angle = portal.points[i].angle;

		let foundIndex = -1; // todo: add find_free_portal() later
		
		let mesh;
		
		if(foundIndex == -1){
			// create size of 1 and then scale it to correct size, so translate works easier.
			let geometry = new THREE.PlaneGeometry(1, 1);
			let material = new THREE.MeshPhongMaterial();
			material.color.set(0xFF00FF);
			material.transparent = false;
			material.opacity = 0.7;
			material.side = THREE.DoubleSide;
			
			//geometry.translate(0, 0, 0);
			mesh = new THREE.Mesh(geometry, material);
			
			mesh.scale.set(5, portal.size, 1);
			
		}else{
			mesh = portal.points[i].mesh;
			mesh.visible = true;
			mesh.material.color.set(0xFFFFFF); // needed if the unit has "hit flash" effect (red).
		}

		mesh.rotation.x = Math.PI/2;
		mesh.rotation.z = (180-angle)*(Math.PI/180.0);

		mesh.position.x = x;
		mesh.position.y = Z_PORTAL;
		mesh.position.z = z;

		
		// if was new portal, update mesh/texture too, and add to array/scene:
		if(foundIndex == -1){
			portal.points[i]['mesh'] = mesh;
			
			scene.add(mesh);
		}
	}
	
	portals.push(portal);
	
}



function spawn_portals(){
	spawn_portal({
		'size': 200.0,
		'shape': 1, // 0 = circle, 1 = line. todo: use ellipse
		'unidirectional': true, // can the object go in from both ends.
		'preserve_position': true, // does object come out of other end at same relative position to portal it came in it?
		'preserve_angle': true, // is the incoming object rotated to the outgoing portal angle?
		'points': [
			{ // startpoint
				'x': 327,
				'y': -770,
				'angle': 126.0,
			},
			{ // endpoint
				'x': 211,
				'y': -51,
				'angle': 256.0,
			},
		],
	});
}






function post_init(){
	generate_sounds();
	
	spawn_bombers();
	

	if(mapinfo.hasOwnProperty("units")){
		load_units(mapinfo.units);
	}
	
	spawn_portals();
	
	
	
	{
		let db_version = 1;
		let db;
		const DBOpenRequest = window.indexedDB.open('test', db_version);

		DBOpenRequest.onerror = (event) => {
			console.warn("error loading db");
			console.warn(event);
		};

		DBOpenRequest.onsuccess = (event) => {
			console.log("loading db");
			console.log(event);

			// Store the result of opening the database in the db variable. This is used a lot below
			db = DBOpenRequest.result;

			console.log("db");
			console.log(db);
		};
	}

}




function reset_globals(){
	gameLoadedVar = false;
	// todo, add all other globals, or better, make it into a class...
	
	for(let key in loaded){
		if(loaded.hasOwnProperty(key)){
			loaded[key] = false;
		}
	}
	
}




// map_loaded
function game_loaded(){

	if(gameLoadedVar) return true;
	
	for(let key in loaded){
		if(loaded.hasOwnProperty(key)){
			if(!loaded[key]){
				return false;
			}
		}
	}
	
	gameLoadedVar = true;
	
	set_loading_desc("Post-initialization");
		
	console.log("game loaded... post initializating...");
	post_init();

	let game_loading_time = (getTimeMillis()-loading_start_time)/1000;
	console.log("GAME LOADED IN "+game_loading_time.toFixed(3)+" seconds");
	
	return true;
}






function hits_turret(owner, x, z){
	let offset_x = 0;
	let offset_z = 0;
	let object_w = 40; // hitbox size
	let object_h = 40;
	let hw = object_w/2;
	let hh = object_h/2;
	
	for(var i = 0; i < turrets.length; i++){
		let turret = turrets[i];
		if(turret.alive && turret.owner != owner){
			if(point_inside_rect(x, z, 
				turret.mesh.position.x-hw+offset_x, 
				turret.mesh.position.z-hh+offset_z, 
				turret.mesh.position.x+hw+offset_x, 
				turret.mesh.position.z+hh+offset_z
			)){
				return i;
			}
		}
	}
	return -1;
}


function hits_player(owner, x, z){
	let offset_x = 0;
	let offset_z = 0;
	let object_w = 40; // hitbox size
	let object_h = 40;
	let hw = object_w/2;
	let hh = object_h/2;
	
	for(var i = 0; i < players.length; i++){
		let player = players[i];
		if(player.alive && player.owner != owner){
			if(point_inside_rect(x, z, 
				player.mesh.position.x-hw+offset_x, 
				player.mesh.position.z-hh+offset_z, 
				player.mesh.position.x+hw+offset_x, 
				player.mesh.position.z+hh+offset_z
			)){
				return i;
			}
		}
	}
	return -1;
}


function hits_bomber(owner, x, z){
	let offset_x = 20;
	let offset_z = 30;
	let bomber_w = 740; // hitbox size
	let bomber_h = 80;
	let hw = bomber_w/2;
	let hh = bomber_h/2;
	
	for(var i = 0; i < bombers.length; i++){
		let bomber = bombers[i];
		if(bomber.alive && bomber.owner != owner){
			if(point_inside_rect(x, z, 
				bomber.x-hw+offset_x, 
				bomber.z-hh+offset_z, 
				bomber.x+hw+offset_x, 
				bomber.z+hh+offset_z
			)){
				return i;
			}
		}
	}
	return -1;
}

function explode_bomber(bomberHit, explosion_type){
	if(typeof explosion_type === "undefined"){
		explosion_type = EXPLOSION_ROUND;
	}
	let bomber = bombers[bomberHit];
	if(bomber.explode_time == -1){
		bomber.health = 0;
		bomber.explode_time = getTimeMillis();
		
		bomber.alive = false;
		bomber.mesh.visible = false;
		
		play_sound("explosion_bomb", bomber.x, bomber.z);
		explode_at(bomber.x, bomber.z, explosion_type, EXPLOSION_HUGE3);
		
		if(total_bombers_alive() == 0){
			spawn_bombers();
		}
	}
}


function explode_turret(turretHit, explosion_type){
	if(typeof explosion_type === "undefined"){
		explosion_type = EXPLOSION_ROUND;
	}
	let turret = turrets[turretHit];
	//if(turret.explode_time == -1){
		turret.health = 0;
		//turret.explode_time = getTimeMillis();
		
		turret.alive = false;
		turret.barrel_mesh.visible = false; // hide barrel once blown up.
		
		play_sound("explosion_bomb", turret.x, turret.z);
		explode_at(turret.x, turret.z, explosion_type, EXPLOSION_LARGE);
	//}
}

function respawn_turret(turretIndex){
	let turret = turrets[turretIndex];
	turret.health = 400;
	turret.alive = true;
	turret.barrel_mesh.visible = true;
	
	let framename = turret_type_to_idleframe(turret.type);
	let pos = frame_offset('turret', framename, 0);
	turret.texture.offset.x = pos.x;
	turret.texture.offset.y = pos.y;
}


function hit_bomber(bomberHit, damage){
	let bomber = bombers[bomberHit];				
	bomber.hit_time = getTimeMillis();
	bomber.health -= damage;
	if(bomber.health <= 0){
		explode_bomber(bomberHit);
	}else if(bomber.health <= bomber.health_falling){
		bomber.falling = true;
	}else if(bomber.health <= bomber.health_smokestart){
		bomber.smokestart = true;
	}
}
	
function hit_player(i, damage){
	let player = players[i];
	player.hit_time = getTimeMillis();
	player.health -= damage;
	/*
	if(player.health <= 0){
		explode_bomber(i);
	}else if(player.health <= player.health_smokestart){
		player.smokestart = true;
	}
	*/
}


function hit_turret(turretHit, damage){
	let turret = turrets[turretHit];				
	turret.hit_time = getTimeMillis();
	turret.health -= damage;
	if(turret.health <= 0){
		// update frame to dead:
		let framename = turret_type_to_deadframe(turret.type);
		let pos = frame_offset('turret', framename, 0);
		turret.texture.offset.x = pos.x;
		turret.texture.offset.y = pos.y;
		
		explode_turret(turretHit);
	}else if(turret.health <= turret.health_smokestart){
		turret.smokestart = true;
	}
}


var loadingTextVisible = true;


var santaFrameNumber = 0;
var explosionFrameNumber = 0;
var soldierFrameNum = 0;

var prevShootTime = 0;
var shooting_started = false;
var can_shoot = false;

var shooting_imprecision = 0.5; // in degrees.
var frameTime_val = getTimeMillis();
var frameNumber_val = 0;

var rotatePlayer = 0;

var prevShootStartTime = 0;

function frameTime(){
	return frameTime_val;
}
function frameNumber(){
	return frameNumber_val;
}








function render(renderFrame){
	if(game_paused){
		return;
	}
	frameNumber_val++;
	frameTime_val = getTimeMillis();
	

	if(!game_loaded()){
		return;
	}else{
		if(loadingTextVisible){
			$("#loading_container").hide();
			loadingTextVisible = false;
		}
	}
	
	if((frameNumber_val % framesPerFps) == 0){
		updateFPS();
	}
	
	if(guivisible){
		if((frameNumber_val % 5) == 0){
			updateInfo();
		}
	}
	
	let curplayer = players[myPlayer];
		


	

	if(shooting_started){
		
		if(getTimeMillis()-prevShootStartTime > continuous_shoot_delay){
			can_shoot = true;
		}
		
		if(can_shoot){
			if(getTimeMillis()-prevShootTime > planegun_delay){
				shoot_from_myplayer();
				prevShootTime = getTimeMillis();
			}
		}
	}
	


	
	if(curplayer.type == TYPE_HELI){
		let helispeed_x = 0.2;
		let helispeed_z = 0.1;
		let helimaxspeed_x = 13;
		let helimaxspeed_z = 15;
		if(key_down(65)){ // 'A'
			curplayer.speed_x -= helispeed_x;
		}
		if(key_down(68)){ // 'D'
			curplayer.speed_x += helispeed_x;
		}
		if(key_down(87)){ // 'W'
			curplayer.speed_z -= helispeed_z;
		}
		if(key_down(83)){ // 'S'
			curplayer.speed_z += helispeed_z;
		}
		
		if(curplayer.speed_x > helimaxspeed_x){
			curplayer.speed_x = helimaxspeed_x;
		}else if(curplayer.speed_x < -helimaxspeed_x){
			curplayer.speed_x = -helimaxspeed_x;
		}
		if(curplayer.speed_z > helimaxspeed_z){
			curplayer.speed_z = helimaxspeed_z;
		}else if(curplayer.speed_z < -helimaxspeed_z){
			curplayer.speed_z = -helimaxspeed_z;
		}
		curplayer.angle = get_angle(0, 0, curplayer.speed_x, curplayer.speed_z);
		curplayer.speed = get_dist_2d(0,0, curplayer.speed_x, curplayer.speed_z);
	}else{
		if(curplayer.type == TYPE_SOLDIER){
		
			
			if(key_down(65)){ // 'A'
				curplayer.angle += 4;
				setAngle(myPlayer, curplayer.angle);
			}
			if(key_down(68)){ // 'D'
				curplayer.angle -= 4;
				setAngle(myPlayer, curplayer.angle);
			}
			if(key_down(87)){ // 'W'
				curplayer.internal_speed += 0.5;
				if(curplayer.type == TYPE_SOLDIER){
					if(curplayer.internal_speed > 20){
						curplayer.internal_speed = 20;
					}
				}
				setSpeed(myPlayer, curplayer.internal_speed);
			}
			if(key_down(83)){ // 'S'
				curplayer.internal_speed -= 1.5;
				setSpeed(myPlayer, curplayer.internal_speed);
			}
		}else{
			if(key_down(65)){ // 'A'
				curplayer.angle += 2;
				setAngle(myPlayer, curplayer.angle);
			}
			if(key_down(68)){ // 'D'
				curplayer.angle -= 2;
				setAngle(myPlayer, curplayer.angle);
			}
			if(key_down(87)){ // 'W'
				curplayer.internal_speed += 0.5;
				setSpeed(myPlayer, curplayer.internal_speed);
			}
			if(key_down(83)){ // 'S'
				curplayer.internal_speed -= 1.5;
				setSpeed(myPlayer, curplayer.internal_speed);
			}
		}
	}
	if(key_down(32)){ // 'space'
		
		
		let allow_bombing = false;
		if(!bombingStarted){
			bombingStarted = true;
			bombStartTime = getTimeMillis();
			allow_bombing = true;
		}
		if(getTimeMillis()-bombStartTime > continuous_shoot_delay){
			if(getTimeMillis()-prevBombTime > bombgun_delay){
				allow_bombing = true;
			}
		}
		if(allow_bombing){
			let x = players[myPlayer].mesh.position.x;
			let z = players[myPlayer].mesh.position.z;
			let dire = new get_kxy_angle(players[myPlayer].angle);
			let speed = players[myPlayer].speed;

			drop_bomb(players[myPlayer].owner, x, z, dire, speed);
			prevBombTime = getTimeMillis();
		}
	}



	for(var i = 0; i < shots.length; i++){
		let shot = shots[i];
		
		if(shot.alive){
			shot.x += shot.kx;
			shot.z += shot.kz;
			
			shot.kx *= AIR_RESISTANCE;
			shot.kz += GRAVITY_CONSTANT;
			
			// teleport from edges:
			if(shot.x < -MAP_W/2-edgePadX){
				shot.x = MAP_W/2+edgePadX;
			}

			if(shot.x > MAP_W/2+edgePadX){
				shot.x = -MAP_W/2-edgePadX;
			}
			
			let hit_sound = "explosion_bullet";
			let splash_sound = "bullet_splash";
			let explode = true;
			let explosion_size = EXPLOSION_TINY;
			let glow = true;
			if(shot.type == WEAPON_SHOTGUN){
				hit_sound = "shotgun_bullet";
				splash_sound = "shotgun_splash";
				explode = true;
				explosion_size = EXPLOSION_SHOTGUN;
				glow = false;
			}
			
			let bomberHit = hits_bomber(shot.owner, shot.x, shot.z);
			let playerHit = hits_player(shot.owner, shot.x, shot.z);
			let turretHit = hits_turret(shot.owner, shot.x, shot.z);
			
			if(bomberHit != -1){
				
				play_sound(hit_sound, shot.x, shot.z);
				if(explode){
					explode_at(shot.mesh.position.x, shot.mesh.position.z, EXPLOSION_ROUND, explosion_size, glow);
				}

				hit_bomber(bomberHit, 20);
				
				shot.alive = false;
				scene.remove(shots[i].mesh);
			}else if(playerHit != -1){
				play_sound(hit_sound, shot.x, shot.z);
				if(explode){
					explode_at(shot.mesh.position.x, shot.mesh.position.z, EXPLOSION_ROUND, explosion_size, glow);
				}

				hit_player(playerHit, 20);
				
				shot.alive = false;
				scene.remove(shots[i].mesh);
			}else if(turretHit != -1){
				play_sound(hit_sound, shot.x, shot.z);
				if(explode){
					explode_at(shot.mesh.position.x, shot.mesh.position.z, EXPLOSION_ROUND, explosion_size, glow);
				}

				hit_turret(turretHit, 20);
				
				shot.alive = false;
				scene.remove(shots[i].mesh);
			}else{
			
				let ground_found = is_ground(shot.x, shot.z);
		
				if(ground_found || shot.mesh.position.z > MAP_H/2){

					shot.alive = false;
					scene.remove(shots[i].mesh);
					
					if(ground_found){
						play_sound(hit_sound, shot.x, shot.z);
						if(explode){
							explode_at(shot.mesh.position.x, shot.mesh.position.z, EXPLOSION_ROUND, explosion_size, glow);
						}
					}else{
						play_sound(splash_sound, shot.x, shot.z);
						splash_at(shot.mesh.position.x, shot.mesh.position.z, SPLASH_SMALL);
					}
				}
			}
			
			shot.mesh.position.x = shot.x;
			shot.mesh.position.z = shot.z;
			let angle = get_angle(0, 0, shot.kx, -shot.kz);
			
			shot.mesh.rotation.z = (angle+180)*(Math.PI/180.0);
		}
	} // shots
	
	
	
	
	
	for(var i = 0; i < bombs.length; i++){
		let bomb = bombs[i];
		
		if(bomb.alive){
			bomb.x += bomb.kx;
			bomb.z += bomb.kz;
			
			bomb.kx *= AIR_RESISTANCE;
			bomb.kz += GRAVITY_CONSTANT;
			
			// teleport from edges:
			if(bomb.x < -MAP_W/2-edgePadX){
				bomb.x = MAP_W/2+edgePadX;
			}

			if(bomb.x > MAP_W/2+edgePadX){
				bomb.x = -MAP_W/2-edgePadX;
			}
			
			let bomb_speed = get_dist_2d(0, 0, bomb.kx, bomb.kz);
			
			if(!bomb.whistling){
				if(bomb_speed > 7){
					//play_sound("bomb_drop", bomb.x, bomb.z);
					bomb.whistling = true;
				}
			}
			
			let bomberHit = -1;
			if(bomb.owner >= 0){ // only players can hit AI bombers. 
				bomberHit = hits_bomber(bomb.owner, bomb.x, bomb.z);
			}
			let playerHit = hits_player(bomb.owner, bomb.x, bomb.z);
			let turretHit = hits_turret(bomb.owner, bomb.x, bomb.z);
			
			if(bomberHit != -1){
				
				play_sound("explosion_bomb", bomb.x, bomb.z);
				explode_at(bomb.mesh.position.x, bomb.mesh.position.z, EXPLOSION_ROUND, EXPLOSION_LARGE);
				
				hit_bomber(bomberHit, 200);
				
				bomb.alive = false;
				scene.remove(bombs[i].mesh);
			}else if(playerHit != -1){
				play_sound("explosion_bomb", bomb.x, bomb.z);
				explode_at(bomb.mesh.position.x, bomb.mesh.position.z, EXPLOSION_ROUND, EXPLOSION_LARGE);

				hit_player(playerHit, 200);
				
				bomb.alive = false;
				scene.remove(bombs[i].mesh);
			}else if(turretHit != -1){
				play_sound("explosion_bomb", bomb.x, bomb.z);
				explode_at(bomb.mesh.position.x, bomb.mesh.position.z, EXPLOSION_ROUND, EXPLOSION_LARGE);

				hit_turret(turretHit, 200);
				
				bomb.alive = false;
				scene.remove(bombs[i].mesh);
			}else{
			
				let ground_found = is_ground(bomb.x, bomb.z);
						
				if(ground_found || bomb.mesh.position.z > MAP_H/2){
				
					
					bomb.alive = false;
					//bomb.mesh.visible = false;
					scene.remove(bombs[i].mesh);
					
					
					if(ground_found){
						play_sound("explosion_bomb", bomb.x, bomb.z);
						explode_at(bomb.mesh.position.x, bomb.mesh.position.z, EXPLOSION_FLAT, EXPLOSION_LARGE);
					}else{
						play_sound("bomb_splash", bomb.x, bomb.z);
						splash_at(bomb.mesh.position.x, bomb.mesh.position.z, SPLASH_MEDIUM);
					}
				}
			}
			
			
			bomb.mesh.position.x = bomb.x;
			bomb.mesh.position.z = bomb.z;
			let angle = get_angle(0, 0, bomb.kx, -bomb.kz);
			bomb.mesh.rotation.z = (angle+180)*(Math.PI/180.0);
		}
	} // bombs
	
	
	
	

	if(turrets_enabled){
		for(var i = 0; i < turrets.length; i++){
			let turret = turrets[i];
			
			if(turret.alive){
				let can_shoot = false;
				if(turret.type == TURRET_ANTIAIR){
					if(frameTime()-turret.shoot_start > 150+randiff(20)){
						can_shoot = true;
					}
				}else if(turret.type == TURRET_BOMBER){
					if(frameTime()-turret.shoot_start > 3000+randiff(200)){
						can_shoot = true;
					}
				}
				
				//let curplayer = players[myPlayer];
				
				let target_x = curplayer.mesh.position.x;
				let target_z = curplayer.mesh.position.z;
				
				let dist = get_dist_2d(turret.x, turret.z, target_x, target_z);
				
				if(dist < turret.max_shoot_dist){
					shoot_turret(turret, OWNER_AI, can_shoot);
				}
			}
		} // turrets
	}
	

	for(var i = 0; i < bombers.length; i++){
		let bomber = bombers[i];
		
		if(bomber.alive){
			let angle = get_angle(0, 0, bomber.kx, -bomber.kz);
			
			let framesX = 1;
			
			let startX = 0;
			let startY = 0;
			
			let maxFrames = 2; // debug value.
			
			if(bomber.type == PLANE_BOMBER){
				startX = 0;
				startY = 0;
				maxFrames = 1;
			}else if(bomber.type == PLANE_HORNET){
				startX = 0;
				startY = 1;
				maxFrames = 1;
			}else if(bomber.type == PLANE_UFO){
				startX = 0;
				startY = 2;
				maxFrames = 1;
			}
			
			bomber.x += bomber.kx;
			bomber.z += bomber.kz;
			
			if(bomber.falling){
				//bomber.kx *= 0.995;
				bomber.kz += 0.02;
			}
			
			
			// teleport from edges:
			if(bomber.x < -MAP_W/2-edgePadX){
				bomber.x = MAP_W/2+edgePadX;
			}

			if(bomber.x > MAP_W/2+edgePadX){
				bomber.x = -MAP_W/2-edgePadX;
			}

		
			let ground_found = is_ground(bomber.x, bomber.z);
					
			if(ground_found || bomber.z > MAP_H/2){
			
				bomber.alive = false;
				bomber.mesh.visible = false;
				
				if(ground_found){
					play_sound("explosion_bomb", bomber.x, bomber.z);
					
					explode_bomber(i, EXPLOSION_FLAT);
				}else{
					play_sound("plane_splash", bomber.x, bomber.z);
					
					splash_at(bomber.x, bomber.z, SPLASH_HUGE2);
					explode_bomber(i, EXPLOSION_FLAT);
				}
			}
			

			if(bomber.bombing_start_time != -1){
				if(frameTime() - bomber.bombing_start_time < 2000){
					if(frameTime() - bomber.last_bomb_time > 250){
						let dire = new get_kxy_angle(angle);
						let speed = bomber.kx;
						drop_bomb(bomber.owner, bomber.x, bomber.z+33, dire, speed, true);
						bomber.last_bomb_time = frameTime();
					}
				}else{
					bomber.bombing_start_time = -1;
					bomber.last_bomb_time = -1;
				}
			}else{
				if(Math.random() < 0.002){
					bomber.bombing_start_time = frameTime();
					bomber.last_bomb_time = -1;
				}
			}


			bomber.mesh.position.x = bomber.x;
			bomber.mesh.position.z = bomber.z;


			if(frameNumber() % 3 == 0){
				bomber.frame++;
			}
			if(bomber.frame > maxFrames-1){
				bomber.frame = 0;
			}

			let frameY = startY+Math.floor(bomber.frame/framesX);
			let frameX = startX+bomber.frame % framesX;
		
			bomber.texture.offset.x = (frameX*1024)/1024;
			bomber.texture.offset.y = (frameY*256)/256;
			
			if(bomber.hit_time != -1){
				bomber.mesh.material.color.set(0xFF8888);
				if(frameTime() - bomber.hit_time > 50){
					bomber.mesh.material.color.set(0xFFFFFF);
					bomber.hit_time = -1;
				}
			}
			
			
			bomber.mesh.rotation.z = (angle+180)*(Math.PI/180.0);
			
			let dire = new get_kxy_angle(angle);
			
			if(dire.x < 0){
				
				bomber.mesh.scale.y = -1;
			}else{
				
				bomber.mesh.scale.y = 1;
			}
			
		}
	} // bombers






	for(var i = 0; i < explosions.length; i++){
		let explosion = explosions[i];
		
		if(explosion.alive){
			let framesX = 8;
			let framesY = 8;
			let startX = 0;
			let startY = 0;
			let maxFrames = 2; // debug value.
			
			if(explosion.type == EXPLOSION_ROUND){
				startX = 0;
				startY = 0;
				maxFrames = 20;
			}else if(explosion.type == EXPLOSION_FLAT){
				startX = 0;
				startY = 3;
				maxFrames = 24;
			}



			if(frameNumber() % 3 == 0){
				explosion.frame++;
			}
			if(explosion.frame > maxFrames-1){
				explosion.frame = 0;
				explosion.alive = false;
				explosion.mesh.visible = false;
				//scene.remove(explosions[i].mesh);
			}

			let frameY = startY+Math.floor(explosion.frame/framesX);
			let frameX = startX+explosion.frame % framesX;
		
			explosion.texture.offset.x = (frameX*128)/1024;
			explosion.texture.offset.y = (frameY*128)/1024;
			
			if(explosion.speed > 0){
				explosion.x += explosion.kx;
				explosion.z += explosion.kz;
				
				explosion.kx *= 0.95;
				
				explosion.mesh.position.x = explosion.x;
				explosion.mesh.position.z = explosion.z;
			}
		}
	} // explosions





	for(var i = 0; i < lights.length; i++){
		let light = lights[i];
		
		if(light.alive){
			let framesX = 8;
			let framesY = 8;
			let startX = 0;
			let startY = 0;
			let maxFrames = 2; // debug value.
			
			if(light.type == EXPLOSION_ROUND){
				startX = 0;
				startY = 0;
				maxFrames = 20;
			}else if(light.type == EXPLOSION_FLAT){
				startX = 0;
				startY = 3;
				maxFrames = 24;
			}
			
			if(frameNumber() % 3 == 0){
				light.frame++;
			}
			
			//light.mesh.material.opacity = 1-(light.frame/(maxFrames-1));
			light.mesh.intensity = (1-(light.frame/(maxFrames-1)))*light.brightness;
			
			if(light.frame > maxFrames-1){
				light.frame = 0;
				light.alive = false;
				light.mesh.visible = false;
			}
		}
	} // lights



	for(var i = 0; i < visuals.length; i++){
		let visual = visuals[i];
		
		if(visual.alive){
			let framesX = 8;
			let framesY = 8;
			let startX = 0;
			let startY = 0;
			let maxFrames = 2; // debug value.
			
			if(visual.type == EXPLOSION_ROUND){
				startX = 0;
				startY = 0;
				maxFrames = 20;
			}else if(visual.type == EXPLOSION_FLAT){
				startX = 0;
				startY = 3;
				maxFrames = 24;
			}
			maxFrames = Math.round(maxFrames*1.3+1);
			
			if(frameNumber() % 3 == 0){
				visual.frame++;
			}
			
			visual.mesh.material.opacity = 1-(visual.frame/(maxFrames-1));
			
			if(visual.frame > maxFrames-1){
				visual.frame = 0;
				visual.alive = false;
				visual.mesh.visible = false;
				//scene.remove(explosions[i].mesh);
			}
		}
	} // visuals


	for(var i = 0; i < splashes.length; i++){
		let splash = splashes[i];
		
		if(splash.alive){
			if(frameNumber() % 3 == 0){
				splash.frame++;
			}
			if(splash.frame >= 14-1){
				splash.frame = 0;
				splash.alive = false;
				splash.mesh.visible = false;
				//scene.remove(splashes[i].mesh);
			}
			let framesX = 4;
			let framesY = 4;

			let frameY = Math.floor(splash.frame/framesX);
			let frameX = splash.frame % framesX;
			splash.texture.offset.x = (frameX*128)/512;
			splash.texture.offset.y = (frameY*128)/512;
		}
	} // splashes





	for(var i = 0; i < players.length; i++){
		let player = players[i];
		
		if(!gameEnded){
		
			// handle lane changes:
			if(player.lane == 1){
				player.mesh.position.y = Z_MAP_COLLISION_FRONT;
			}else if(player.lane == -1){
				player.mesh.position.y = Z_MAP_BEHIND_FRONT;
			}else{
				// lane "0" (collision layer)
				if(player.type == TYPE_SOLDIER){
					player.mesh.position.y = Z_SOLDIER;
				}else{
					player.mesh.position.y = Z_PLANE;
				}
			}

			
			let dir = 1;

			
			if(player.type == TYPE_HELI){
				player.mesh.position.x += player.speed_x;
				player.mesh.position.z += player.speed_z;
				
				if(player.speed_x < 0){
					dir = -1;
				}
			}else{
				let dire = new get_kxy_angle(player.angle);
			
				player.mesh.position.x += dire.x*player.speed;
				player.mesh.position.z += dire.z*player.speed;
				
				if(dire.x < 0){
					dir = -1;
				}
			}

		
			
			// teleport from edges:
			if(player.mesh.position.x < -MAP_W/2-edgePadX){
				player.mesh.position.x = MAP_W/2+edgePadX;
			}

			if(player.mesh.position.x > MAP_W/2+edgePadX){
				player.mesh.position.x = -MAP_W/2-edgePadX;
			}
			
			//if(player.mesh.position.z > MAP_H/2+edgePadY/2){
			//	player.mesh.position.z = -MAP_H-edgePadY;
			//}
			//if(player.mesh.position.z < -MAP_H-edgePadY){
			//	player.mesh.position.z = MAP_H/2+edgePadY/2;
			//}
			
			let splash_size = SPLASH_LARGE;
			let splash_offset_z = 0;
			
			if(player.type == TYPE_SOLDIER){
				splash_size = SPLASH_SMALL;
				splash_offset_z = 6;
			}
			
			// test if gets under water:
			if(player.mesh.position.z > MAP_H/2){
				if(!player.underwater){
					play_sound("plane_splash", player.mesh.position.x, player.mesh.position.z);
					splash_at(player.mesh.position.x, player.mesh.position.z+splash_offset_z, splash_size);
					player.underwater = true;
					
					// dampen player speed:
					player.kx *= 0.3;
					player.kz *= 0.3;
					player.internal_speed *= 0.3;
					setSpeed(i, player.internal_speed);
					
				}
			}else{
				// test if gets out of water:
				if(player.underwater){
					play_sound("plane_splash", player.mesh.position.x, player.mesh.position.z);
					splash_at(player.mesh.position.x, player.mesh.position.z+splash_offset_z, splash_size);
					player.underwater = false;
					//player.kz *= 0.5;
				}
			}
			

			
			if(player.type == TYPE_PLANE){
				// no flipping in x axis.
			}else{
				if(player.type == TYPE_HELI){
					if(dir < 0){
						player.mesh.scale.x = 1;
					}else{
						player.mesh.scale.x = -1;
					}
				}else{
					if(dir < 0){
						player.mesh.scale.y = 1;
					}else{
						player.mesh.scale.y = -1;
					}
				}
			}
			
			
			if(player.type == TYPE_SOLDIER){
				let ground_found = is_ground(player.mesh.position.x, player.mesh.position.z+18);
			
				if(ground_found){
					player.kz = 0;
				}else{
					player.mesh.position.z += player.kz;
					
					if(player.underwater){
						if(player.mesh.position.z > MAP_H/2+10){
							player.kz -= BUOYANCY_CONSTANT*5;
							
						}
						player.kz *= WATER_RESISTANCE; // inertia caused by thick water.
						
					}else{
						player.kz += GRAVITY_CONSTANT;
					}
				}
			}
			
			if(player.type == TYPE_HELI){
				let max_tilt_speed = 25;
				let max_tilt_angle = 60;
				let tilt_speed = player.speed_x*2;
				if(tilt_speed > max_tilt_speed) tilt_speed = max_tilt_speed;
				if(tilt_speed < -max_tilt_speed) tilt_speed = -max_tilt_speed;
				let tilt_angle = (-tilt_speed/max_tilt_speed)*max_tilt_angle;
				player.mesh.rotation.z = get_rads(tilt_angle+180);
			}else{
				player.mesh.rotation.z = get_rads(player.angle+180);
			}

			//let light_on_time = 20;
			//let light_off_time = 50;
			if(player.mesh.material.emissiveMap){
			
				if(player.type == TYPE_PLANE){
					if(Math.round(frameNumber()/30) % 3 == 0){
						player.mesh.material.emissive.set(0x000000);
					}else{
						player.mesh.material.emissive.set(0xFFFF55);
					}
				}
			}
			
			
			if(player.underwater){
				player.internal_speed *= 0.96;
				if(player.internal_speed <= 0.01){
					player.internal_speed = 0;
					// blow it up? 
				}
				setSpeed(i, player.internal_speed);
			}
		}
	} // players
	




	{


		
		bgTexImg2.offset.x+=0.002*rainspeed;
		bgTexImg2.offset.y+=0.01*rainspeed;
		
		
		// if night enabled: nightmode night_mode
		if(night_fade_dir){
		

			if(night_fade_dir == 1){
				ambient_light += night_fade_speed;
				if(ambient_light > max_ambient_light){
					ambient_light = max_ambient_light;
				}
			}else if(night_fade_dir == 2){
				ambient_light -= night_fade_speed;
				if(ambient_light < min_ambient_light){
					ambient_light = min_ambient_light;
				}
			}
		
			if(NIGHTSKY_STYLE == 0){
				// black sky
				
				if(night_fade_dir == 1){
					// disable night
				
					skyboxMesh.material.opacity += night_fade_speed;
					if(skyboxMesh.material.opacity >= 1){
						skyboxMesh.material.opacity = 1;
					}
					
					cloudsMesh.material.opacity += night_fade_speed;
					if(cloudsMesh.material.opacity >= 1){
						cloudsMesh.material.opacity = 1;
						//cloudsMesh.visible = false;
					}
					
					
					
				}else if(night_fade_dir == 2){
					// enable night (remove skyboxMesh)
					
					skyboxMesh.material.opacity -= night_fade_speed;
					if(skyboxMesh.material.opacity <= 0){
						skyboxMesh.material.opacity = 0;
						skyboxMesh.visible = false;

					}
					
					cloudsMesh.material.opacity -= night_fade_speed;
					if(cloudsMesh.material.opacity <= min_cloud_opa){
						cloudsMesh.material.opacity = min_cloud_opa;
						//cloudsMesh.visible = false;
					}
					
				}
				ambient.color.r = ambient_light;
				ambient.color.g = ambient_light;
				ambient.color.b = ambient_light;
			
			}else if(NIGHTSKY_STYLE == 1){
				// yellow sky
				// todo fix:
				if(night_fade_dir == 1){
					skyopacity += night_fade_speed;
					if(skyopacity > 1) skyopacity = 1;
				}else if(night_fade_dir == 2){
					skyopacity -= night_fade_speed;
					if(skyopacity < 0) skyopacity = 0;
				}
				ambient.color.r = ambient_light;
				ambient.color.g = ambient_light;
				ambient.color.b = ambient_light;
				cloudsMesh.material.color.set(colorBetweenRGBA(0xFFFFFF, 0xFFFF00, skyopacity));
				skyboxMesh.material.color.set(colorBetweenRGBA(0xFFFFFF, 0xFFFF00, skyopacity));
			}
			

		
			
			let waterFadePercent = 1-skyboxMesh.material.opacity; // 1 = day, 0 = night
			
			{
			
				// animate behind.png lightmap color:
				let opa = 1-skyboxMesh.material.opacity;
				let bounce_opacity = true;
				let color_opa = 1-skyboxMesh.material.opacity;
				if(bounce_opacity){
					//opa = (Math.sin(frameNumber()/20)+1)/2;
					//opa *= opa;
					color_opa = (Math.sin(frameNumber()/30)+1)/2;
				}
				behindMesh.material.emissiveIntensity = opa;//opa;
				
				
				let color = colorBetweenRGBA_array([0xFF0000, 0xFFFF00, 0x00FF00, 0x00FFFF, 0x0000FF, 0xFF00FF, 0xFF0000], color_opa);
				//let color = colorBetweenRGBA_array([0xFF5555, 0xFFFF55, 0x55FF55, 0x55FFFF, 0x5555FF, 0xFF55FF, 0xFF5555], color_opa);
				//if((frameNumber() % 10) == 0){
//					console.log(color);
				//}
				behindMesh.material.emissive.set(color);
			
			}
			
			
			let refopaFrom = 0.2;
			let refopaTo = 0.5;
			
			mapMeshFlipped.material.opacity = waterFadePercent*(refopaTo-refopaFrom)+refopaFrom;
			
			let waterColorFrom = 0xDDDDDD;
			let waterColorTo = 0x666666;
			
			
			//waterDownBack.material.opacity = 0.4;
			waterDownBack.material.color.set(colorBetweenRGBA(waterColorFrom, waterColorTo, waterFadePercent));
			
			//waterDownFront.material.opacity = 0.6;
			waterDownFront.material.color.set(colorBetweenRGBA(waterColorFrom, waterColorTo, waterFadePercent));
			
		}
		

		if(fade_dir){
			if(fade_dir == 1){ // disable rain
				rainfallMesh.material.opacity -= rain_fade_speed;

				if(rainfallMesh.material.opacity <= 0){
					rainfallMesh.material.opacity = 0;
					rainfallMesh.visible = false;
					fade_dir = 0;
				}
			}else if(fade_dir == 2){ // enable rain
				rainfallMesh.material.opacity += rain_fade_speed;
				
				if(rainfallMesh.material.opacity >= rainMaxOpacity){
					rainfallMesh.material.opacity = rainMaxOpacity;
					fade_dir = 0;
				}
			}
			
			if(fade_dir == 1){ // disable rain
				waterdropsMesh.material.opacity -= rain_fade_speed;

				if(waterdropsMesh.material.opacity <= 0){
					waterdropsMesh.material.opacity = 0;
					waterdropsMesh.visible = false;
					//fade_dir = 0;
				}
			}else if(fade_dir == 2){ // enable rain
				waterdropsMesh.material.opacity += rain_fade_speed;
				
				if(waterdropsMesh.material.opacity >= raindropsMaxOpacity){
					waterdropsMesh.material.opacity = raindropsMaxOpacity;
					//fade_dir = 0;
				}
			}
			
			
		
			// interpolate cloud colors:
			let cloudFadePercent = rainfallMesh.material.opacity/rainMaxOpacity;
			
			cloudsMesh.material.color.set(
				colorBetweenRGBA(cloudColorFrom, cloudColorTo, cloudFadePercent)
			);
			
			skyboxMesh.material.color.set(
				colorBetweenRGBA(skyboxColorFrom, skyboxColorTo, cloudFadePercent)
			);
		}
	}
	
	
	

	{
	
		let px = players[myPlayer].mesh.position.x;
		let pz = players[myPlayer].mesh.position.z;
		
		let scrollFrameNum = frameNumber()*0.5;

		let mul = 0.8;
		cloudsBackTex.offset.x = ((-px/(0.5*mul))/MAP_W)+scrollFrameNum/1000*.3;
		cloudsBackTex.offset.y = ((pz/(3*mul))/MAP_H);

		let aspect = CANVAS_W/CANVAS_H;
		nightskyTex.offset.x = ((px/10*aspect)/CANVAS_W);
		nightskyTex.offset.y = ((-pz/10)/CANVAS_H);

		mapParallaxTex.offset.x = ((px/10)/MAP_W);
		mapParallaxTex.offset.y = ((-pz/15)/MAP_H);
		
		cloudsFrontTex.offset.x = ((px/5)/MAP_W)+scrollFrameNum/1500;
		cloudsFrontTex.offset.y = ((-pz/20)/MAP_H);


		if(flip_dir && (frameNumber() % 2) == 0){
			// flip
			planeFrameNum++;
			if(planeFrameNum >= 15-1){
				planeFrameNum = 0;
				planeFrameNumX++;
				if(planeFrameNumX >= 2){
					planeFrameNumX = 0;
				}
		
				flip_dir = 0;
			}

			
			playerSpriteTest.offset.x = (planeFrameNumX*98)/256;//+(1/256);
			playerSpriteTest.offset.y = (planeFrameNum*54)/1024;
			
			planeEmissiveTex.offset.x = (planeFrameNumX*98)/256;//+(1/256);
			planeEmissiveTex.offset.y = (planeFrameNum*54)/1024;
		}



		
		
		let waterSpeed = 0.1;
		mapTexWater.offset.x = scrollFrameNum/1600*waterSpeed*1.5;
		mapTexWater.offset.y = scrollFrameNum/250*waterSpeed;
		
		mapTexWaterDrops.offset.x = scrollFrameNum/15;




		{

			let speedAdd = players[santaPlayer].speed/15;
			santaFrameNumber += speedAdd;
			
			if(santaFrameNumber >= 22-1){
				santaFrameNumber = 0;
			}
			
			let intnum = Math.round(santaFrameNumber);
			
			
			let framesX = 3;
			let framesY = 8;
			
			//let w = 165;
			//let h = 56;

			let santaFrameY = Math.floor(intnum/3);
			let santaFrameX = intnum % 3;
			santaSpriteTest.offset.x = (santaFrameX*167)/512;//+(1/256);
			santaSpriteTest.offset.y = (santaFrameY*58)/512;
			
			santaEmissiveTex.offset.x = (santaFrameX*167)/512;//+(1/256);
			santaEmissiveTex.offset.y = (santaFrameY*58)/512;
		}
		
		
		
		{
			// TYPE_SOLDIER animation: soldier player animation:
			let thisplayer = players[soldierPlayer];
			
			let speedAdd = thisplayer.speed/15;
			soldierFrameNum += speedAdd;
			
			let animation_name = 'stand_idle';
			if(thisplayer.underwater){
				animation_name = 'basic_swim';
			}else{
				animation_name = 'running';
			}
			
			let anim_frames = SPRITES['soldier']['anims'][animation_name].length;
			
			if(soldierFrameNum >= anim_frames-1){
				soldierFrameNum = 0;
			}
			
			
			let pos = frame_offset('soldier', animation_name, Math.round(soldierFrameNum));
			soldierSpriteTest.offset.x = pos.x;
			soldierSpriteTest.offset.y = pos.y;
						
		}
		
	}







	if(camstyle == 0){
		/////////////////
		// 3D style:
		let cpx = players[myPlayer].mesh.position.x;
		let cpy = players[myPlayer].mesh.position.y;
		let cpz = players[myPlayer].mesh.position.z;
		
		camera.position.x = cpx+MOUSE_OFFSET_X;
		camera.position.y = cpy+500;
		camera.position.z = cpz+MOUSE_OFFSET_Y;
		
		//camera.lookAt( scene.position );
		camera.lookAt(
			cpx + MOUSE_OFFSET_X, 
			cpy, 
			cpz + MOUSE_OFFSET_Y
		);
		cameraCube.rotation.copy( camera.rotation );
	}else{
		/////////////////
		// 2D style:
		let cpx = players[myPlayer].mesh.position.x;
		let cpy = players[myPlayer].mesh.position.y;
		let cpz = players[myPlayer].mesh.position.z;
		
		camera.position.x = cpx+MOUSE_OFFSET_X;
		camera.position.y = cpy+2000;
		camera.position.z = cpz+MOUSE_OFFSET_Y;
		
		//camera.lookAt( players[myPlayer].mesh.position );
		camera.lookAt(
			cpx + MOUSE_OFFSET_X, 
			cpy, 
			cpz + MOUSE_OFFSET_Y
		);
	}
	
	renderer.render(scene, camera);
}






function find_free_light(){
	for(let i = 0; i < lights.length; i++){
		let light = lights[i];
		if(!light.alive){
			return i;
		}
	}
	return -1;
}



function find_free_visual(type){
	for(let i = 0; i < visuals.length; i++){
		let visual = visuals[i];
		if(!visual.alive && visual.type == type){
			return i;
		}
	}
	return -1;
}


function find_free_explosion(type){
	for(let i = 0; i < explosions.length; i++){
		let explosion = explosions[i];
		if(!explosion.alive && explosion.type == type){
			return i;
		}
	}
	return -1;
}




function find_free_splash(){
	for(let i = 0; i < splashes.length; i++){
		let splash = splashes[i];
		if(!splash.alive){
			return i;
		}
	}
	return -1;
}


function total_bombers_alive(){
	let total = 0;
	for(let i = 0; i < bombers.length; i++){
		if(bombers[i].alive){
			total++;
		}
	}
	return total;
}

function find_free_bomber(){
	for(let i = 0; i < bombers.length; i++){
		let bomber = bombers[i];
		if(!bomber.alive){
			return i;
		}
	}
	return -1;
}




function explode_at(x, z, type, size, glowing){

	if(typeof glowing === "undefined"){
		glowing = true;
	}

	// spawn glowing...
	if(glowing){
		glow_at(x, z, type, size);
		//light_at(x, z, type, size);
		
		//light_at(x, z, type, 500, 4);
	}

	let random_rotation = false;
	if(type == EXPLOSION_ROUND){
		// only round explosions can be rotated around their center point.
		random_rotation = true;
	}

	let mscale = 1; // default EXPLOSION_MEDIUM.
	if(size == EXPLOSION_SHOTGUN){
		mscale = 1/8;
	}else if(size == EXPLOSION_TINY){
		mscale = 1/4;
	}else if(size == EXPLOSION_SMALL){
		mscale = 1/2;
	}else if(size == EXPLOSION_MEDIUM){
		mscale = 1;
	}else if(size == EXPLOSION_LARGE){
		mscale = 1*2;
	}else if(size == EXPLOSION_HUGE){
		mscale = 1*3;
	}else if(size == EXPLOSION_HUGE2){
		mscale = 1*5;
	}else if(size == EXPLOSION_HUGE3){
		mscale = 1*6;
	}


	let w = 128;
	let h = 128;
	
	let foundIndex = find_free_explosion(type);
	
	let mesh;
	let texture;

	if(foundIndex == -1){
		texture = explosionSpriteTest.clone();
		texture.needsUpdate = true;

		let geometry = new THREE.PlaneGeometry(w, h);
		let material = new THREE.MeshBasicMaterial({map: texture, color: 0xFFFFFF});
		material.color.set(0xFFFFFF);
		material.transparent = true;
		material.opacity = 1;
		material.side = THREE.DoubleSide;
		//material.blending = THREE.AdditiveBlending;

		mesh = new THREE.Mesh(geometry, material);
	}else{
		mesh = explosions[foundIndex].mesh;
		mesh.visible = true;
	}
	
	
	
	mesh.rotation.x = Math.PI/2;
	if(random_rotation){
		mesh.rotation.z = Math.random()*Math.PI*2;
	}

	mesh.position.x = x;
	mesh.position.y = Z_MAP_EXPLOSIONS+Math.random()+(ZINSTEP/2);
	if(type == EXPLOSION_FLAT){
		mesh.position.z = z-Math.round(h*(mscale/2)*0.7); // centered to bottom of the image.
	}else{
		mesh.position.z = z; // default as fully centered to image.
	}
	
	mesh.scale.set(mscale,mscale,mscale);

	
	
	if(foundIndex == -1){
		let explosion = {
			'x': x,
			'z': z,
			'kx': 0,
			'kz': 0,
			'speed': 0,
			'frame': 0,
			'alive': true,
			'mesh': mesh,
			'type': type,
			'size': size,
			'scale': mscale,
			'texture': texture,
		};
		explosions.push(explosion);
		scene.add(explosions[explosions.length-1].mesh);
	}else{
		explosions[foundIndex].frame = 0;
		explosions[foundIndex].alive = true;
	}
}



function light_at(x, z, type, size, brightness){

	let foundIndex = find_free_light();
	let mesh;
	if(foundIndex == -1){
		mesh = new THREE.PointLight(0xffee88, brightness, size, 1);
	}else{
		mesh = lights[foundIndex].mesh;
		mesh.visible = true;
	}
	
	mesh.position.x = x;
	mesh.position.y = Z_MAP_VISUALS+150;
	mesh.position.z = z;
	

	if(foundIndex == -1){
		let light = {
			'frame': 0,
			'alive': true,
			'type': type,
			'brightness': brightness,
			'size': size,
			'time': 2000,
			'mesh': mesh,
		};
		lights.push(light);
		scene.add(lights[lights.length-1].mesh);
	}else{
		lights[foundIndex].frame = 0;
		lights[foundIndex].alive = true;
	}
}



function glow_at(x, z, type, size){

	let mscale = 1; // default EXPLOSION_MEDIUM.
	
	if(size == EXPLOSION_SHOTGUN){
		mscale = 1/8;
	}else if(size == EXPLOSION_TINY){
		mscale = 1/4;
	}else if(size == EXPLOSION_SMALL){
		mscale = 1/2;
	}else if(size == EXPLOSION_MEDIUM){
		mscale = 1;
	}else if(size == EXPLOSION_LARGE){
		mscale = 1*2;
	}else if(size == EXPLOSION_HUGE){
		mscale = 1*3;
	}else if(size == EXPLOSION_HUGE2){
		mscale = 1*5;
	}else if(size == EXPLOSION_HUGE3){
		mscale = 1*6;
	}
	mscale *= 3; // double the size relative to explosion size.


	let w = 128;
	let h = 128;

	let foundIndex = find_free_visual(type);

	let mesh;
	let texture;

	if(foundIndex == -1){
		texture = glowspriteTex.clone();
		texture.needsUpdate = true;

		let geometry = new THREE.PlaneGeometry(w, h);
		let material = new THREE.MeshBasicMaterial({map: texture, color: 0x444444});
		material.color.set(0x555555);
		material.transparent = true;
		//material.opacity = 1; // fades out after it is created.
		material.side = THREE.DoubleSide;
		material.blending = THREE.AdditiveBlending;

		mesh = new THREE.Mesh(geometry, material);
	}else{
		mesh = visuals[foundIndex].mesh;
		mesh.visible = true;
	}
	
	mesh.rotation.x = Math.PI/2;
	mesh.rotation.z = Math.random()*Math.PI*2; // random rotation.

	mesh.position.x = x;
	mesh.position.y = Z_MAP_VISUALS+Math.random()*(ZINSTEP/2);
	mesh.position.z = z; // default as fully centered to image.
	
	mesh.scale.set(mscale,mscale,mscale);

	if(foundIndex == -1){
		let visual = {
			'x': x,
			'z': z,
			'kx': 0,
			'kz': 0,
			'speed': 0,
			'frame': 0,
			'alive': true,
			'mesh': mesh,
			'type': type,
			'size': size,
			'scale': mscale,
			'texture': texture,
		};
		visuals.push(visual);
		scene.add(visuals[visuals.length-1].mesh);
	}else{
		visuals[foundIndex].frame = 0;
		visuals[foundIndex].alive = true;
	}
}






function splash_at(x, z, size){
	let mscale = 1;
	
	if(size == SPLASH_TINY){
		mscale = 1/8;
	}else if(size == SPLASH_SMALL){
		mscale = 1/4;
	}else if(size == SPLASH_MEDIUM){
		mscale = 1/2;
	}else if(size == SPLASH_LARGE){
		mscale = 1;
	}else if(size == SPLASH_HUGE){
		mscale = 1*2;
	}else if(size == SPLASH_HUGE2){
		mscale = 1*5;
	}

	let w = 128;
	let h = 128;
	
	let foundIndex = find_free_splash();
	
	let mesh;
	let texture;

	if(foundIndex == -1){
		texture = splashSpriteTest.clone();
		texture.needsUpdate = true;

		let geometry = new THREE.PlaneGeometry(w, h);
		let material = new THREE.MeshPhongMaterial({map: texture, color: 0xFFFFFF});  			
		material.color.set(0xFFFFFF);
		material.transparent = true;
		material.opacity = 1;
		material.side = THREE.DoubleSide;
		//material.blending = THREE.AdditiveBlending;

		mesh = new THREE.Mesh(geometry, material);
	}else{
		mesh = splashes[foundIndex].mesh;
		mesh.visible = true;
	}
	

	mesh.rotation.x = Math.PI/2;

	mesh.position.x = x;
	mesh.position.y = Z_MAP_SPLASHES;
	mesh.position.z = z-8;
	
	mesh.scale.set(mscale,mscale,mscale);

	if(foundIndex == -1){
		let splash = {
			'x': x,
			'z': z,
			'frame': 0,
			'alive': true,
			'mesh': mesh,
			'scale': mscale,
			'texture': texture,
		};
		splashes.push(splash);
		scene.add(splashes[splashes.length-1].mesh);
	}else{
		splashes[foundIndex].frame = 0;
		splashes[foundIndex].alive = true;
	}
}








// flying_angle 0 = left, 180 = right.
function spawn_bomber(owner, x, z, flying_angle, speed, type, size){

	let mscale = 1;
	
	if(typeof flying_angle === "undefined"){
		flying_angle = 180;
		console.log("flying_angle = 180");
	}
	if(typeof speed === "undefined"){
		speed = 10;
	}
	if(typeof type === "undefined"){
		type = PLANE_BOMBER;
	}
	if(typeof size !== "undefined"){
		mscale = size;
	}
	
	let dire = new get_kxy_angle(flying_angle);

	let w = 1024;
	let h = 256;
	
	let foundIndex = find_free_bomber(x, z);
	
	let mesh;
	let texture;

	if(foundIndex == -1){
		texture = bomberSpriteTest.clone();
		texture.needsUpdate = true;

		let geometry = new THREE.PlaneGeometry(w, h);
		let material = new THREE.MeshPhongMaterial({map: texture, color: 0xFFFFFF});  			
		material.color.set(0xFFFFFF);
		material.transparent = true;
		material.opacity = 1;
		material.side = THREE.DoubleSide;
		material.emissive.set(0xFFFFFF);
		material.emissiveMap = bomberEmissiveTex;
		material.emissiveIntensity = 1.2;

		mesh = new THREE.Mesh(geometry, material);
	}else{
		mesh = bombers[foundIndex].mesh;
		mesh.visible = true;
		mesh.material.color.set(0xFFFFFF);
	}
	

	mesh.rotation.x = Math.PI/2;

	mesh.position.x = x;
	mesh.position.y = Z_BOMBER;
	mesh.position.z = z;
	
	mesh.scale.set(mscale,mscale,mscale);
	
	let kx = dire.x*speed;
	let kz = dire.z*speed;
	let health = 1000;
	let health_smokestart = 500;
	let health_falling = 200;

	if(foundIndex == -1){
		let bomber = {
			'x': x,
			'z': z,
			'kx': kx,
			'kz': kz,
			'speed': speed,
			'hit_time': -1,
			'explode_time': -1,

			'health': health,
			'health_smokestart': health_smokestart, // hp when bomber starts to fall down.
			'health_falling': health_falling, // hp when bomber starts to fall down.
			'falling': false,
			
			'frame': 0,
			'alive': true,
			
			'mesh': mesh,
			'scale': mscale,
			'texture': texture,
			'type': type,
			'bombing_start_time': -1,
			'last_bomb_time': -1,
			'owner': owner,
		};
		bombers.push(bomber);
		scene.add(bombers[bombers.length-1].mesh);
	}else{
		let bomber = bombers[foundIndex];
		bomber.frame = 0;
		bomber.alive = true;
		bomber.x = x;
		bomber.z = z;
		bomber.kx = kx;
		bomber.kz = kz;
		bomber.speed = speed;
		bomber.hit_time = -1;
		bomber.explode_time = -1;
		bomber.falling = false;
		bomber.health = health;
		bomber.health_smokestart = health_smokestart;
		bomber.health_falling = health_falling;
		bomber.scale = mscale;
		bomber.type = type;
		bomber.bombing_start_time = -1;
		bomber.last_bomb_time = -1;
		bomber.owner = owner;
	}
	
}



function spawn_bombers(){
	// -1 = AI team.
	spawn_bomber(OWNER_AI, -MAP_W/2, -MAP_H+Math.random()*800-800, 180, Math.random()*10+5);
	spawn_bomber(OWNER_AI, MAP_W/2, -MAP_H+Math.random()*800-800, 0, Math.random()*10+5);
}




function find_free_turret(type){
	for(let i = 0; i < turrets.length; i++){
		if(!turrets[i].alive && turrets[i].type == type){
			return i;
		}
	}
	return -1;
}

function turret_type_to_idleframe(type){
	if(type == TURRET_ANTIAIR){
		return "aa_idle";
	}else if(type == TURRET_BOMBER){
		return "bomber_idle";
	}
	return "aa_idle";
}
function turret_type_to_deadframe(type){
	if(type == TURRET_ANTIAIR){
		return "aa_dead";
	}else if(type == TURRET_BOMBER){
		return "bomber_dead";
	}
	return "aa_dead";
}



function spawn_turret(owner, x, z, type){

	let mscale = 1;
	

	if(typeof type === "undefined"){
		type = TURRET_ANTIAIR;
	}

	
	let sprite = SPRITES['turret'];


	let foundIndex = find_free_turret(type);
	
	let mesh;
	let barrel_mesh;
	let texture;
	let turret = {};
	
	
	if(foundIndex == -1){
		texture = turretSpriteTest.clone();
		texture.needsUpdate = true;

		let geometry = new THREE.PlaneGeometry(sprite.w, sprite.h);
		let material = new THREE.MeshPhongMaterial({map: texture, color: 0xFFFFFF});  			
		material.color.set(0xFFFFFF);
		material.transparent = true;
		material.opacity = 1;
		material.side = THREE.DoubleSide;

		mesh = new THREE.Mesh(geometry, material);
		
		// create barrel:
		{
			// create size of 1 and then scale it to correct size, so translate works easier.
			let geometry = new THREE.PlaneGeometry(1, 1);
			let material = new THREE.MeshPhongMaterial();
			material.color.set(0x000000);
			material.transparent = false;
			material.opacity = 1;
			material.side = THREE.DoubleSide;
			
			// move pipe from middle to left a bit:
			geometry.translate(0.2, 0, 0.5);
			barrel_mesh = new THREE.Mesh(geometry, material);
			let barrel_length = 50;
			barrel_mesh.scale.set(barrel_length, 3, 1);
		}
		
		
	}else{
		turret = turrets[foundIndex];
		mesh = turret.mesh;
		mesh.visible = true;
		mesh.material.color.set(0xFFFFFF); // needed if the unit has "hit flash" effect (red).
		texture = turret.texture;
		barrel_mesh = turret.barrel_mesh;
		barrel_mesh.visible = true;
	}
	
	// set correct frame:
	let framename = turret_type_to_idleframe(type);
	let pos = frame_offset('turret', framename, 0);
	texture.offset.x = pos.x;
	texture.offset.y = pos.y;
	
	mesh.rotation.x = Math.PI/2;

	mesh.position.x = x;
	mesh.position.y = Z_TURRET;
	mesh.position.z = z;
	
	mesh.scale.set(mscale,mscale,mscale);
	
	
	barrel_mesh.rotation.x = Math.PI/2;
	barrel_mesh.rotation.z = 0; // reset rotation.
	
	
	
	if(type == TURRET_ANTIAIR){
		barrel_mesh.position.x = x+1.5;
		barrel_mesh.position.z = z-15;
	}else if(type == TURRET_BOMBER){
		barrel_mesh.position.x = x;
		barrel_mesh.position.z = z-19.5;
	}
	barrel_mesh.position.y = Z_TURRET_BARREL;

	// initialize data:
	turret['frame'] = 0;
	turret['alive'] = true;
	turret['x'] = x;
	turret['z'] = z;
	turret['ammo'] = 1000;
	turret['shoot_start'] = -1;
	turret['health'] = 400;
	turret['health_smokestart'] = 100;
	turret['scale'] = mscale;
	turret['type'] = type;
	turret['owner'] = owner;
	turret['smokestart'] = false;
	turret['explode_time'] = -1;
	turret['max_shoot_dist'] = MAX_TARGET_DISTANCE; // todo: read from map unit settings.
	
	// if was new turret, update mesh/texture too, and add to array/scene:
	if(foundIndex == -1){
		turret['mesh'] = mesh;
		turret['texture'] = texture;
		turret['barrel_mesh'] = barrel_mesh;
		
		turrets.push(turret);
		scene.add(turrets[turrets.length-1].mesh);
		scene.add(turrets[turrets.length-1].barrel_mesh);
	}
	
}











function drop_bomb(owner, x, z, dire, speed, owned_by_ai){

	if(typeof owned_by_ai === "undefined"){
		owned_by_ai = false;
	}
	
	//play_sound("bomb_drop", x, z);
	
	
	let w = 25;
	let h = 17;
	
	let geometry = new THREE.PlaneGeometry(w, h);
	let material = new THREE.MeshPhongMaterial({map: bombSpriteTest, color: 0xFFFFFF});  			
	material.color.set(0xFFFFFF);
	material.transparent = true;
	material.opacity = 1;
	material.side = THREE.DoubleSide;
	//material.blending = THREE.AdditiveBlending;

	let mesh = new THREE.Mesh(geometry, material);
	let mscale = 1;
	//mesh.position.x = 2117;
	mesh.position.y = Z_MAP_BOMBS;
	//mesh.position.z = 237;

	let angle = get_angle(0, 0, dire.x, dire.z);
	mesh.rotation.x = Math.PI/2;
	mesh.rotation.z = (180-angle)*(Math.PI/180.0);
	
	mesh.scale.set(mscale,mscale,mscale);
	

	
	
	//let dire = new get_kxy_angle(players[myPlayer].angle);
	//let speed = 0.1*players[myPlayer].speed;

	
	mesh.position.x = x;
	mesh.position.z = z;
	
	let bomb = {
		'x': x,
		'z': z,
		'kx': dire.x*speed,
		'kz': dire.z*speed,
		'alive': true,
		'mesh': mesh,
		'whistling': false,
		'owned_by_ai': owned_by_ai,
		'owner': owner,
	};
	bombs.push(bomb);
	scene.add(bombs[bombs.length-1].mesh);
}



// random value -range to range
function randiff(range){
	return (((Math.random()-0.5)*2)*range);
}


function todeg(rad){
	return 180-rad*(180.0/Math.PI);
}


// ported to js from pete's python code for solving trajectory equation.
// x0,y0 = from
// x1,y1 = to
function get_angles_for_target(x0, y0, x1, y1, v){
	let delta_x = x1 - x0;
	let delta_y = y1 - y0;
	if(delta_x == 0){
		if(delta_y > 0){
			return [todeg(Math.PI/2), null]; // shoot straight down
		}else{
			return [todeg(-Math.PI/2), null]; // shoot straight up
		}
	}
	let k = delta_y/delta_x;

	let c = (k - 2*GRAVITY_CONSTANT*(delta_x/(2*v*v)))/Math.sqrt(1+k*k);
	let alpha = Math.atan(-k);
	let beta = Math.asin(c);

	let theta_1 = (beta - alpha) / 2;
	let theta_2 = (-beta + Math.PI - alpha) / 2;
	
	let solutions = [theta_1-Math.PI, theta_2-Math.PI, theta_1, theta_2];
		
	let min_t = 666666.0;
	let min_theta = null;
	let max_theta = null;
	
	let ts = [];

	for(let i = 0; i < 4; i++){
		let theta = solutions[i];
		let t = delta_x/(Math.cos(theta)*v);		
		if(t > 0){
			ts.push([t, theta]);
		}
	}
	
	if(ts.length == 1){
		min_theta = ts[0][1];
	}else if(ts.length == 2){
		// find min/max of first 2 values
		if(ts[0][0] > ts[1][0]){
			// if first value of t is larger, set max_theta as t's theta value.
			min_theta = ts[1][1];
			max_theta = ts[0][1];
		}else{
			min_theta = ts[0][1];
			max_theta = ts[1][1];
		}
	}

	let min_a = (min_theta !== null) ? todeg(min_theta) : null; // straight shot
	let max_a = (max_theta !== null) ? todeg(max_theta) : null; // ballistic shot (longer)
	
	return [min_a, max_a];
}









function shoot_turret(turret, owner, shot_allowed){
	//let angle = -(Math.random()*(160-20)+20); // -20 to -160
	
	//let pred_amount = 200;
	//let hpred = Math.round(pred_amount/2);
	let curplayer = players[myPlayer];
	
	let target_x = curplayer.mesh.position.x;
	let target_z = curplayer.mesh.position.z;
	
	let dist = get_dist_2d(turret.x, turret.z, target_x, target_z);
	
	//let shot_minimum_acceptable_distance = 50;
	
	// quick check to not process too far away players:
	if(dist < turret.max_shoot_dist){
	
	


		let shot_start_x = turret.x;
		let shot_start_z = turret.z-17;
		
		let bullet_speed = 20.1; // speed 1 = 1*0.1+20 (lol)
		let max_frames_per_dist = 30*(turret.max_shoot_dist*2)/bullet_speed; // double in case needed

		// add prediction of player movement in the future:
		let max_frames = Math.floor((dist/bullet_speed));
		let dire = new get_kxy_angle(curplayer.angle);
		let pspeed = curplayer.speed * max_frames;
		let add_x = dire.x*pspeed;
		let add_z = dire.z*pspeed;
		//target_x = curplayer.mesh.position.x + add_x;
		//target_z = curplayer.mesh.position.z + add_z;
		
		target_x = curplayer.mesh.position.x;
		target_z = curplayer.mesh.position.z;
		
		/*
		
		let targeting_angle = get_angle(shot_start_x, shot_start_z, target_x, target_z);

		let best_angle = 999;
		let frames_used = 0;
		let found_target = false;
		
		
		// simulate bullet movement beforehand:
		{
			let min_dist = 999999;
			let min_frames_used = 999999;
			let total_grounds_found = 0;
			
			// alter the angle to find best angle:
			//for(let a = -hpred; a <= hpred; a++){
			for(let a = -hpred; a <= hpred; a++){
				let astep = a*2.0;
				let cur_angle = targeting_angle + astep;
				let dire_bullet = new get_kxy_angle(cur_angle);
				
				let shot = {
					'x': shot_start_x,
					'z': shot_start_z,
					'kx': dire_bullet.x*bullet_speed,
					'kz': dire_bullet.z*bullet_speed,
				};
							
				// find shortest distance to target at first shot:
				for(let i = 0; i < max_frames_per_dist; i++){
					shot.x += shot.kx;
					shot.z += shot.kz;
					shot.kx *= AIR_RESISTANCE;
					shot.kz += GRAVITY_CONSTANT;
					
					let ground_found = is_ground(shot.x, shot.z);
					if(ground_found){
						total_grounds_found++;
						break;
					}
					
					let shot_dist = get_dist_2d(shot.x, shot.z, target_x, target_z);
					if(shot_dist < shot_minimum_acceptable_distance){
						frames_used = i+1;
						if(shot_dist < min_dist){
							min_dist = shot_dist;
							min_frames_used = frames_used;
							best_angle = cur_angle;
							found_target = true;
						}
					}
				}
			}
			
			//console.log("total_grounds_found = "+total_grounds_found);
		}
		*/
		

		target_x += add_x;
		target_z += add_z;
		
		let best_angles = get_angles_for_target(shot_start_x, shot_start_z, target_x, target_z, bullet_speed);
		let found_angle = null;
		
		for(let p = 0; p < best_angles.length; p++){
			let cur_angle = best_angles[p];
			if(cur_angle !== null){

				let dire_bullet = new get_kxy_angle(cur_angle);
				
				let shot = {
					'x': shot_start_x,
					'z': shot_start_z,
					'kx': dire_bullet.x*bullet_speed,
					'kz': dire_bullet.z*bullet_speed,
				};
							
				// simulate bullet movement:
				let hit_ground = false;
				let maxframes = 60*10; // 10 secs max calculation.
				let prev_shot_dist = null;
				let prev_shot_dist_diff = 0;
				for(let i = 0; i < maxframes; i++){
					shot.x += shot.kx;
					shot.z += shot.kz;
					shot.kx *= AIR_RESISTANCE;
					shot.kz += GRAVITY_CONSTANT;
					
					let shot_dist = get_dist_2d(shot.x, shot.z, target_x, target_z);
					
					if(prev_shot_dist !== null){
						let shot_dist_diff = shot_dist-prev_shot_dist;
						if(shot_dist_diff-prev_shot_dist_diff > 0){
							// todo: clean up code.
							break; // bullet started to get further from target.
						}
						
						prev_shot_dist_diff = shot_dist_diff;
					}

					if(is_ground(shot.x, shot.z)){
						//console.log("cur_angle = "+cur_angle.toFixed(2)+" hits ground");
						hit_ground = true;
						break;
					}
					
					prev_shot_dist = shot_dist;
				}
				if(!hit_ground){
					// found a way which didnt hit ground; use it:
					found_angle = cur_angle;
					break;
				}
			}
		}
		
		
		//console.log("found_angle = "+found_angle);
		
		if(found_angle !== null){
			
			//console.log("max_frames = "+max_frames+", frames_used = "+frames_used);
			
			let random_spread = 0;//(Math.random()-0.5)*1.5; //1.5 degree spread.
			let shot_angle = found_angle + random_spread;
		
			// always rotate turret to the correct rotation:
			turret.barrel_mesh.rotation.z = (180-shot_angle)*(Math.PI/180.0);
			
			if(shot_allowed){
				shoot_turret_from(owner, shot_start_x, shot_start_z, shot_angle, turret.type);
				turret.shoot_start = getTimeMillis();
			}
			
			//console.log("shoot turret from "+owner);
		}
	}
}


function shoot_turret_from(owner, x, z, angle, type){
	if(type == TURRET_ANTIAIR){
		play_sound("antiair_gun", x, z);
		shoot_planegun_nosound(owner, x, z, angle, 0.1);
	}else if(type == TURRET_BOMBER){
		play_sound("explosion_bullet", x, z);

		let dire = new get_kxy_angle(angle);
		let speed = 20;
		
		drop_bomb(owner, x, z, dire, speed);
	}
}





function shoot_from_myplayer(){
	let curplayer = players[myPlayer];
	if(curplayer.weapons1[curplayer.current1] == WEAPON_PLANEGUN){
		shoot_planegun(
			curplayer.owner,
			curplayer.mesh.position.x,
			curplayer.mesh.position.z,
			curplayer.shoot_angle,
			curplayer.speed
		);
	}else if(curplayer.weapons1[curplayer.current1] == WEAPON_SHOTGUN){
		play_sound("plane_machinegun", curplayer.mesh.position.x, curplayer.mesh.position.z);
	
		for(let i = 0; i < 10; i++){
			shoot_planegun_nosound(
				curplayer.owner,
				curplayer.mesh.position.x,
				curplayer.mesh.position.z,
				curplayer.shoot_angle+(Math.random()-0.5)*6,
				curplayer.speed+(Math.random()-0.5)*12,
				WEAPON_SHOTGUN
			);
		}
	}else if(curplayer.weapons1[curplayer.current1] == WEAPON_BOMB){
		let x = curplayer.mesh.position.x;
		let z = curplayer.mesh.position.z;
		let object_speed = curplayer.speed;
		let bullet_angle = curplayer.shoot_angle;
		bullet_angle += (Math.random()-0.5)*shooting_imprecision;
		let dire = new get_kxy_angle(bullet_angle);
		let speed = object_speed+20;
		
		drop_bomb(players[myPlayer].owner, x, z, dire, speed);
	}
}



function shoot_planegun(owner, x, z, bullet_angle, object_speed){
	play_sound("plane_machinegun", x, z);
	shoot_planegun_nosound(owner, x, z, bullet_angle, object_speed, WEAPON_PLANEGUN);
}



function shoot_planegun_nosound(owner, x, z, bullet_angle, object_speed, type){
	let w = 64;
	let h = 6;
	
	let geometry = new THREE.PlaneGeometry(w, h);
	let material = new THREE.MeshPhongMaterial({map: shotSpriteTest, color: 0xFFFFFF});  			
	material.color.set(0xFFFFFF);
	material.transparent = true;
	material.opacity = 1;
	material.side = THREE.DoubleSide;
	material.emissive.set(0xFFFF00);
	material.emissiveMap = shotlightsTex;
	material.emissiveIntensity = 0.7;
	//material.blending = THREE.AdditiveBlending;

	let mesh = new THREE.Mesh(geometry, material);
	let mscale = 1;
	mesh.position.x = x;
	mesh.position.y = Z_MAP_SHOTS;
	mesh.position.z = z;

	mesh.rotation.x = Math.PI/2;
	mesh.rotation.z = (180-bullet_angle)*(Math.PI/180.0);
	
	mesh.scale.set(mscale,mscale,mscale);
	
	bullet_angle += (Math.random()-0.5)*shooting_imprecision;
	let dire = new get_kxy_angle(bullet_angle);
	let speed = object_speed+20;

	let shot = {
		'x': x,
		'z': z,
		'kx': dire.x*speed,
		'kz': dire.z*speed,
		'alive': true,
		'mesh': mesh,
		'owner': owner,
		'type': type,
	};
	shots.push(shot);
	scene.add(shots[shots.length-1].mesh);
}











function change_player(playerIndex){
	if(playerIndex >= 0 && playerIndex < players.length){
		myPlayer = playerIndex;
	}else{
		console.log("player "+playerIndex+" does not exist");
	}
}






// keys
document.addEventListener("keyup", onDocumentKeyUp, false);
function onDocumentKeyUp(event) {
	KEYS[event.which] = false;
	
	var keyCode = event.which;
	//console.log("keyup = "+keyCode);
	
	if(keyCode == 32){ // 'space'
		//rotatePlayer = 0;
		bombingStarted = false;
		bombStartTime = 0;
		prevBombTime = 0;
		
	}else if(keyCode == 68){ // 'S'
		//rotatePlayer = 0;
	}
}


// keys
document.addEventListener("keydown", onDocumentKeyDown, false);
function onDocumentKeyDown(event) {
	var keyCode = event.which;
	
	if(!game_paused && gameLoadedVar){
		KEYS[event.which] = true;
		
		console.log("keydown = "+keyCode);
		
		let curplayer = players[myPlayer];

		if(keyCode == 113){
			// download sounds sound data:
			download_all_sounds();
		}else if(keyCode == 66){ // 'B'
			spawn_bombers();
			
		}else if(keyCode == 80){ // 'P'
			// toggle turrets
			turrets_enabled ^= 1;
			//if(turrets_enabled){
				for(let i = 0; i < turrets.length; i++){
					respawn_turret(i);
				}
			//}

		}else if(keyCode == 103){ // numpad 7
			
		}else if(keyCode == 104){ // numpad 8
			
		}else if(keyCode == 105){ // numpad 9
			
		}else if(keyCode == 100){ // numpad 4
			
		}else if(keyCode == 101){ // numpad 5
			
		}else if(keyCode == 102){ // numpad 6
			
		}else if(keyCode == 97){ // numpad 1
			
		}else if(keyCode == 98){ // numpad 2
			
		}else if(keyCode == 99){ // numpad 3
			
		}else if(keyCode == 96){ // numpad 0
			
		}else if(keyCode == 110){ // numpad ','/'del'
			
		}else if(keyCode == 69){ // 'E'
			curplayer.lane++;
			if(curplayer.lane > 1){
				curplayer.lane = 1;
			}

		}else if(keyCode == 81){ // 'Q'
			curplayer.lane--;
			if(curplayer.lane < -1){
				curplayer.lane = -1;
			}
			
		}else if(keyCode == 82){
			mapMesh.material.alphaTest += 0.1;
			console.log(mapMesh.material.alphaTest);
		}else if(keyCode == 70){
			mapMesh.material.alphaTest -= 0.1;
			console.log(mapMesh.material.alphaTest);
		}else if(keyCode == 87){ // 'W'
			// jump
			
			
		}else if(keyCode == 83){ // 'S'
			// prone
			
			
		}else if(keyCode == 65){ // 'A'
			// turn left
			
			//rotatePlayer = 2;
			
		}else if(keyCode == 68){ // 'D'
			// turn right
			
			//rotatePlayer = -2;
			
		}else if(keyCode == 89){ // 'Y'
			// youtube element
			//var group = new THREE.Group();
			//group.add(new YoutubeEmbed('bmfudW7rbG0', 0, Z_RAIN, 0, -Math.PI/2));
			//scene2.add(group);
		
		}else if(keyCode == 32){ // 'space	'

			
		}else if(keyCode == 115){ // 'F4'
			guivisible ^= 1;
			
			if(guivisible){
				$("#gui").show();
			}else{
				$("#gui").hide();
			}
			
		}else if(keyCode == 49){ // '1'
			change_player(keyCode-49);

		}else if(keyCode == 50){ // '2'
			change_player(keyCode-49);
			
		}else if(keyCode == 51){ // '3'
			change_player(keyCode-49);
			
		}else if(keyCode == 52){ // '4'
			change_player(keyCode-49);
			
		}else if(keyCode == 53){ // '5'
			change_player(keyCode-49);
			
		}else if(keyCode == 54){ // '6'
			change_player(keyCode-49);
			
		}else if(keyCode == 55){ // '7'
			change_player(keyCode-49);
			
		}else if(keyCode == 56){ // '8'
			change_player(keyCode-49);
			
		}else if(keyCode == 57){ // '9'
			SHOW_RAIN_BG ^= 1;
			
			if(SHOW_RAIN_BG){
				rainfallMesh.visible = true;
				waterdropsMesh.visible = true;
				fade_dir = 2; // enable
			}else{
				fade_dir = 1; // disable
			}
			
		}else if(keyCode == 78){ // 'N'
			SHOW_NIGHTSKY_BG ^= 1;
			NIGHTSKY_STYLE = 0;
			
			// night_enabled night enabled
			if(SHOW_NIGHTSKY_BG){
				night_fade_dir = 2; // enable night
				// todo: add textures/clouds/sunset.png for sunset night mode.
				//scene.background = new THREE.Color(0xFFFF00); // add skybox. this simple!
			}else{
				//scene.background = nightskyTex; // add skybox. this simple!
				skyboxMesh.visible = true;
				night_fade_dir = 1; // disable night
			}
			
		}else if(keyCode == 77){ // 'M'
			//change mode to sunset
			SHOW_NIGHTSKY_BG ^= 1;
			NIGHTSKY_STYLE = 1;
			
			// sunset enable sunset
			if(SHOW_NIGHTSKY_BG){
				night_fade_dir = 2; // enable night
				// todo: add textures/clouds/sunset.png for sunset night mode.
				//scene.background = new THREE.Color(0xFFFF00); // add skybox. this simple!
			}else{
				//scene.background = nightskyTex; // add skybox. this simple!
				skyboxMesh.visible = true;
				night_fade_dir = 1; // disable night
			}
		
		}else if(keyCode == 48){ // '0'
			SHOW_WAVE_BG ^= 1;
			
			// show bumpy sky:
			terrain.visible = !!SHOW_WAVE_BG;
			
			// hide "real" sky:
			skyboxMesh.visible = !SHOW_WAVE_BG;
			cloudsMesh.visible = !SHOW_WAVE_BG;
		}
	} // !game_paused
	
	// allow pause button to work at all times:
	if(keyCode == 13){ // 'enter'
		if(gameLoadedVar){
			game_paused ^= 1;
			game_paused_by_enter = game_paused;
			play_sound("_blip");
			update_pause_screen();
		}
	}
};

function update_pause_screen(){
	if(game_paused){
		$("#pause_container").css("display", "table");
	}else{
		$("#pause_container").css("display", "none");
	}
}



$(window).bind('beforeunload', function(){
	return null; // disabled for dev mode...
	return 'Are you sure you want to leave?'; // modern browsers will show their own message instead of this.
});





// onmousemove
document.addEventListener("mousemove", onDocumentMouseMove, false);
function onDocumentMouseMove(event) {
	if(!game_paused && gameLoadedVar){
		var renderlayer = renderer.getSize();
		var midX = renderlayer.width/2;
		var midY = renderlayer.height/2;
		var x = event.clientX;
		var y = event.clientY;
		// update mouse pos only if not pressing SHIFT key.
		// NOTE: DONT USE CTRL IN ANY COMBINATIONS SINCE CTRL+W QUITS PAGE.
		// this way you can stop camera following mouse.
		// todo: fix pointing direction being wrong if player not in middle of screen.
		if(!key_down(16)){ // if not 'SHIFT'
			MOUSE_X = x; // integers.
			MOUSE_Y = y;
			
			MOUSE_OFFSET_X = (MOUSE_X-(CANVAS_W/2))*2;
			MOUSE_OFFSET_Y = (MOUSE_Y-(CANVAS_H/2))*2;
		}
		
		var angle = get_angle(midX, midY, x, y);
		var dist = get_dist_2d(midX, midY, x, y);
		var maxDistX = midX/1;
		var maxDistY = midY/1;
		var maxDist = maxDistX;
		if(maxDistY < maxDistX){
			maxDist = maxDistY;
		}
		if(dist > maxDist){
			dist = maxDist;
		}
		var distPercent = dist/maxDist;
		var maxSpeed = 80;
		var minSpeed = 0;

		if(!players.length){
			console.log("players not initialized yet");
		}else{
			setShootAngle(myPlayer, angle);
		}
	}
};

function stopEvent(event){
	if(typeof event.preventDefault !== "undefined"){
		event.preventDefault();
	}
	if(typeof event.stopPropagation !== "undefined"){
		event.stopPropagation();
	}
}


window.addEventListener("contextmenu", function(event){
	if(!contextmenu_enabled){
		event.preventDefault();
	}
});


// if val distance to target is less or equal range.
function is_near(val, target){
	let range = 0.01;
	return (Math.abs(val-target) <= range);
}



document.addEventListener('wheel', onDocumentWheel, { passive: false });
function onDocumentWheel(event){
	if(event.deltaY < 0){
		// UP:
		INTERNAL_ZOOM *= ZOOM_MULTI;
	}else{
		// DOWN:
		INTERNAL_ZOOM /= ZOOM_MULTI;
	}

	// lock zoom to special multipliers (powers of two basically).
	let tempzoom = INTERNAL_ZOOM;
	let mults = [0.25, 0.5, 1, 2, 4];
	for(let i = 0; i < mults.length; i++){
		if(is_near(tempzoom, mults[i])){
			tempzoom = mults[i];
			console.log("zoom is exactly "+tempzoom);
			break;
		}
	}

	camera.zoom = tempzoom;
	camera.updateProjectionMatrix();
}


document.addEventListener("mousedown", onDocumentMouseDown, false);
function onDocumentMouseDown(event) {
	if(!game_paused && gameLoadedVar){
		if(event.button == 0){ // left click leftclick
			if(players.length > 0){
				shoot_from_myplayer();
				prevShootTime = getTimeMillis();
				shooting_started = true;
				prevShootStartTime = getTimeMillis();
			}
		
		}else if(event.button == 1){ // middle click
			// change primary weapon:
			if(players.length > 0){
				players[myPlayer].current1++;
				if(players[myPlayer].current1 >= players[myPlayer].weapons1.length){
					players[myPlayer].current1 = 0;
				}
			}
			
		}else if(event.button == 2){ // right click
			// flip plane:

			if(players.length > 0){
				if(players[myPlayer].type == TYPE_PLANE){
					if(!flip_dir){
						plane_flipped ^= 1;
					
						play_sound("plane_flip", players[myPlayer].mesh.position.x, players[myPlayer].mesh.position.z);
				
						//console.log("plane_flipped: "+(!!plane_flipped));
								
						flip_dir = 1;
						
					}
				}
			}
		}
	}
	
	stopEvent(event); // prevent any other handling of these events by browser.
};




document.addEventListener("mouseup", onDocumentMouseUp, false);
function onDocumentMouseUp(event) {
	// dont check paused here or keys can get stuck after unpausing.
	if(gameLoadedVar){
		if(event.button == 0){ // left click
			shooting_started = false;
			can_shoot = false;
		}else if(event.button == 1){ // middle click
			
		}else if(event.button == 2){ // right click
			
		}
	}
};



</script>


</body>
</html>