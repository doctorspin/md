<!DOCTYPE html>
<html lang="en">
<head>
	<title>Master Defender</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	
	<meta name="mobile-web-app-capable" content="yes">
	<meta name="apple-mobile-web-app-capable" content="yes">
	<meta name="apple-mobile-web-app-status-bar-style" content="black">
	
	<meta property="og:title" content="Master Defender">
	<meta property="og:description" content="Defend your ground by planes and soldiers!">
	
	<script src="three.js"></script>
	<script src="OrbitControls.js"></script>

	<link type="text/css" href="jquery/jquery-ui.css" rel="Stylesheet" />
	<script type="text/javascript" src="jquery/jquery.min.js"></script>
	<script type="text/javascript" src="jquery/jquery-ui.min.js"></script>
	
	<script src="riffwave.js"></script>
	<script src="sfxr.js"></script>
	


<style>

html, body, #loading_container {
    margin: 0;
    padding: 0;
    height: 100%;
    width: 100%;
}

#loading_container {
    display: table;
	position:absolute;
	background: rgb(27,48,110);
	
	background: radial-gradient(circle, rgba(0,0,0,0.5) 0%, rgba(0,198,196,0.5) 13%, rgba(0,255,252,0.5) 15%, rgba(39,255,244,0.5) 17%, rgba(240,18,17,0.5) 65%, rgba(255,0,0,0.5) 100%), linear-gradient(0deg, rgba(27,48,110,1) 10%, rgba(106,125,255,1) 55%, rgba(137,219,122,1) 60%, rgba(3,3,10,1) 83%, rgba(0,0,0,1) 100%);
	
	background-size: 100% 100%;
	background-position: 50% 50%;
	
	animation: gradient 3s ease infinite;
}

@keyframes gradient {
	0% {
		background-size: 100% 100%;
	}
	50% {
		background-size: 200% 200%;
	}
	100% {
		background-size: 100% 100%;
	}
}



#loading_container_inner {
    display: table-cell;
    margin: 0;
    padding: 0;

    text-align: center;
    vertical-align: middle;
}

#loading_text {
	font:40px verdana;

	margin: auto;
	color:black;
  

}





.lds-ellipsis {
  display: inline-block;
  position: relative;
  width: 80px;
  height: 80px;
  top:40px;
}
.lds-ellipsis div {
  position: absolute;
  top: 33px;
  width: 8px;
  height: 8px;
  border-radius: 50%;

  background: #000;
}
.lds-ellipsis div:nth-child(1) {
  left: 8px;
  animation: lds-ellipsis1 0.6s infinite;
}
.lds-ellipsis div:nth-child(2) {
  left: 8px;
  animation: lds-ellipsis2 0.6s infinite;
}
.lds-ellipsis div:nth-child(3) {
  left: 32px;
  animation: lds-ellipsis2 0.6s infinite;
}
.lds-ellipsis div:nth-child(4) {
  left: 56px;
  animation: lds-ellipsis3 0.6s infinite;
}
@keyframes lds-ellipsis1 {
  0% {
    transform: scale(0);
  }
  100% {
    transform: scale(1);
  }
}
@keyframes lds-ellipsis3 {
  0% {
    transform: scale(1);
  }
  100% {
    transform: scale(0);
  }
}
@keyframes lds-ellipsis2 {
  0% {
    transform: translate(0, 0);
  }
  100% {
    transform: translate(24px, 0);
  }
}





.lds-ellipsis-left {
  display: inline-block;
  position: relative;
  width: 80px;
  height: 80px;
  top:40px;
}
.lds-ellipsis-left div {
  position: absolute;
  top: 33px;
  width: 8px;
  height: 8px;
  border-radius: 50%;

  background: #000;
}
.lds-ellipsis-left div:nth-child(1) {
  left: 8px;
  animation: lds-ellipsis-left1 0.6s infinite;
}
.lds-ellipsis-left div:nth-child(2) {
  left: 8px;
  animation: lds-ellipsis-left2 0.6s infinite;
}
.lds-ellipsis-left div:nth-child(3) {
  left: 32px;
  animation: lds-ellipsis-left2 0.6s infinite;
}
.lds-ellipsis-left div:nth-child(4) {
  left: 56px;
  animation: lds-ellipsis-left3 0.6s infinite;
}
@keyframes lds-ellipsis-left1 {
  0% {
    transform: scale(1);
  }
  100% {
    transform: scale(0);
  }
}
@keyframes lds-ellipsis-left3 {
  0% {
    transform: scale(0);
  }
  100% {
    transform: scale(1);
  }
}
@keyframes lds-ellipsis-left2 {
  0% {
    transform: translate(24px, 0);
  }
  100% {
    transform: translate(0, 0);
  }
}


</style>
<script>

/*
todo:
- visible_size = 8192/6 <--- make all repetitive map backgrounds defineable in a way that you give the scale of the texture compared to map size,
  so it will always be relative to map size.
- playerSpriteTest sprite should be 1-2px wider to prevent texture bleeding caused by offset change which was done to render rotation better.
*/



/*
var YoutubeEmbed = function(id, x, y, z, rx){
	var div = document.createElement('div');
	div.style.width = '480px';
	div.style.height = '360px';
	div.style.backgroundColor = '#000';
	var iframe = document.createElement('iframe');
	iframe.style.width = '480px';
	iframe.style.height = '360px';
	iframe.style.border = '0px';
	iframe.src = ['https://www.youtube.com/embed/', id, '?rel=0&autoplay=1&mute=0'].join('');
	div.appendChild(iframe);
	var object = new CSS3DObject(div);
	object.position.set(x, y, z);
	object.rotation.x = rx;
	return object;
};
*/





function decodeRGBA(argb){
	this.a = (argb >> 24) & 255;
	this.r = (argb >> 16) & 255;
	this.g = (argb >> 8) & 255;
	this.b = argb & 255;
}

function encodeRGBA(a,r,g,b){
	return ((a << 24) | (r << 16) | (g << 8) | b) >>> 0; // ">>> 0" converts to 32bit unsigned integer
}

function valueBetween(from, to, percent){
	return (to-from)*percent+from;
}

function intBetween(from, to, percent){
	return Math.round(valueBetween(from, to, percent));
}

// gives gradient color value at specific point of the gradient line.
function colorBetweenRGBA(from, to, percent){
	let c1 = new decodeRGBA(from);
	let c2 = new decodeRGBA(to);
	return encodeRGBA(
		intBetween(c1.a, c2.a, percent),
		intBetween(c1.r, c2.r, percent),
		intBetween(c1.g, c2.g, percent),
		intBetween(c1.b, c2.b, percent)
	);
}

function colorBetweenRGBA_array(arr, percent){
	let len = arr.length;
	let total_gradients = len-1; // 2 colors have 1 gradient, 3 have 2. etc.
	let step = 1.0/total_gradients;
	let c1 = Math.floor(percent/step);
	let c2 = c1+1;
	if(c2 > len-1){
		c2 = len-1;
	}
	let percent_between = (percent/step)-c1;
	return colorBetweenRGBA(arr[c1], arr[c2], percent_between);
}





var PARAMS;
var SOUND;
var SOUND_VOL = 0.1068; // see sfxr.js (var volume) for volume adjusting for browser. this changes the wav file but doesnt work well because it clips the sounds at too loud or low volumes.
var SAMPLE_RATE = 44100;
var SAMPLE_SIZE = 8;
var CURRENT_TYPE = "";
var LOCKED = {};


Params.prototype.query = function () {
	var result = "";
	var that = this;
	$.each(this, function (key,value) {
		if (that.hasOwnProperty(key)){
			result += "&" + key + "=" + value;
		}
	});
	return result.substring(1);
};


// check_pickupCoin
// fx = pickupCoin
function gen(fx) {
	CURRENT_TYPE = fx;
	$('.checkmark').text("");
	$('#check_'+fx).text(">");
	PARAMS = new Params();
	PARAMS.sound_vol = SOUND_VOL;
	PARAMS.sample_rate = SAMPLE_RATE;
	PARAMS.sample_size = SAMPLE_SIZE;
	if (fx.indexOf("#") == 0) {
		PARAMS.fromB58(fx.slice(1));
		$("#wav").text("random.wav").attr("download", "random.wav");
	} else {
		PARAMS[fx]();
		$("#wav").text(fx + ".wav").attr("download", fx + ".wav");
	}
	updateUi();
	//play();
}




function gen_current(){
	gen(CURRENT_TYPE);
}


function mut() {
	PARAMS.mutate();
	updateUi();
	play();
}



function play(noregen) {
	//console.log(PARAMS);
	if (!noregen) {
		var b58 = PARAMS.toB58();
		if (document.location.href.indexOf("#") != -1) {
			document.location.hash = PARAMS.toB58();
		}
		$("#permalink").attr("href", "#" + b58)
		$("#permalink").text(b58)
		$("#share").attr("href", "#" + b58)
		SOUND = new SoundEffect(PARAMS).generate();
		$("#file_size").text(Math.round(SOUND.wav.length / 1024) + "kB");
		$("#num_samples").text(SOUND.header.subChunk2Size / 
							 (SOUND.header.bitsPerSample >> 3));
		$("#clipping").text(SOUND.clipping);
	}

	$("#wav").attr("href", SOUND.dataURI)  ;
	$("#sfx").attr("href", "sfx.wav?" + PARAMS.query());

	SOUND.getAudio().play();
}

function copy() {
	var b = $("#copybuffer");
	b.css("display", "block");
	b.val($("#permalink").text());
	b.select();
	document.execCommand("copy");
	b.css("display", "none");
}

function serialize_params() {
  $("textarea").val(JSON.stringify(PARAMS, null, 2));
  $("#serialize").show();
}

function deserialize_params() {
  var newPARAMS = JSON.parse($("textarea").val());
  PARAMS.fromJSON(newPARAMS);
  play();
  updateUi();
}

function disenable() {
  var duty = PARAMS.wave_type == SQUARE || PARAMS.wave_type == SAWTOOTH;
  $("#p_duty").slider("option", "disabled", !duty);
  $("#p_duty_ramp").slider("option", "disabled", !duty);
}

function updateUi() {
	$.each(PARAMS, function (param, value) {
		if (param == "wave_type") {
			$("#shape input:radio[value=" + value + "]").
			prop('checked', true).button("refresh");
		} else if (param == "sample_rate") {
			$("#hz input:radio[value=" + value + "]").
			prop('checked', true).button("refresh");
		} else if (param == "sample_size") {
			$("#bits input:radio[value=" + value + "]").
			prop('checked', true).button("refresh");
		} else {
			var id = "#" + param;
			$(id).slider("value", 1000 * value);
			$(id).each(function(){
				convert(this, PARAMS[this.id]);
			});
		}
	});
	disenable();
}
    

$(function() {
	$("#shape").buttonset();
	$("#hz").buttonset();
	$("#bits").buttonset();
	$("#shape input:radio").change(function (event) {
		PARAMS.wave_type = parseInt(event.target.value);
		disenable();
		play();
	});
	$("#hz input:radio").change(function (event) {
		SAMPLE_RATE = PARAMS.sample_rate = parseInt(event.target.value);
		play();
	});
	$("#bits input:radio").change(function (event) {
		SAMPLE_SIZE = PARAMS.sample_size = parseInt(event.target.value);
		play();
	});
	$("button").button();
	$(".slider").slider({
		value: 1000,
		min: 0,
		max: 1000,
		slide: function (event, ui) {
			convert(event.target, ui.value / 1000.0);
		},
		change: function(event, ui) {
			if (event.originalEvent) {
				PARAMS[event.target.id] = ui.value / 1000.0;
				convert(event.target, PARAMS[event.target.id]);
				play();
				console.log(event.target.id);
			}
		}
	});
	$(".slider").filter(".signed").
				 slider("option", "min", -1000).
				 slider("value", 0);
	$('.slider').each(function () {
		var is = this.id;
		if (!$('label[for="' + is + '"]').length) 
		$(this).parent().parent().find('th').append($('<label>', {for: is}));
	});

	var UNITS = {
		p_env_attack:	function (v) { return (v / 44100).toPrecision(4) + ' sec' },
		p_env_sustain: function (v) { return (v / 44100).toPrecision(4) + ' sec' },
		p_env_punch:	 function (v) { return '+' + (v * 100).toPrecision(4) + '%'},
		p_env_decay:	 function (v) { return (v / 44100).toPrecision(4) + ' sec' },
		
		p_base_freq:	'Hz',
		p_freq_limit: 'Hz',
		p_freq_ramp:	function (v) { 
			return (44100*Math.log(v)/Math.log(0.5)).toPrecision(4) + ' 8va/sec'; },
		p_freq_dramp: function (v) { 
			return (v*44100 / Math.pow(2, -44101./44100)).toPrecision(4) + 
			' 8va/sec^2?'; },

		p_vib_speed:		function (v) { return v === 0 ? 'OFF' : 
										 (441000/64. * v).toPrecision(4) + ' Hz'},
		p_vib_strength: function (v) { return v === 0 ? 'OFF' : 
										 '&plusmn; ' + (v*100).toPrecision(4) + '%' },

		p_arp_mod:	 function (v) { return ((v === 1) ? 'OFF' : 
											'x ' + (1./v).toPrecision(4)) },
		p_arp_speed: function (v) { return (v === 0 ? 'OFF' :
											(v / 44100).toPrecision(4) +' sec') },

		p_duty:			function (v) { return (100 * v).toPrecision(4) + '%'; },
		p_duty_ramp: function (v) { return (8 * 44100 * v).toPrecision(4) +'%/sec'},

		p_repeat_speed: function (v) { return v === 0 ? 'OFF' : 
										 (44100/v).toPrecision(4) + ' Hz' },

		p_pha_offset: function (v) { return v === 0 ? 'OFF' :
									 (1000*v/44100).toPrecision(4) + ' msec' },
		// Not so sure about this:
		p_pha_ramp:	 function (v) { return v === 0 ? 'OFF' :
					 (1000*v).toPrecision(4) + ' msec/sec' },

		p_lpf_freq:	 function (v) { 
			return (v === .1) ? 'OFF' : Math.round(8 * 44100 * v / (1-v)) + ' Hz'; },
		p_lpf_ramp:	function (v) {	if (v === 1) return 'OFF';
			return Math.pow(v, 44100).toPrecision(4) + ' ^sec'; },
		p_lpf_resonance: function (v) { return (100*(1-v*.11)).toPrecision(4)+'%';},

		p_hpf_freq:	 function (v) { 
			return (v === 0) ? 'OFF' : Math.round(8 * 44100 * v / (1-v)) + ' Hz'; },
		p_hpf_ramp: function (v) {	if (v === 1) return 'OFF';
			return Math.pow(v, 44100).toPrecision(4) + ' ^sec'; },

		sound_vol: function (v) { 
			v = 10 * Math.log(v*v) / Math.log(10);
			var sign = v >= 0 ? '+' : '';
			return sign + v.toPrecision(4) + ' dB'; 
		}
	};

	var CONVERSIONS = {
		p_env_attack:	function (v) { return v * v * 100000.0 },
		p_env_sustain: function (v) { return v * v * 100000.0 },
		p_env_punch:	 function (v) { return v },
		p_env_decay:	 function (v) { return v * v * 100000.0 },
		
		p_base_freq:	function (v) { return 8 * 44100 * (v * v + 0.001) / 100 },
		p_freq_limit: function (v) { return 8 * 44100 * (v * v + 0.001) / 100 },
		p_freq_ramp:	function (v) { return 1.0 - Math.pow(v, 3.0) * 0.01 },
		p_freq_dramp: function (v) { return -Math.pow(v, 3.0) * 0.000001 },

		p_vib_speed:		function (v) { return Math.pow(v, 2.0) * 0.01 },
		p_vib_strength: function (v) { return v * 0.5 },

		p_arp_mod:	 function (v) { 
			return v >= 0 ? 1.0 - Math.pow(v, 2) * 0.9 : 1.0 + Math.pow(v, 2) * 10; },
		p_arp_speed: function (v) { return (v === 1.0) ? 0 :
									Math.floor(Math.pow(1.0 - v, 2.0) * 20000 +32)},

		p_duty:			function (v) { return 0.5 - v * 0.5; },
		p_duty_ramp: function (v) { return -v * 0.00005 },

		p_repeat_speed: function (v) { return (v === 0) ? 0 :
										 Math.floor(Math.pow(1-v, 2) * 20000) + 32 },

		p_pha_offset: function (v) { return (v < 0 ? -1 : 1) * Math.pow(v,2)*1020 },
		p_pha_ramp:	 function (v) { return (v < 0 ? -1 : 1) * Math.pow(v,2) },

		p_lpf_freq:	 function (v) { return Math.pow(v, 3) * 0.1 },
		p_lpf_ramp:	 function (v) { return 1.0 + v * 0.0001 },
		p_lpf_resonance: function (v) { return 5.0 / (1.0 + Math.pow(v, 2) * 20) }, // * (0.01 + fltw);

		p_hpf_freq: function (v) { return Math.pow(v, 2) * 0.1 },
		p_hpf_ramp: function (v) { return 1.0 + v * 0.0003 },

		sound_vol: function (v) { return Math.exp(v) - 1; }
	};
	for (var p in CONVERSIONS) {
		var control = $('#' + p)[0];
		control.convert = CONVERSIONS[p];
		control.units = UNITS[p];
	}
	
	gen(document.location.hash || "explosion");
	
});

function convert(control, v) {
  if (control.convert) {
    v = control.convert(v);
    control.convertedValue = v;
    if (typeof control.units === 'function')
      v = control.units(v);
    else
      v = v.toPrecision(4) + ' ' + control.units;
    $('label[for="' + control.id + '"]').html(v);
  }
}

</script>

<style>
* {
	box-sizing: border-box;
	cursor:default;
}
body {
	background:#000;
	color:#fff;
	padding:0;
	margin:0;
	overflow:hidden;
	font-family:courier;
	text-align:left;
	font-size:1.5vmax;
}
#gui {
	display:none;
}
#timer {
	display:none;
	position:absolute;
	top:0;
	left:0;
	font:2vmax courier;
	padding:10px 10px 10px 20px;
	background-color:rgba(0,0,0, 0.5);
	text-shadow: 0 0 3px #000000, 0 0 2px #000000, 0 0 1px #000000;
	border-bottom-right-radius:10px;
}
#fps {
	position:absolute;
	top:0;
	left:0;
	font:1vmax courier;
	padding:4px 4px 4px 10px;
	background-color:rgba(0,0,0, 0.5);
	text-shadow: 0 0 3px #000000, 0 0 2px #000000, 0 0 1px #000000;
	border-bottom-right-radius:10px;
}
#info {
	position: absolute;
	bottom:0;
	left:0;
	width: 100%;
	font:1vmax courier;
	padding:4px 4px 4px 10px;
	background-color:rgba(0,0,0, 0.5);
	text-shadow: 0 0 3px #000000, 0 0 2px #000000, 0 0 1px #000000;
}
.elem {
	float:left;
	padding-right:30px;
}

#players {
	text-align:left;
	position:absolute;
	right:0;
	top:0;
	max-width:30vmax;
	padding:0.5vmax;
	background-color:rgba(0,0,0, 0.5);
	border-bottom-left-radius:1vmax;
	font:1vmax courier;
}



#players-ending-scores {
	text-align:left;
	position:absolute;
	left:50%;
	top:15%;
	margin-left:-18vmax;
	margin-top:0;
	width:36vmax;
	padding:10px 10px 10px 10px;
	background-color:rgba(0,0,0, 0.85);
	border-radius:1.5vmax;
	font-size:2vmax;
}


#countdown {
	padding-top:15px;
	width:100%;
	text-align:center;
}

.hidden {
	display:none;
}


#ending-score-table {
	width:100%;
}

#ending-score-table .num {
	width:2vmax;
	padding-left:0.25vmax;
	padding-right:0.25vmax;
	text-align:right;
}
#ending-score-table .nam {
	padding-left:0.5vmax;
	padding-right:10px;
}
#ending-score-table .sco {
	width:3vmax;
	padding-left:0.5vmax;
	padding-right:1vmax;
}
#ending-score-table .ext {
	width:3vmax;
	padding-left:1vmax;
	padding-right:0.25vmax;
	color:rgba(255,255,255, 0.5);
}



</style>
</head>
<body>




<style>
#blocker {
	position: absolute;
	top: 0px;
	left: 0px;
	width: 100%;
	height: 100%;
}
</style>

<div id="container"></div>
<div id="blocker"></div>



<!--
<script src="three.js"></script>
<script src="OrbitControls.js"></script>
-->

<!--<script src="https://threejs.org/examples/js/libs/dat.gui.min.js"></script>-->
<!--<script src="https://threejs.org/examples/js/loaders/OBJLoader.js"></script>-->

<!--
<script src="jquery.min.js"></script>
-->
	
<script>
/*jshint esversion: 6 */
//credit: https://gist.github.com/banksean/304522#file-perlin-noise-simplex-js
class Perlin {
	constructor() {
		this.grad3 = [[1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0], [1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1], [0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1]]; 
		this.p = []; for (var i=0; i<256; i++) { this.p[i] = Math.floor(Math.random()*256);}
		this.perm = []; for(i=0; i<512; i++) { this.perm[i]=this.p[i & 255];} 
		this.simplex = [[0,1,2,3],[0,1,3,2],[0,0,0,0],[0,2,3,1],[0,0,0,0],[0,0,0,0],[0,0,0,0],[1,2,3,0],[0,2,1,3],[0,0,0,0],[0,3,1,2],[0,3,2,1],[0,0,0,0],[0,0,0,0],[0,0,0,0],[1,3,2,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[1,2,0,3],[0,0,0,0],[1,3,0,2],[0,0,0,0],[0,0,0,0],[0,0,0,0],[2,3,0,1],[2,3,1,0],[1,0,2,3],[1,0,3,2],[0,0,0,0],[0,0,0,0],[0,0,0,0],[2,0,3,1],[0,0,0,0],[2,1,3,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[2,0,1,3],[0,0,0,0],[0,0,0,0],[0,0,0,0],[3,0,1,2],[3,0,2,1],[0,0,0,0],[3,1,2,0],[2,1,0,3],[0,0,0,0],[0,0,0,0],[0,0,0,0],[3,1,0,2],[0,0,0,0],[3,2,0,1],[3,2,1,0]]; 
	}
	dot(g, x, y){ return g[0]*x + g[1]*y;}
	noise(xin, yin) { 
		var n0, n1, n2;var F2 = 0.5*(Math.sqrt(3.0)-1.0); var s = (xin+yin)*F2;var i = Math.floor(xin+s); var j = Math.floor(yin+s); var G2 = (3.0-Math.sqrt(3.0))/6.0; var t = (i+j)*G2; var X0 = i-t;var Y0 = j-t; var x0 = xin-X0;var y0 = yin-Y0; var i1, j1; if(x0>y0) {i1=1; j1=0;} else {i1=0; j1=1;} var x1 = x0 - i1 + G2;var y1 = y0 - j1 + G2; var x2 = x0 - 1.0 + 2.0 * G2;var y2 = y0 - 1.0 + 2.0 * G2; var ii = i & 255; var jj = j & 255; var gi0 = this.perm[ii+this.perm[jj]] % 12; var gi1 = this.perm[ii+i1+this.perm[jj+j1]] % 12; var gi2 = this.perm[ii+1+this.perm[jj+1]] % 12; var t0 = 0.5 - x0*x0-y0*y0; if(t0<0) n0 = 0.0; else { t0 *= t0; n0 = t0 * t0 * this.dot(this.grad3[gi0], x0, y0);} var t1 = 0.5 - x1*x1-y1*y1; if(t1<0) n1 = 0.0; else { t1 *= t1; n1 = t1 * t1 * this.dot(this.grad3[gi1], x1, y1); }var t2 = 0.5 - x2*x2-y2*y2; if(t2<0) n2 = 0.0; else { t2 *= t2; n2 = t2 * t2 * this.dot(this.grad3[gi2], x2, y2); } return 70.0 * (n0 + n1 + n2);
	}
}
</script>



<style>
.checkmark {
	min-width:20px;
	width:20px;
	font:bold 14px verdana;
	margin-right:5px;
}

.but_play, .but_new {
	width:78px;
}

#loading_desc {
	font:12px verdana;
	color:#000;
}


</style>

<div id="loading_container"><div id="loading_container_inner">
<div id="loading_text">

<div class="lds-ellipsis-left"><div></div><div></div><div></div><div></div></div>Loading<div class="lds-ellipsis"><div></div><div></div><div></div><div></div></div>

</div>
<div id="loading_desc">Working...</div>

</div></div>


<div id="gui">

	<div id="timer">
	</div>

	<div id="fps">
	FPS: 0
	</div>

	<div id="info">
		<div class="elem">
			X: <span id="player-x">0</span>
		</div>
		<div class="elem">
			Y: <span id="player-z">0</span>
		</div>
		<div class="elem">
			Z: <span id="player-y">0</span>
		</div>
		<div class="elem">
			Deg: <span id="player-angle">0</span>
		</div>
	</div>

	<div id="players">
		<div id="scores" style="display:none">
		</div>
		
		
		<!--need to have these inputs for sfxr to work -->
		
		
		<div style="display:none" id="sfxr_panel">

			<div id="generators">
			  <span class="checkmark" id="check_pickupCoin"></span><button onclick="gen('pickupCoin')">Pickup/coin</button> <br/>
			  <span class="checkmark" id="check_laserShoot"></span><button onclick="gen('laserShoot')">Laser/shoot</button> <br/>
			  <span class="checkmark" id="check_explosion"></span><button onclick="gen('explosion')">Explosion</button> <br/>
			  <span class="checkmark" id="check_powerUp"></span><button onclick="gen('powerUp')">Powerup</button> <br/>
			  <span class="checkmark" id="check_hitHurt"></span><button onclick="gen('hitHurt')">Hit/hurt</button> <br/>
			  <span class="checkmark" id="check_jump"></span><button onclick="gen('jump')">Jump</button> <br/>
			  <span class="checkmark" id="check_click"></span><button onclick="gen('click')">Click</button> <br/>
			  <span class="checkmark" id="check_blipSelect"></span><button onclick="gen('blipSelect')">Blip/select</button> <br/>
			  <span class="checkmark" id="check_synth"></span><button onclick="gen('synth')">Synth</button> <br/>
			  <span class="checkmark" id="check_random"></span><button onclick="gen('random')">Random</button> <br/>
			  <br/>
			  
			  <p>
			  <div>
				<button onclick="play(true)" class="but_play">Play</button>
				<button onclick="gen_current()" class="but_new">New</button>
				</div><br>
			  </p>
			  <button onclick="mut()" class="but_mutate">Mutate</button> <br/>
			  
			  
			<div style="border-radius:5px; background-color:#DDDDDD; padding:10px;margin:6px">Save:&nbsp;<a id="wav">sfx.wav</a></div>
			  <input id="copybuffer"/>
			</div>

			<div class="demo">
			<form>
			  <div id="shape">
				<input type="radio" id="square" value=0 name="shape" />
				  <label for="square">Square</label>
				<input type="radio" id="sawtooth" value=1 name="shape" checked="checked" />
				  <label for="sawtooth">Sawtooth</label>
				<input type="radio" id="sine" value=2 name="shape" />
				  <label for="sine">Sine</label>
				<input type="radio" id="noise" value=3 name="shape" />
				  <label for="noise">Noise</label>
			  </div>
			</form>

			<style>
			.lock {
				min-width:50px;
			}
			.pbend {
				min-width:50px;
			}
			.linkvel {
				min-width:50px;
			}

			.th_title {
				padding-left:175px;
			}
			</style>

			<table style="margin-left:20px">
			<tr>
				<td>Lock</td>
				<td>Ln.Bnd</td>
				<td>Ln.Vel</td>
				<th colspan=5>Volume Gain</th>
			</tr>
			<tr>
				<td class="lock"><input class="lockbtn" id="lock_sound_vol" type="checkbox" value="1"></td>
				<td class="pbend"><input class="pbendbut" id="lock_sound_vol" type="checkbox" value="1"></td>
				<td class="linkvel"><input class="linkvelbut" id="lock_sound_vol" type="checkbox" value="1"></td>
				<td><div class="slider" id="sound_vol"></div></td>
				<th style="width:200px">Gain</th>
			</tr>
			<tr>
				<th colspan=5 class="th_title">Envelope</th>
			</tr>
			<tr>
				<td class="lock"><input class="lockbtn" id="lock_p_env_attack" type="checkbox" value="1"></td>
				<td class="pbend"><input class="pbendbut" id="lock_sound_vol" type="checkbox" value="1"></td>
				<td class="linkvel"><input class="linkvelbut" id="lock_sound_vol" type="checkbox" value="1"></td>
				<td><div class="slider" id="p_env_attack"></div></td>
				<th style="width:200px">Attack time</th>
			</tr>
			<tr>
				<td class="lock"><input class="lockbtn" id="lock_p_env_sustain" type="checkbox" value="1"></td>
				<td class="pbend"><input class="pbendbut" id="lock_sound_vol" type="checkbox" value="1"></td>
				<td class="linkvel"><input class="linkvelbut" id="lock_sound_vol" type="checkbox" value="1"></td>
				<td><div class="slider" id="p_env_sustain"></div></td>
				<th>Sustain time</th>
			</tr>
			<tr>
				<td class="lock"><input class="lockbtn" id="lock_p_env_punch" type="checkbox" value="1"></td>
				<td class="pbend"><input class="pbendbut" id="lock_sound_vol" type="checkbox" value="1"></td>
				<td class="linkvel"><input class="linkvelbut" id="lock_sound_vol" type="checkbox" value="1"></td>
				<td><div class="slider" id="p_env_punch"></div></td>
				<th>Sustain punch</th>
			</tr>
			<tr>
				<td class="lock"><input class="lockbtn" id="lock_p_env_decay" type="checkbox" value="1"></td>
				<td class="pbend"><input class="pbendbut" id="lock_sound_vol" type="checkbox" value="1"></td>
				<td class="linkvel"><input class="linkvelbut" id="lock_sound_vol" type="checkbox" value="1"></td>
				<td><div class="slider" id="p_env_decay"></div></td>
				<th>Decay time</th>
			</tr>
			<tr>
				<th colspan=5 class="th_title">Frequency</th>
			</tr>
			<tr>
				<td class="lock"><input class="lockbtn" id="lock_p_base_freq" type="checkbox" value="1"></td>
				<td class="pbend"><input class="pbendbut" id="lock_sound_vol" type="checkbox" value="1"></td>
				<td class="linkvel"><input class="linkvelbut" id="lock_sound_vol" type="checkbox" value="1"></td>
				<td><div class="slider" id="p_base_freq"></div></td>
				<th>Start frequency</th>
			</tr>
			<tr>
				<td class="lock"><input class="lockbtn" id="lock_p_freq_limit" type="checkbox" value="1"></td>
				<td class="pbend"><input class="pbendbut" id="lock_sound_vol" type="checkbox" value="1"></td>
				<td class="linkvel"><input class="linkvelbut" id="lock_sound_vol" type="checkbox" value="1"></td>
				<td><div class="slider" id="p_freq_limit"></div></td>
				<th>Min freq. cutoff</th>
			</tr>
			<tr>
				<td class="lock"><input class="lockbtn" id="lock_p_freq_ramp" type="checkbox" value="1"></td>
				<td class="pbend"><input class="pbendbut" id="lock_sound_vol" type="checkbox" value="1"></td>
				<td class="linkvel"><input class="linkvelbut" id="lock_sound_vol" type="checkbox" value="1"></td>
				<td><div class="signed slider" id="p_freq_ramp"></div></td>
				<th>Slide</th>
			</tr>
			<tr>
				<td class="lock"><input class="lockbtn" id="lock_p_freq_dramp" type="checkbox" value="1"></td>
				<td class="pbend"><input class="pbendbut" id="lock_sound_vol" type="checkbox" value="1"></td>
				<td class="linkvel"><input class="linkvelbut" id="lock_sound_vol" type="checkbox" value="1"></td>
				<td><div class="signed slider" id="p_freq_dramp"></div></td>
				<th>Delta slide</th>
			</tr>
			<tr>
				<th colspan=5 class="th_title">Vibrato</th>
			</tr>
			<tr>
				<td class="lock"><input class="lockbtn" id="lock_p_vib_strength" type="checkbox" value="1"></td>
				<td class="pbend"><input class="pbendbut" id="lock_sound_vol" type="checkbox" value="1"></td>
				<td class="linkvel"><input class="linkvelbut" id="lock_sound_vol" type="checkbox" value="1"></td>
				<td><div class="slider" id="p_vib_strength"></div></td>
				<th>Depth</th>
			</tr>
			<tr>
				<td class="lock"><input class="lockbtn" id="lock_p_vib_speed" type="checkbox" value="1"></td>
				<td class="pbend"><input class="pbendbut" id="lock_sound_vol" type="checkbox" value="1"></td>
				<td class="linkvel"><input class="linkvelbut" id="lock_sound_vol" type="checkbox" value="1"></td>
				<td><div class="slider" id="p_vib_speed"></div></td>
				<th>Speed</th>
			</tr>
			<tr>
				<th colspan=5 class="th_title">Arpeggiation</th>
			</tr>
			<tr>
				<td class="lock"><input class="lockbtn" id="lock_p_arp_mod" type="checkbox" value="1"></td>
				<td class="pbend"><input class="pbendbut" id="lock_sound_vol" type="checkbox" value="1"></td>
				<td class="linkvel"><input class="linkvelbut" id="lock_sound_vol" type="checkbox" value="1"></td>
				<td><div class="signed slider" id="p_arp_mod"></div></td>
				<th>Frequency mult</th>
			</tr>
			<tr>
				<td class="lock"><input class="lockbtn" id="lock_p_arp_speed" type="checkbox" value="1"></td>
				<td class="pbend"><input class="pbendbut" id="lock_sound_vol" type="checkbox" value="1"></td>
				<td class="linkvel"><input class="linkvelbut" id="lock_sound_vol" type="checkbox" value="1"></td>
				<td><div class="slider" id="p_arp_speed"></div></td>
				<th>Change speed</th>
			</tr>
			<tr>
				<th colspan=5 class="th_title">Duty Cycle</th>
			</tr>
			<tr>
				<td class="lock"><input class="lockbtn" id="lock_p_duty" type="checkbox" value="1"></td>
				<td class="pbend"><input class="pbendbut" id="lock_sound_vol" type="checkbox" value="1"></td>
				<td class="linkvel"><input class="linkvelbut" id="lock_sound_vol" type="checkbox" value="1"></td>
				<td><div class="slider" id="p_duty"></div></td>
				<th>Duty cycle</th>
			</tr>
			<tr>
				<td class="lock"><input class="lockbtn" id="lock_p_duty_ramp" type="checkbox" value="1"></td>
				<td class="pbend"><input class="pbendbut" id="lock_sound_vol" type="checkbox" value="1"></td>
				<td class="linkvel"><input class="linkvelbut" id="lock_sound_vol" type="checkbox" value="1"></td>
				<td><div class="signed slider" id="p_duty_ramp"></div></td>
				<th>Sweep</th>
			</tr>
			<tr>
				<th colspan=5 class="th_title">Retrigger</th>
			</tr>
			<tr>
				<td class="lock"><input class="lockbtn" id="lock_p_repeat_speed" type="checkbox" value="1"></td>
				<td class="pbend"><input class="pbendbut" id="lock_sound_vol" type="checkbox" value="1"></td>
				<td class="linkvel"><input class="linkvelbut" id="lock_sound_vol" type="checkbox" value="1"></td>
				<td><div class="slider" id="p_repeat_speed"></div></td>
				<th>Rate</th>
			</tr>
			<tr>
				<th colspan=5 class="th_title">Flanger</th>
			</tr>
			<tr>
				<td class="lock"><input class="lockbtn" id="lock_p_pha_offset" type="checkbox" value="1"></td>
				<td class="pbend"><input class="pbendbut" id="lock_sound_vol" type="checkbox" value="1"></td>
				<td class="linkvel"><input class="linkvelbut" id="lock_sound_vol" type="checkbox" value="1"></td>
				<td><div class="signed slider" id="p_pha_offset"></div></td>
				<th>Offset</th>
			</tr>
			<tr>
				<td class="lock"><input class="lockbtn" id="lock_p_pha_ramp" type="checkbox" value="1"></td>
				<td class="pbend"><input class="pbendbut" id="lock_sound_vol" type="checkbox" value="1"></td>
				<td class="linkvel"><input class="linkvelbut" id="lock_sound_vol" type="checkbox" value="1"></td>
				<td><div class="signed slider" id="p_pha_ramp"></div></td>
				<th>Sweep</th>
			</tr>
			<tr>
				<th colspan=5 class="th_title">Low-Pass Filter</th>
			</tr>
			<tr>
				<td class="lock"><input class="lockbtn" id="lock_p_lpf_freq" type="checkbox" value="1"></td>
				<td class="pbend"><input class="pbendbut" id="lock_sound_vol" type="checkbox" value="1"></td>
				<td class="linkvel"><input class="linkvelbut" id="lock_sound_vol" type="checkbox" value="1"></td>
				<td><div class="slider" id="p_lpf_freq"></div></td>
				<th>Cutoff frequency</th>
			</tr>
			<tr>
				<td class="lock"><input class="lockbtn" id="lock_p_lpf_ramp" type="checkbox" value="1"></td>
				<td class="pbend"><input class="pbendbut" id="lock_sound_vol" type="checkbox" value="1"></td>
				<td class="linkvel"><input class="linkvelbut" id="lock_sound_vol" type="checkbox" value="1"></td>
				<td><div class="signed slider" id="p_lpf_ramp"></div></td>
				<th>Cutoff sweep</th>
			</tr>
			<tr>
				<td class="lock"><input class="lockbtn" id="lock_p_lpf_resonance" type="checkbox" value="1"></td>
				<td class="pbend"><input class="pbendbut" id="lock_sound_vol" type="checkbox" value="1"></td>
				<td class="linkvel"><input class="linkvelbut" id="lock_sound_vol" type="checkbox" value="1"></td>
				<td><div class="slider" id="p_lpf_resonance"></div></td>
				<th>Resonance</th>
			</tr>
			<tr>
				<th colspan=5 class="th_title">High-Pass Filter</th>
			</tr>
			<tr>
				<td class="lock"><input class="lockbtn" id="lock_p_hpf_freq" type="checkbox" value="1"></td>
				<td class="pbend"><input class="pbendbut" id="lock_sound_vol" type="checkbox" value="1"></td>
				<td class="linkvel"><input class="linkvelbut" id="lock_sound_vol" type="checkbox" value="1"></td>
				<td><div class="slider" id="p_hpf_freq"></div></td>
				<th>Cutoff frequency</th>
			</tr>
			<tr>
				<td class="lock"><input class="lockbtn" id="lock_p_hpf_ramp" type="checkbox" value="1"></td>
				<td class="pbend"><input class="pbendbut" id="lock_sound_vol" type="checkbox" value="1"></td>
				<td class="linkvel"><input class="linkvelbut" id="lock_sound_vol" type="checkbox" value="1"></td>
				<td><div class="signed slider" id="p_hpf_ramp"></div></td>
				<th>Cutoff sweep</th>
			</tr>
			</table>


			</div>


			<br/>

			<div id="data">
			  <button onclick="serialize_params();"> ▼ SoundToCode</button>
			  <button onclick="deserialize_params()"> ▲ CodeToSound</button>
			  <div id="serialize">
				<textarea></textarea>
				<button onclick="$('textarea').select(); document.execCommand('copy');">Copy</button>
				<button onclick="$('#serialize').hide();">Hide ✕</button>
			  </div>
			</div>
		

		</div>

	</div>

	<div id="players-ending-scores" class="hidden">
		<div id="ending-scores">
		</div>
		<div id="countdown"></div>
	</div>
</div>

<script>


var ortho = true;
var smoothRender = 1;

var globalFilter = smoothRender ? THREE.LinearFilter : THREE.NearestFilter;

	



var SHOW_WAVE_BG = false;
var SHOW_RAIN_BG = false; // rain enabled/disabled
var SHOW_MAP_BG = true;
var SHOW_NIGHTSKY_BG = false;
var turrets_enabled = true;


var fade_dir = 0;
var night_fade_dir = 0;

var plane_flipped = false; // 0 = not upside down. 1 = upside down.
var flip_dir = 0; // which direction animation is going. 0 = nowhere, 1 = to flip dir, 2 = to unflip dir.
var planeFrameNum = 0;
var planeFrameNumX = 0;



///////////////////////////////////////////////////////
// z-indexes for different layers of objects:
// from furthest to nearest (in the order of rendering; first in this list = smallest number = first to render).
//
var ZIN = -200; // current z-index
var ZINSTEP = 100;
// create new Z-index value
function NEWZIN(){
	ZIN += ZINSTEP;
	return ZIN-ZINSTEP;
}

var Z_SKYBOX = NEWZIN(); // the most furthest clouds (skybox).

var Z_CLOUDS = NEWZIN(); // clouds parallax


var Z_MAP_WATER_BACK = NEWZIN();

var Z_MAP_WATERDROPS = NEWZIN();

var Z_MAP_BG = NEWZIN(); // map texture (back layer / map background parallax).




var Z_MAP_BEHIND = NEWZIN(); // map sprites layer

var Z_MAP_BEHIND_FRONT = NEWZIN(); // on front of the behind items.

var Z_TURRET = NEWZIN(); //  turrets behind every other object.




var Z_MAP_BOMBS = NEWZIN();
var Z_MAP_SHOTS = NEWZIN();

var Z_BOMBER = NEWZIN(); // enemy planes basically.
var Z_PLANE = NEWZIN(); // airplanes.
var Z_SOLDIER = NEWZIN(); // soldiers.




var Z_MAP_EXPLOSIONS = NEWZIN();


var Z_MAP_DECALS = NEWZIN(); // decals (bushes to hide behind)

var Z_MAP_FRONT = NEWZIN(); // map sprites layer

var Z_MAP_COLLISION = NEWZIN(); // main map texture.

var Z_MAP_COLLISION_FRONT = NEWZIN(); // when on front "lane"





var Z_MAP_WATER_FRONT = NEWZIN();

var Z_MAP_SPLASHES = NEWZIN();

var Z_MAP_VISUALS = NEWZIN(); // explosion glows etc.



var Z_RAIN = NEWZIN(); // rain texture.
//
////////////////////////////////////////////////////





if(ortho){
	sizemulti = 0.1;
}



var urlprefix = ""; // possibly used when using server to host files: "https://md.com/" etc.

var map_name = "highmap";
var map_data_url = urlprefix+'maps/'+map_name+'/settings.json';



function texture_path(name){
	return urlprefix+TEXTURES[name].path;
}


let default_texture_config = {
	// stuff like linear filter, repeat, offset... etc.
};


var TEXTURES = {
	'splash_sprite_url': 		{path: 'sprites/splash.png', 
								config: default_texture_config},
								
	'glowsprite_url': 			{path: 'sprites/glow2b.png', 
								config: default_texture_config},
								
	'map_bg_url': 				{path: 'maps/parallax.png', 
								config: default_texture_config},
								
	'santa_sprite_url': 		{path: "sprites/SantaSleigh.png", 
								config: default_texture_config},
								
	'santa_lights_sprite_url': 	{path: "sprites/SantaSleigh-lights3c.png", 
								config: default_texture_config},
								
	'plane_sprite_url': 		{path: "sprites/AirplaneFullSpin-scaled.png", 
								config: default_texture_config},
								
	'plane_lights_sprite_url': 	{path: "sprites/AirplaneFullSpin-scaled-lights2.png", 
								config: default_texture_config},
								
	'helicopter_test_url': 		{path: "sprites/helicopter_2x.png", 
								config: default_texture_config},
								
	'helicopter_lights_sprite_url': {path: "sprites/helicopter_2x-lights.png", 
								config: default_texture_config},
								
	'bomber_sprite_url': 		{path: 'sprites/bomber_c47_2x.png', 
								config: default_texture_config},
								
	'bomber_lights_sprite_url': {path: 'sprites/bomber_c47_2x-lights2.png', 
								config: default_texture_config},
								
	'fighters_url': 			{path: "sprites/fighter_planes.png", 
								config: default_texture_config},
								
	'map_water_url': 			{path: 'textures/water2.jpg', 
								config: default_texture_config},
								
	'map_waterdrops_url': 		{path: 'textures/raindrop-ripples-oneliner2.png', 
								config: default_texture_config},
								
	'skybox_url': 				{path: "textures/clouds/cloud-bg.jpg", 
								config: default_texture_config},
								
	'clouds_bg_url': 			{path: 'textures/clouds/cloud-layer.png', 
								config: default_texture_config},
								
	'nightsky_url': 			{path: "textures/clouds/stars.png", 
								config: default_texture_config},
								
	'bg2_url': 					{path: 'textures/rainfall.png', 
								config: default_texture_config},
								
	'map_url': 					{path: 'maps/'+map_name+'/collision.png', 
								config: default_texture_config},
								
	'map_behind_url': 			{path: 'maps/'+map_name+'/behind.png', 
								config: default_texture_config},
								
	'map_behind_lights_url': 	{path: 'maps/'+map_name+'/behind-lights.png', 
								config: default_texture_config},
								
	'map_front_url': 			{path: 'maps/'+map_name+'/front.png', 
								config: default_texture_config},
								
	'explosion_sprites_url': 	{path: 'sprites/explosions-big1.png', 
								config: default_texture_config},
								
	'bombs_sprite_url': 		{path: 'sprites/bomb.png', 
								config: default_texture_config},
								
	'shots_sprite_url': 		{path: 'sprites/shot2.png', 
								config: default_texture_config},
								
	'shots_lights_sprite_url': 	{path: 'sprites/shot2-lights.png', 
								config: default_texture_config},
								
	'stream_sprite_url': 		{path: 'sprites/stream.png', 
								config: default_texture_config},
								
	'turret_sprite_url': 		{path: 'sprites/turrets_3x.png', 
								config: default_texture_config},
								
	'mario_sprite_url': 		{path: 'sprites/mario_3x.png', 
								config: default_texture_config},
								
	'soldier_sprite_url': 		{path: 'sprites/soldier-3x.png', 
								config: default_texture_config},
};



// frames are order from the beginning. must be converted to sprite sheet coordinate.
var SPRITES = {
	'soldier': {
		/*
		added at initialize_sprite:
		sprite['w'] = w;
		sprite['h'] = h;
		sprite['sheet_w'] = sheet_w;
		sprite['sheet_h'] = sheet_h;
		sprite['frames_x'] = frames_x; // total frames horizontally in the sheet.
		sprite['anims_coords'] = {}; // calculated texcoords.
		*/
		'anims': {
			'stand_idle': [1], // 31 identical
			'prone_idle': [25],
			'crouch_idle': [21],
			'jump_start': [2,3,4],
			'jump_spin': [5,6,7,8],
			'jump_land': [9,10,11],
			'running': [12,13,14,15,16,17],
			'stand_prone': [18,19,20,21,22,23,24,25],
			'crouch_prone':      [20,21,22,23,24,25],
			'prone_shoot': [26,27,28,29,30],
			'stand_shoot': [32,33,34,35,36,37],
			'crouch_shoot': [38,39,40,41,42,43],
			'swim_idle': [44,45,46,47,48,49,50,51,52,53,54,55],
			'swim_slow': [56,57,58,59,60,61],
			'swim_fast': [62,63,64,65,66,67,68,69],
			'dead': [70],
			'standing': [71],
			'floating': [72],
			'dive_start': [73,74,75,76,77],
			'basic_swim': [78,79,80,81,82,83,84,85,86],
			'basic_swim': [78,79,80,81,82,83,84,85,86],
			'sit': [87],
			'shit': [88],
		},
	},
	// each key is initialized at the image loader.
	// = each key handles one image texture coords.
	'turret': {
		'anims': {
			// antiair:
			'aa_idle': [1],
			'aa_dead': [2],
			'aa_barrel': [3],
			'bomber_idle': [5],
			'bomber_dead': [6],
			'bomber_barrel': [7],
			
			// ground turret:
			// ?
		},
	},
	'mario': {
		'anims': {
			'stand_idle': [1],
			'walk': [1,2,3,2],
		},
	},
};




// returns frame coordinate from sprite index: (only works left to right, top to bottom).
function get_xy(pos, w, h, frames_x){
	let xf = pos % frames_x;
	let yf = Math.floor(pos/frames_x);
	this.x = xf*w;
	this.y = yf*h;
}



// returns frame offset as texture coordinates:
// get_frame get_animation_frame
function frame_offset(spriteName, animName, frameIndex){
	if(typeof SPRITES[spriteName] === "undefined"){
		console.log("UNKNOWN sprite['"+spriteName+"']");
		return {x:-1,y:-1};
	}else if(typeof SPRITES[spriteName]['anims_coords'][animName] === "undefined"){
		console.log("UNKNOWN sprite['"+spriteName+"']['"+animName+"']");
		return {x:-1,y:-1};
	}else if(typeof SPRITES[spriteName]['anims_coords'][animName][frameIndex] === "undefined"){
		console.log("UNKNOWN sprite['"+spriteName+"']['"+animName+"']["+frameIndex+"]");
		return {x:-1,y:-1};
	}else{
		return SPRITES[spriteName]['anims_coords'][animName][frameIndex]; // {x,y}
	}
}



function initialize_sprite(spriteName, w, h, sheet_w, sheet_h, frames_x){
	let sprite = SPRITES[spriteName];
	// add new values:
	sprite['w'] = w;
	sprite['h'] = h;
	sprite['sheet_w'] = sheet_w;
	sprite['sheet_h'] = sheet_h;
	sprite['frames_x'] = frames_x; // total frames horizontally in the sheet.
	sprite['anims_coords'] = {};

	let spriteAnims = sprite.anims;
	for(var animName in spriteAnims) {
		if(spriteAnims.hasOwnProperty(animName)){
			let anim = spriteAnims[animName];
			sprite['anims_coords'][animName] = [];
			for(let i = 0; i < anim.length; i++){
				// index starts from 1, so -1:
				let pos = new get_xy(anim[i]-1, w, h, frames_x);
				sprite['anims_coords'][animName].push({
					x: pos.x/sheet_w, // translate to texture coordinates offset values
					y: pos.y/sheet_h,
				});
			}
		}
	}
}




/*
function cache_all_sprite_anims(){
	for(var spriteName in SPRITES){
		if(SPRITES.hasOwnProperty(spriteName)){
			let sprite = SPRITES[spriteName];
			if(!sprite.hasOwnProperty('anims_coords')){
				sprite['anims_coords'] = [];
			}
			let spriteAnims = sprite.anims;
			for(var animName in spriteAnims) {
				if(spriteAnims.hasOwnProperty(animName)){
					let anim = spriteAnims[animName];
					if(!sprite['anims_coords'].hasOwnProperty(animName)){
						sprite['anims_coords'][animName] = [];
					}
					for(let i = 0; i < anim.length; i++){
						let pos = new get_xy(anim[i], sprite.w, sprite.h, sprite.frames_x);
						sprite['anims_coords'][animName].push(pos);
					}
				}
			}
		}
	}
	console.log(SPRITES);
}
*/




// checks if xy coord on map is ground or not
// hits_ground
function is_ground(x,y){
	let dx = Math.round(x+MAP_W/2);
	let dy = Math.round(y+MAP_H/2);
	
	if(dx >= 0 && dx < MAP_W && dy >= 0 && dy < MAP_H){
		if(MAP_DATA[dy*MAP_W+dx] > 40){
			return true;
		}
	}
	return false;
}






var skyboxColor = 0xFFFFFF;
var skyboxColorRain = 0xDDDDDD;

var cloudsColor = 0xFFFFFF;
var cloudsColorRain = 0x444444;


var rainMaxOpacity = 0.7; // values greater than 1 possible.
var raindropsMaxOpacity = 1; // values greater than 1 possible.

var nightskyMaxOpacity = 1.0;
var min_ambient_light = 0.25;
var max_ambient_light = 1.0;
var min_cloud_opa = 0.2;


var cloudColorFrom = cloudsColor; // will be initialized on rain switch.
var cloudColorTo = cloudsColorRain;

var skyboxColorFrom = skyboxColor; // will be initialized on rain switch.
var skyboxColorTo = skyboxColorRain;

var maptexImg;
var maptexImg2;
var maptexImg3;
var behindEmissiveTex;
var maptexImg4;
var mapTexWater;
var mapTexWaterDrops;

var bgTexImg1;
var bgTexImg2;
var bgTexClouds;
var skyboxImg;
var nightskyImg;






var playerSpriteTest;
var planeEmissiveTex;
var helicopterSpriteTest;
var helicopterEmissiveTex;
var santaSpriteTest;
var santaEmissiveTex;
var bomberEmissiveTex;
var soldierSpriteTest;
var explosionSpriteTest;
var splashSpriteTest;
var glowspriteTex;
var bombSpriteTest;
var shotSpriteTest;
var shotlightsTex;
var bomberSpriteTest;
var turretSpriteTest;
var streamSpriteTest;




var KEYS = {};

// key_pressed
function key_down(keyCode){
	if(KEYS.hasOwnProperty(keyCode)){
		return KEYS[keyCode];
	}
	return false;
}

var CANVAS_W = 1; // debug values. initialized at init()
var CANVAS_H = 1;

var MOUSE_X = -1; // -1 = not set.
var MOUSE_Y = -1;

var prevBombTime = 0;
var bombStartTime = 0;
var bombingStarted = false;

let continuous_shoot_delay = 300; // continuous shooting starts after this time.
let planegun_delay = 80;
let bombgun_delay = 30;

let rainspeed = 1.4*1.6;
let rain_fade_speed = 0.01;
var night_fade_speed = 0.01;

let ambient_light = 1;


let GRAVITY_CONSTANT = 0.1; // was 0.06
let BUOYANCY_CONSTANT = 0.01; // force to player making him rise up from water.
let AIR_RESISTANCE = 0.995; // kx multiplied by this on air.
let WATER_RESISTANCE = 0.97; // kx multiplied by this in water.


let MAX_TEX_SIZE = 1024; // will be initialized at pre_init

let antialiasing = false;

var MAP_DATA = null;
var COLLISION_DATA = {}; // all collideable sprites images are stored as 8bit per pixel data here for collision detection.

let map_defaults = {}; // default map settings which will be combined with map settings.json.
let mapinfo = {};


var OWNER_AI = -1; // ai owner id.


// player types:
var TYPE_PLANE = 0; // wind/air affected. not flipped.
var TYPE_SOLDIER = 1; // gravity/air affected. flipped in x axis when moving to other direction.
var TYPE_BOAT = 2; // water/air affected. flipped in x axis when moving to other direction.
var TYPE_SANTA = 3; // nothing affected? flipped in x axis when moving to other direction.
var TYPE_HELI = 4; // helicopter. flipped in x axis.

// player weapons:
var WEAPON_PLANEGUN = 0;
var WEAPON_SHOTGUN = 1;
var WEAPON_BOMB = 2;

// explosion types:
var EXPLOSION_ROUND = 0; // generic explosion anywhere since its circular shape.
var EXPLOSION_FLAT = 1; // explosion for buildings etc that are on flat surface.

// explosion sizes:
var EXPLOSION_TINY = 0;
var EXPLOSION_SMALL = 1;
var EXPLOSION_MEDIUM = 2;
var EXPLOSION_LARGE = 3; // explosion_big
var EXPLOSION_HUGE = 4;
var EXPLOSION_HUGE2 = 5;
var EXPLOSION_HUGE3 = 6;
var EXPLOSION_SHOTGUN = 7;

// splash sizes:
var SPLASH_TINY = 0;
var SPLASH_SMALL = 1;
var SPLASH_MEDIUM = 2;
var SPLASH_LARGE = 3;
var SPLASH_HUGE = 4;
var SPLASH_HUGE2 = 5;


// bomber plane types:
var PLANE_BOMBER = 0;
var PLANE_HORNET = 1;
var PLANE_UFO = 2;


// turret types:
var TURRET_ANTIAIR = 0; // turret shooting airplanes.
var TURRET_BOMBER = 1; // shooting bombs.
var TURRET_GROUND = 2; // turret shooting ground units.






var gameLoadedVar = false;

// list of things loaded or not. game wont start until all are loaded.
var loaded = {
	map_settings: false,
	glowsprite: false,
	nightsky: false,
	map: false,
	map_bg: false,
	map_behind: false,
	map_behind_lights: false,
	map_front: false,
	santa: false,
	santa_lights: false,
	plane: false,
	plane_lights: false,
	skybox: false,
	clouds: false,
	rain: false,
	water: false,
	waterdrops: false,
	explosions: false,
	bombs: false,
	splashes: false,
	shots: false,
	shots_lights: false,
	bomber: false,
	stream: false,
	turret: false,
	soldier: false,
	helicopter: false,
	helicopter_lights: false,
};






function load_textures(){
	for(let i = 0; i < TEXTURES.length; i++){
	/*
		soldierSpriteTest = new THREE.TextureLoader().load(texture_path('soldier_sprite_url'), function(tex){
			tex.image = correct_texture_size(tex.image);
			loaded.soldier = true;
			set_loading_desc("Soldier loaded");
			
			let scale = 3;
			let frameW = 52*scale;
			let frameH = 43*scale;
			let frames_x = 6;
			

		
			initialize_sprite('soldier', frameW, frameH, tex.image.width, tex.image.height, frames_x);
			console.log(SPRITES);

			soldierSpriteTest.minFilter = globalFilter;
			soldierSpriteTest.magFilter = globalFilter;
			soldierSpriteTest.repeat.x = frameW/tex.image.width;
			soldierSpriteTest.repeat.y = frameH/tex.image.height;
			soldierSpriteTest.offset.x = 0;
			soldierSpriteTest.offset.y = 0;
			soldierSpriteTest.flipY = false;
		});
		*/
	}
}





	
function rescale_skybox(){
	let aspect = CANVAS_W/CANVAS_H;
	nightskyImg.repeat.x = 1.3*aspect;
	nightskyImg.repeat.y = 1.3;
}


var rainfallMesh;
var behindMesh;
var cloudsMesh;
var skyboxMesh;
var nightskyMesh;

var waterDownBack;
var waterDownFront
var waterdropsMesh;

var mapMesh;
var mapMeshFlipped;

let sprites = {};
let spriteData = {};
let animations = {};




var controls, camera, scene, renderer;

var guivisible = 0;

// constants:
var fadetime = 2.0; // fadetime in secs to red color when time is up.
var gameMaxTimeSecs = fadetime; // in secs. should be same as fadetime.
var countdownTimeMax = 8; // in secs time to show the endscores.



var crystalCount = 80;


var defaultBoostTime = 1000000; // for players.


var framesPerFps = 20;

var mapsize = 10000;
var terrainVerts = 128;

var MAP_W = 1000; // will be initialized later. 
var MAP_H = 1000; // map height should be 50-100% longer than the map image height.

var maptex_w;
var maptex_h;




let edgePadX = 1750*3; // padding areas after which player would teleport
let edgePadY = 3300;




var playerSize = 100*sizemulti;


var boostSpeed = 60*3;

var boostGivingTime = 200;
var boostGivingAmount = 20;
var maxBoostAmount = 200;

var bombGivingTime = 700;
var bombGivingAmount = 1;
var maxBombAmount = 300;

var holeLineDist = 200;





// state vars:
var countdownTimeStart = -1;

var myPlayer = 0;
let santaPlayer = 0;
let soldierPlayer = 0;

var gameStartTime = -1;

var gameEnding = false;
var gameEnded = false; // someone won now.
var prevEndingState = -1;




var players = [];

var lights = [];
var bombs = [];
var shots = [];
var explosions = [];
var splashes = [];
var bombers = [];
var turrets = []; // can be antiair or regular turret.
var visuals = []; // glow sprites etc... works same way as explosions basically.


var frameNumber = 0;
var prevFpsTime = 0;

var ambient;
var light1;
var terrain;


var cameraCube, sceneCube;
var textureCube;
var texturePlayerCube;
var textureSpaceCube;
var textureCrystalCube;






function getTimeMillis(){
	var d = new Date();
	return d.getTime();
}


function startCountdownTimer(){
	countdownTimeStart = getTimeMillis();
}

function displayEndingScores(){
	$('#players-ending-scores').removeClass("hidden");
	$('#players').addClass("hidden");
}

function hideEndingScores(){
	$('#players-ending-scores').addClass("hidden");
	$('#players').removeClass("hidden");
}


function getPlayerScale(playerIndex){
	var scale = 1+players[playerIndex].score/10.0;
	if(scale > 3){
		scale = 3;
	}
	return scale;
}



function get_dist_2d(p1x, p1y, p2x, p2y){
	return Math.sqrt((p2x-p1x)*(p2x-p1x)+(p2y-p1y)*(p2y-p1y));
}


function point_inside_circle(px, py, cx, cy, radius){
	return (get_dist_2d(px, py, cx, cy) < radius);
}


function point_inside_rect(x, y,  x1, y1, x2, y2){
	if(x < x1) return false;
	if(x > x2) return false;
	if(y < y1) return false;
	if(y > y2) return false;
	return true;
}


function get_kxy_angle(angle){
	this.x = Math.sin((angle-90.0)*(Math.PI/180.0));
	this.z = Math.cos((angle-90.0)*(Math.PI/180.0));
}


function get_rads(angle){
	return angle*(Math.PI/180.0);
}


function get_kxy(from_x, from_y, to_x, to_y){
	var angle = (Math.atan2(to_y-from_y, from_x-to_x)/Math.PI)*180.0;
	this.x = Math.sin((angle-90.0)*(Math.PI/180.0));
	this.z = Math.cos((angle-90.0)*(Math.PI/180.0));
}

function get_angle(from_x, from_y, to_x, to_y){
	return (Math.atan2(to_y-from_y, from_x-to_x)/Math.PI)*180.0;
}

function get_angle_kxy(from_x, from_y, to_x, to_y, angle){
	var angle = (Math.atan2(to_y-from_y, from_x-to_x)/Math.PI)*180.0;
	this.x = Math.sin((angle-90.0)*(Math.PI/180.0));
	this.z = Math.cos((angle-90.0)*(Math.PI/180.0));	
}




var colorList = [0xFF9595, 0xFF95BD, 0xFF95E0, 0xFF65FA, 0xCAC1FF, 0x79B8FF, 0x19C1FF, 0x01EAFF, 0x01FFCC, 0x8BD783, 0x5CD050, 0xF8FF3F, 0xFBFF99, 0xFDFFCF, 0xFFE9CF, 0xFFC581, 0xFFA281];

var colorListHtml = ["#FF9595", "#FF95BD", "#FF95E0", "#FF65FA", "#CAC1FF", "#79B8FF", "#19C1FF", "#01EAFF", "#01FFCC", "#8BD783", "#5CD050", "#F8FF3F", "#FBFF99", "#FDFFCF", "#FFE9CF", "#FFC581", "#FFA281"];

function randomColor(){
	var ran = Math.floor(Math.random()*colorList.length);
	this.color = colorList[ran];
	this.colorHtml = colorListHtml[ran];
}


var randomWords = ["soldier", "admiral", "general", "lieutenant"];


function randomNick(){
	return randomWords[Math.floor(Math.random()*randomWords.length)];
}



function set_loading_desc(text){
	$("#loading_desc").text(text);
	console.log("LOADER: "+text);
}

pre_init();
animate();




function sort_by_score(a, b){
	if (a.score < b.score) return 1;
	if (a.score > b.score) return -1;
	return 0;
}

function updateScoreTable(){
	var html = "";
	var scoretable = [];
	for(var i = 0; i < players.length; i++){
		var playerName = players[i].nick;
		var playerScore = players[i].score;
		var bgStyle = "";
		if(i == myPlayer){
			bgStyle = '; border:1px dashed rgba(255,255,255, 0.25); margin:-1px';
		}
		scoretable.push({
			'name': playerName,
			'score': playerScore,
			'style': 'color:'+players[i].color+bgStyle,
		});
	}

	scoretable.sort(sort_by_score);
	var html = '<table id="ending-score-table" cellspacing="0" cellpadding="0" border="0">';
	for(var i = 0; i < scoretable.length; i++){
		var num = i+1;
		html += '<tr style="'+scoretable[i].style+'"><td class="num">'+num+'.</td><td class="nam" style="'+scoretable[i].style+'">'+scoretable[i].name+'</td><td class="sco">'+scoretable[i].score+'</td></tr>';
	}
	html += '</table>';
	
	$('#scores').html(html);
	$('#ending-scores').html(html);
}


function updateBoostCount(){
	$('#boost-count').html(players[myPlayer].boostTime);
}
function updateInfo(){
	let curplayer = players[myPlayer];
	let xpos = Math.round(curplayer.mesh.position.x*10)/10;
	let ypos = Math.round(curplayer.mesh.position.y*10)/10;
	let zpos = Math.round(curplayer.mesh.position.z*10)/10;
	let angle = Math.round(curplayer.angle*10)/10;
	$('#player-x').html(xpos.toFixed(1));
	$('#player-y').html(ypos.toFixed(1));
	$('#player-z').html(zpos.toFixed(1));
	$('#player-angle').html(angle.toFixed(1));
}
function updateScoreCount(){
	$('#player-y').html(players[myPlayer].score);
}


// set_speed
function setSpeed(i, speed){
	if(speed < 0) speed = 0;
	if(speed > 150) speed = 150;
	
	players[i].internal_speed = speed;
	real_speed = Math.sqrt(speed*speed*5);
	players[i].speed = real_speed;
}

// set_angle
function setAngle(i, angle){
	players[i].angle = angle;
}

function setShootAngle(i, angle){
	players[i].shoot_angle = angle;
}


// addscore()
function addPlayerScore(playerIndex, score){
	var prevScore = players[playerIndex].score;
	players[playerIndex].score += score;
	
	
	if(players[playerIndex].score < 0){
		players[playerIndex].score = 0;
	}
	//var scale = getPlayerScale(playerIndex);
	//players[playerIndex].mesh.scale.set(scale,scale,scale);
	
	if(playerIndex == myPlayer){
		updateScoreCount();
	}
	
	updateScoreTable();
}








function getGameTimeLeft(){
	if(gameStartTime == -1){
		return gameMaxTimeSecs;
	}
	var retval = gameMaxTimeSecs-((getTimeMillis()-gameStartTime)/1000.0);
	if(retval < 0){
		retval = 0;
	}
	return retval;
}

function updateTimer(){
	if(!gameEnded){
		$('#timer').html("Gotta catch 'em all!");
	}else{
		var winnerName = players[gameWinnerIndex].nick;
		$('#timer').html(""+winnerName+" has won the game!");
		
		var countdowntime = countdownTimeMax-((getTimeMillis()-countdownTimeStart)/1000.0);
		if(countdowntime < 0){
			countdowntime = 0;
			restartGame();
		}
		$('#countdown').html("Next round starts in "+countdowntime.toFixed(1)+"s");
	}
}

function initTimer(){
	gameStartTime = getTimeMillis();
	prevFpsTime = getTimeMillis();
	updateTimer();
}

function init_gui(){

	set_loading_desc("Initializing GUI");
	
	updateScoreTable();
	updateTimer();
}


function resetVars(){
	countdownTimeStart = -1;

	gameStartTime = -1;
	
	gameEnding = false;
	gameEnded = false; // someone won now.
	prevEndingState = -1;

	
	

	init_gui();
}




function add_player(mesh, type){
	if(typeof type === "undefined"){
		type = TYPE_PLANE;
	}
	let owner = players.length;
	var weapons1 = [
		WEAPON_PLANEGUN,
		WEAPON_SHOTGUN,
		WEAPON_BOMB,
	];
	var weapons2 = [
		WEAPON_BOMB,
		WEAPON_PLANEGUN,
	];
	
	players.push({
		'nick': randomNick(),
		'color': "#FFFFFF",
		'mesh': mesh, // includes our position also.
		'angle': 0,
		'shoot_angle': 0,
		'speed': 0,
		'speed_x': 0, // used for helicopters etc.
		'speed_z': 0,
		'internal_speed': 0,
		'score': 0,
		'boostTime': defaultBoostTime, // each frame takes 10 amount of boost. 1 is gained each frame.
		'boost': false, // if true, then boost is enabled.
		
		'kx': 0, // unused
		'kz': 0, // unused
		
		'x': mesh.position.x, // todo: stop using mesh position as player position.
		'z': mesh.position.z,
		'lane': 0, // -1, 0, 1 possible.
		'ammo': 1000000,
		'bombs': 1000000,
		'fuel': 1000000,
		'type': type, // 0 = TYPE_PLANE, 1 = TYPE_SOLDIER, 2 = TYPE_BOAT, 2 = TYPE_SANTA
		'underwater': false,
		'hit_time': -1,
		'health': 1000,
		'alive': true,
		'owner': owner,
		// primary weapons:
		'weapons1': weapons1, // list of weapons used by click (machinegun etc).
		'current1': 0, // current selected weapon from that list.
		// secondary weapons:
		'weapons2': weapons2, // list of weapons used by space (bombs etc).
		'current2': 0,
	});
	return players.length-1;
}









var SOUNDS = {
	// sounds last element is sound volume.

	//plane_flip:       [1,1,0,0.234,0.343,0.504,0.296,0,-0.241009,0,0.267,0.07778,0,0,0.365,0,0.718354,0,0,1,0,0,0,0,0.332],
	plane_flip: [1,3,0.164,0.243,0,0.383,0.358,0,0.249,-0.035681,0.049863,0.004714,-0.081,-0.007549,1,-0.05378,1,-0.377,-0.07,1.040697,-0.011889,0.015896,0.116385,0.030281,0.176],
	explosion_plane:  [1,3,0,0.354736,0.590014,0.775,0.074,0,0,0,0,0,0.295512,0.676919,0,0,0,0.176156,-0.054911,1,0,0,0,0,0.1068],
	explosion_bomb:   [1,3,0,0.287594,0.51717,0.855,0.117312,0,0,0,0.652,0.66,0,0,0,0,0,-0.146964,-0.004699,    1,0,0,0,0,0.25],
	//exp_2:          [1,3,0,0.287594,0.51717,0.855,0.117312,0,0,0,0.652,0.66,0,0,0,0,0,-0.146964,-0.004699,0.214,0,0,0,0,0.25],
					  
	explosion_bullet: [1,3,0,0.209,0.389,0.58,0.117312,0,0,0,0.652,0.66,0,0,0,0,0,-0.146964,-0.004699,0.717,-0.057,0,0,0,0.15],
	shotgun_bullet:   [1,3,0,0.017927,0,0.445,0.482781,0,-0.312528,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0.033],
	plane_machinegun: [1,3,0,0.373,0.413,0.521,0.078499,0,0.069127,0,0,0,0,0,0,0,0,-0.202749,-0.23743,0.883,-0.237,0,0,0,0.18],
	antiair_gun:      [1,3,0,0.294,0.355,0.494,0.053,0,0.192,0,0,0,0,0,0,0,0,-0.202749,-0.23743,0.883,-0.237,0,0,0,0.13],
	//superspeed:       [1,3,0,0.37668,0.751589,0.93,0.078499,0,0.069127,0,0,0,0,0,0,0,0,-0.202749,-0.23743,1,0,0,0,0,0.1068],
	bomb_drop:        [1,1,0,0.291667,0,1,0.898,0,-0.094,-0.066,0,0,0,0,0.26295,0,0,0,0,1,0,0,0,0,0.031068],
	bomb_splash:      [1,3,0,0.210467,0,0.554,0.279,0,0.167627,0,0,0,0,0,0.187778,0,0,0,0,1,0,0,0,0,0.107],
	plane_splash:     [1,3,0,0.538,0.365,0.68,0.194,0,0.167627,0,0,0,0,0,0.187778,0,0,0,0,1,0,0,0,0,0.113],
	bullet_splash:    [1,3,0,0.12,0,0.437,0.279,0,0.167627,0,0,0,0,0,0.187778,0,0,0,0,1,0,0,0,0,0.107],
	shotgun_splash:   [1,3,0,0.12,0,0.437,0.279,0,0.167627,0,0,0,0,0,0.187778,0,0,0,0,1,0,0,0,0,0.025],
	/*
	epic_shot: [1,3,0,0.287594,0.242,0.971,0.87,0,-0.567,-0.519,0.652,0.66,-0.46,0,0,0,0.545,0.509,-0.236,1,-0.46,0.653,0,0.214,0.25],
	weird: [1,0,0.010329,0.368026,0.267228,0.399649,0.167153,0,0.14828,0.107487,0.352807,-0.240237,-0.039997,-0.01731,0.78035,0.001718,-0.427861,-0.085225,0.305644,0.838106,-0.080457,0.031704,-0.174818,-0.016129,0.414],
	*/
	
	//////////
	// one-dimensional sounds only: no distance adjustments at all:
	// must start with underscore.
	_blip: [1,1,0,0.005078,0.532665,0.439482,0.614439,0,0,0,0,0,0.554557,0.53357,0,0,0,0,0,1,0,0,0,0,0.1068],
	//_morse_beep_long: [1,1,0,0.431,0,0.177,0.529172,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0.1,0,0.1068],
	//_morse_beep_long_failure: [1,1,-0.058058,0.431,-0.030879,0.196496,0.529172,0,-0.056779,-0.035681,0.049863,0.004714,0.005416,-0.007549,1,-0.05378,0.012392,-0.0199,-0.028047,1.040697,-0.011889,0.015896,0.116385,0.030281,0.1068],
	//_morse_beep_short: [1,1,0,0.286,0,0.177,0.529172,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0.1,0,0.1068],
};



function myPlayerPos(){
	return players[myPlayer].mesh.position;
}






var CACHED_SOUND_EFFECTS = {};

// max_sounds
var MAX_SOUND_ALTS = 13;

function generate_sounds(){
	let i = 1;
	for(var soundName in SOUNDS) {
		if(SOUNDS.hasOwnProperty(soundName)){
			set_loading_desc("Generating sound "+i);
			i++;
			generate_sound_caches(soundName);
		}
	}
}


function generate_sound_caches(soundName){
	let newPARAMS = SOUNDS[soundName];
	
	if(newPARAMS[0] != 1){
		console.log("unknown sound version '"+newPARAMS[0]+"'");
		console.log(newPARAMS);
		return;
	}
	
	let order = ['jsfxr_version', 'wave_type', 'p_env_attack','p_env_sustain','p_env_punch','p_env_decay','p_base_freq','p_freq_limit','p_freq_ramp','p_freq_dramp','p_vib_strength','p_vib_speed','p_arp_mod','p_arp_speed','p_duty','p_duty_ramp','p_repeat_speed','p_pha_offset','p_pha_ramp','p_lpf_freq','p_lpf_ramp','p_lpf_resonance','p_hpf_freq','p_hpf_ramp','sound_vol'];
	
	let output = {};
	output['oldParams'] = true;
	output['sample_rate'] = 44100;
	output['sample_size'] = 8;

	for(let i = 1; i < order.length; i++){
		output[order[i]] = newPARAMS[i];
	}
	
	PARAMS.fromJSON(output);

	if(typeof CACHED_SOUND_EFFECTS[soundName] === "undefined"){
		CACHED_SOUND_EFFECTS[soundName] = {};
	}
	
	let max_sounds_gen = MAX_SOUND_ALTS;
	
	let distant_sounds = (soundName[0] !== '_') ? true : false; // non-distant sounds have underscore at start of name.
	if(!distant_sounds){
		max_sounds_gen = 1;
	}
	
	let step = 1.3;
	let min_val = 0.08;
		
	for(let i = 0; i < max_sounds_gen; i++){
		SOUND = new SoundEffect(PARAMS).generate();
		if(typeof CACHED_SOUND_EFFECTS[soundName]['sound'] === "undefined"){
			CACHED_SOUND_EFFECTS[soundName]['sound'] = [];
		}
		CACHED_SOUND_EFFECTS[soundName]['sound'].push(SOUND);
		CACHED_SOUND_EFFECTS[soundName]['params'] = PARAMS;
	
		PARAMS['p_lpf_freq'] /= step; // aka "cutoff frequency"
		if(PARAMS['p_lpf_freq'] <= min_val) PARAMS['p_lpf_freq'] = min_val;
	}
}


function play_sound(soundName, sound_x, sound_z){
	if(typeof CACHED_SOUND_EFFECTS[soundName] === "undefined"){
		return;
	}
	
	let play_sound = true;
	let dist_sound = 0;
	let is_distant_sound = (soundName[0] !== '_') ? true : false; // starting with underscore = single sound.
	
	if(is_distant_sound){
		let px = players[myPlayer].mesh.position.x;
		let pz = players[myPlayer].mesh.position.z;
		let dist = get_dist_2d(px, pz, sound_x, sound_z);
		
		let max_audible_dist = 3000;

		if(dist > 3000){
			play_sound = false;
		}else{
			if(dist > max_audible_dist){
				dist = max_audible_dist;
			}
			dist_sound = Math.round((dist/max_audible_dist)*(MAX_SOUND_ALTS-1));
			let total_sounds = CACHED_SOUND_EFFECTS[soundName]['sound'].length;
			if(dist_sound < 0) dist_sound = 0;
			if(dist_sound > total_sounds-1) dist_sound = total_sounds-1;
		}
	}
	if(play_sound){
		//console.log("dist_sound = "+dist_sound);
		SOUND = CACHED_SOUND_EFFECTS[soundName]['sound'][dist_sound];
		SOUND.getAudio().play();
	}
}



// generate_collision_data generate collision data
function generate_hit_data(tex){
	let data_w = tex.image.width;
	let data_h = tex.image.height;
	
	let outData = new Uint8Array(data_w*data_h);
	
	const tempCanvas = document.createElement('canvas');
	tempCanvas.width = data_w;
	tempCanvas.height = data_h;

	const tempCtx = tempCanvas.getContext('2d');
	tempCtx.drawImage(tex.image, 0, 0);

	const imageData = tempCtx.getImageData(0, 0, data_w, data_h);
	
	for(let y = 0; y < data_h; y++){
		for(let x = 0; x < data_w; x++){
			outData[y*data_w+x] = imageData.data[y*data_w*4+x*4+3]; // +3 = alpha channel.
		}
	}
	
	return outData;
}



function correct_texture_size(image){
	const canvas = document.createElement('canvas');
	const context = canvas.getContext('2d');

	let widthPow = 5;
	while(image.width > Math.pow(2, widthPow)){
		widthPow++;
	}
	let heightPow = 5;
	while(image.height > Math.pow(2, heightPow)){
		heightPow++;
	}

	canvas.width = Math.pow(2, widthPow);
	canvas.height = Math.pow(2, heightPow);
	context.drawImage(image, 0, 0);

	return canvas;
}


// if rect outside data area, then rect size and position changed accordingly.
// zero width means it is outside of data area.
function get_clamped_rect(data_w, data_h, x, y, w, h){
	if(x < 0){
		w = w+x;
		x = 0;
	}else if(x > data_w-1){
		w = 0;
		h = 0;
	}else if(x > data_w-w){
		w = data_w-x;
	}
	if(y < 0){
		h = h+y;
		y = 0;
	}else if(y > data_h-1){
		w = 0;
		h = 0;
	}else if(y > data_h-h){
		h = data_h-y;
		
	}
	return {'x':x, 'y':y, 'w':w, 'h':h};
}



function is_imagedata_empty(data, data_w, data_h){
	for(let y = 0; y < data_h; y++){
		for(let x = 0; x < data_w; x++){
			if(data[y*data_w*4+x*4+3] > 0){ // if not fully transparent; then visible.
				return false;
			}
		}
	}
	return true;
}



function is_area_empty(data, data_w, data_h, xp, yp, w, h){
	let rect = get_clamped_rect(data_w, data_h, xp, yp, w, h);
	if(!rect.w){
		return true; // was outside data area = empty.
	}
	let x1 = rect.x;
	let y1 = rect.y;
	let x2 = x1+rect.w;
	let y2 = y1+rect.h;
	for(let y = y1; y < y2; y++){
		for(let x = x1; x < x2; x++){
			if(data[y*data_w*4+x*4+3] > 0){ // if not fully transparent; then visible.
				return false;
			}
		}
	}
	return true;
}





// should generate it from bottom to top or the pieces are weirdly cut at bottom since the piece size is
function generate_compressed_map(tex){
	let image_w = tex.image.width;
	let image_h = tex.image.height;
	
	 // used to avoid texture bleeding when using mipmaps.
	 // edge pixels are repeated this many times.
	let padding = 0;
	
	// image split into blocksize-padding size squares.
	// this should be a power of 2 since mipmaps work that way too.
	let blockSize = 64;
	

	//let outData = new Uint8Array(data_w*data_h);
	
	const tempCanvas = document.createElement('canvas');
	tempCanvas.width = image_w;
	tempCanvas.height = image_h;
	const tempCtx = tempCanvas.getContext('2d');
	tempCtx.drawImage(tex.image, 0, 0);
	
	let out = "";
	
	let totalBlocks = 0;
	
	let blocks_x = Math.ceil(image_w/blockSize);
	let blocks_y = Math.ceil(image_h/blockSize);
	let maxBlocks = blocks_x*blocks_y;
	

	for(let y = 0; y < image_h; y+=blockSize){
		for(let x = 0; x < image_w; x+=blockSize){
			let imageData = tempCtx.getImageData(x, y, blockSize, blockSize);
			let empty = is_imagedata_empty(imageData.data, blockSize, blockSize);
			if(!empty){
				totalBlocks++;
			}
			out += empty ? '-' : 'O';
		}
		out += "\n";
	}
	
	let sq = Math.sqrt(totalBlocks);
	let out_w = Math.ceil(sq)*blockSize;
	let out_h = Math.ceil(sq)*blockSize;
	let output_blocks = Math.ceil(sq)*Math.ceil(sq);
	let compression_ratio = output_blocks/maxBlocks;
	
	console.log(out);
	console.log("out_w = "+out_w);
	console.log("out_h = "+out_h);
	console.log("compression_ratio = "+(1/compression_ratio));
	


	/*
--------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------OOOOOOOOOOOOO----------------------------------------------------
---------------------------------------------------------------OOOOOOOOOOOOO----------------------------------------------------
-----------------------------------------------------------------OOOOOOOOOO-----------------------------------------------------
------------------------------------------------------------------OOOOOOO-------------------------------------------------------
------OOO----------------------------------------------------------OOOOO----------------------------------------------OOOO------
-----OOOO----------------------------------------------------------OOOO-----------------------------------------------OOOOO-----
-----OOOO----------------------------------------------------------OOOO-----------------------------------------------OOOOO-----
-----OOOO----------------------------------------------------------OOOO------------------------------------------------OOOO-----
-----OOOO----------------------------------------------------------OOOO-----------------------------------------------OOOOO-----
-----OOOO----------------------------------------------------------OOOO-----------------------------------------------OOOOO-----
----OOOOOO----------------------------OO--------------------------------------------------------OO--------------------OOOOOO----
----OOOOOOO--------------------------OOOOO-------------------------OOOO-----------------------OOOOOOO---------------OOOOOOOOOO--
--OOOOOOOOOOO----OOO-------------OOOOOOOOOOOO-------------------OOOOOOOOOO------------------OOOOOOOOOOO-----------OOOOOOOOOOOOOO
OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO
	*/
	/*
	const outputCanvas = document.createElement('canvas');
	outputCanvas.width = data_w;
	outputCanvas.height = data_h;
	const outputCtx = outputCanvas.getContext('2d');

	
	/*
	for(let y = 0; y < data_h; y++){
		for(let x = 0; x < data_w; x++){
			outData[y*data_w+x] = imageData.data[y*data_w*4+x*4];
		}
	}
	
	return outData;
	*/
}



// todo: find automatic places for random turrets.
function generate_placement_array(){
	let step = 64; // probably should be half the size of the object we want to place.
	let arr_w = Math.ceil(MAP_W/step);
	let arr_h = Math.ceil(MAP_H/step);
	for(let y = 0; y < MAP_H; y+=step){
		for(let x = 0; x < MAP_W; x+=step){
			// if opacity of pixel is large enough to be treated as ground:
			if(MAP_DATA[y*MAP_W+x] > 40){
				// ground found
			}else{
				// air found
				
			}
		}
	}
}





function load_units(units){
	for(let i = 0; i < units.length; i++){
		let unit = units[i];
		let type = -1;
		if(unit.type == "antiair"){
			type = TURRET_ANTIAIR;
		}else if(unit.type == "bomber"){
			type = TURRET_BOMBER;
		}
		if(type != -1){
			spawn_turret(unit.owner, unit.x, unit.y, type);
		}
	}
}





function pre_init(){

	set_loading_desc("Initializing");


	CANVAS_W = window.innerWidth;
	CANVAS_H = window.innerHeight;
	
	console.log("CANVAS SIZE = "+CANVAS_W+"x"+CANVAS_H);	
	
	// DATA FILES:
	
	$.getJSON(map_data_url, function(json){
		loaded.map_settings = true;
		
		console.log("MAP SETTINGS:");
		console.log(json);
		
		// combine map_defaults with map settings.json:
		mapinfo = Object.assign(map_defaults, json);
	}).fail(function(){
		console.log("ERROR: Could not read file: '"+map_data_url+"'! File may be missing or incorrectly formatted (JSON is strict format, commas cannot be in end of lines unless another item comes after. All keys must be surrounded by double quotes, and all strings must be surrounded by double quotes).");
	});
	
	
	// CAMERAS
	
	if(ortho){
		camera = new THREE.OrthographicCamera( -CANVAS_W/2, CANVAS_W/2, CANVAS_H/2, -CANVAS_H/2, 1, 1000000 );
	}else{
		camera = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 1, 100000);
	}
	
	camera.position.set(0, 300, 0);

	
	
	cameraCube = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 1, 100000);

	controls = new THREE.OrbitControls(camera);
	controls.minDistance = 500;
	controls.maxDistance = 25000;

	// SCENE

	scene = new THREE.Scene();
	sceneCube = new THREE.Scene();

	// Lights
	ambient = new THREE.AmbientLight(0xffffff);
	scene.add(ambient);
	


	
	
	
	// Textures
	//var r = urlprefix+"textures/landscape.png";
	var r = urlprefix+"textures/clouds/cloud-bg.jpg";
	var urls = [r, r, r, r, r, r];
	

	// reflective bumpy cloud mapping:
	textureCube = new THREE.CubeTextureLoader().load(urls);
	textureCube.format = THREE.RGBFormat;
	textureCube.mapping = THREE.CubeReflectionMapping;




	// load main map texture: (map_path map_plane) load_map
	set_loading_desc("Loading map");
	maptexImg = new THREE.TextureLoader().load(texture_path('map_url'), function ( tex ) {
		tex.image = correct_texture_size(tex.image);
		loaded.map = true;
		set_loading_desc("Map loaded");
		
		// tex and texture are the same in this example, but that might not always be the case
		maptex_w = tex.image.width;
		maptex_h = tex.image.height;
		
		MAP_W = maptex_w;
		MAP_H = maptex_h;

		// make texture pixelized (min and mag needed both!):
		//let filter = THREE.NearestFilter;
		let filter = globalFilter;
		maptexImg.minFilter = filter;
		maptexImg.magFilter = filter;
		
		set_loading_desc("Creating map data");
		
		MAP_DATA = new generate_hit_data(tex);
		generate_placement_array();
		
		generate_compressed_map(tex);
		
		
		
		set_loading_desc("Map data created");
		

		
		// create playable map plane:
		{
		
			console.log("maptexImg = "+maptex_w+"x"+maptex_h);
			let geometry = new THREE.PlaneGeometry(maptex_w, maptex_h);

			
			{
				let material = new THREE.MeshPhongMaterial({map: maptexImg, color: 0xFFFFFF});  
				material.transparent = true;
				material.side = THREE.DoubleSide;
				material.alphaTest = 0.5;
				mapMesh = new THREE.Mesh(geometry, material);
				let mscale = 1;
				mapMesh.rotation.x = -Math.PI/2;
				mapMesh.position.y = Z_MAP_COLLISION;
				mapMesh.position.z = 0;
				mapMesh.scale.set(mscale,mscale,mscale);
				scene.add(mapMesh);
			}
			{	
				let material = new THREE.MeshPhongMaterial({map: maptexImg, color: 0xBBBBBB});  
				material.transparent = true;
				material.opacity = 0.2;
				material.side = THREE.DoubleSide;		
				mapMeshFlipped = new THREE.Mesh(geometry, material);
				let mscale = 1;
				mapMeshFlipped.rotation.x = -Math.PI/2;
				mapMeshFlipped.position.y = Z_MAP_COLLISION;
				mapMeshFlipped.position.z = maptex_h;
				mapMeshFlipped.scale.set(mscale,-mscale,mscale);
				scene.add(mapMeshFlipped);
			}
		}
		
		
		
		// load map water layer (comes under the flipped map)
		mapTexWater = new THREE.TextureLoader().load(texture_path('map_water_url'), function ( tex ) {
			tex.image = correct_texture_size(tex.image);
			loaded.water = true;
			set_loading_desc("Water loaded");
			
			mapTexWater.minFilter = THREE.LinearFilter;
			mapTexWater.magFilter = THREE.LinearFilter;
			mapTexWater.repeat.x = 0.5*2;
			mapTexWater.repeat.y = 2*3.333;

			mapTexWater.wrapS = THREE.RepeatWrapping;
			mapTexWater.wrapT = THREE.RepeatWrapping;
			
			{
				let geometry = new THREE.PlaneGeometry(maptex_w*4, maptex_h*10);

				
				{
					let material = new THREE.MeshPhongMaterial({map: mapTexWater, color: 0xDDDDDD});  
					material.transparent = true;
					material.opacity = 0.4;
					material.side = THREE.DoubleSide;

					waterDownBack = new THREE.Mesh(geometry, material);
					waterDownBack.visible = true;
					let mscale = 1;
					waterDownBack.position.x = 0;
					waterDownBack.position.y = Z_MAP_WATER_BACK;
					waterDownBack.position.z = maptex_h*4+maptex_h*1.5;
					
					waterDownBack.rotation.x = -Math.PI/2;
					waterDownBack.scale.set(mscale,mscale,mscale); // outwards
					scene.add(waterDownBack);
				}
				{
					let material = new THREE.MeshPhongMaterial({map: mapTexWater, color: 0xDDDDDD});  
					material.transparent = true;
					material.opacity = 0.6;
					material.side = THREE.DoubleSide;
					
					waterDownFront = new THREE.Mesh(geometry, material);
					waterDownFront.visible = true;
					let mscale = 1;
					waterDownFront.position.x = 0;
					waterDownFront.position.y = Z_MAP_WATER_FRONT;
					waterDownFront.position.z = maptex_h*4+maptex_h*1.5;
					
					waterDownFront.rotation.x = -Math.PI/2;
					waterDownFront.scale.set(mscale,-mscale,mscale); // inwards
					scene.add(waterDownFront);
				}
			}
		});
		
		
		// load map water layer (comes under the flipped map)
		mapTexWaterDrops = new THREE.TextureLoader().load(texture_path('map_waterdrops_url'), function ( tex ) {
			tex.image = correct_texture_size(tex.image);
			loaded.waterdrops = true;
			set_loading_desc("Waterdrops loaded");
			
			mapTexWaterDrops.minFilter = THREE.LinearFilter;
			mapTexWaterDrops.magFilter = THREE.LinearFilter;
			mapTexWaterDrops.repeat.x = 4*2*0.66;
			mapTexWaterDrops.repeat.y = (4096/128)*5*0.66;

			mapTexWaterDrops.wrapS = THREE.RepeatWrapping;
			mapTexWaterDrops.wrapT = THREE.RepeatWrapping;
			
			{
				let geometry = new THREE.PlaneGeometry(maptex_w*4, maptex_h*10);

				
				{
					let material = new THREE.MeshPhongMaterial({map: mapTexWaterDrops, color: 0xDDDDDD});  
					material.transparent = true;
					material.opacity = SHOW_RAIN_BG ? raindropsMaxOpacity : 0;
					material.side = THREE.DoubleSide;
					//material.blending = THREE.AdditiveBlending;
				
					waterdropsMesh = new THREE.Mesh(geometry, material);
					waterdropsMesh.visible = SHOW_RAIN_BG;
					let mscale = 1;
					waterdropsMesh.position.x = 0;
					waterdropsMesh.position.y = Z_MAP_WATERDROPS;
					waterdropsMesh.position.z = maptex_h*4+maptex_h*1.5;
					
					waterdropsMesh.rotation.x = -Math.PI/2;
					waterdropsMesh.scale.set(mscale,mscale,mscale);
					scene.add(waterdropsMesh);
				}
			}
		});
		
		
		
		// load map sprites background layer:
		behindEmissiveTex = new THREE.TextureLoader().load(texture_path('map_behind_lights_url'), function ( tex ) {
			tex.image = correct_texture_size(tex.image);
			loaded.map_behind_lights = true;
			set_loading_desc("Map behind lights loaded");
			
			behindEmissiveTex.minFilter = globalFilter;
			behindEmissiveTex.magFilter = globalFilter;
		}, null, function(err){
			loaded.map_behind_lights = true;
			console.log("error loading texture: "+err.path.baseURI);
		});
		
		
		// load map sprites background layer:
		maptexImg3 = new THREE.TextureLoader().load(texture_path('map_behind_url'), function ( tex ) {
			tex.image = correct_texture_size(tex.image);
			loaded.map_behind = true;
			set_loading_desc("Map behind loaded");
			
			maptexImg3.minFilter = globalFilter;
			maptexImg3.magFilter = globalFilter;

			{
				let geometry = new THREE.PlaneGeometry(maptex_w, maptex_h);
				let material = new THREE.MeshPhongMaterial({map: maptexImg3, color: 0xFFFFFF});  
				material.transparent = true;
				material.opacity = 1;
				material.alphaTest = 0.5;
				material.side = THREE.DoubleSide;
				material.emissive.set(0xFFFFFF);
				material.emissiveMap = behindEmissiveTex;
				material.emissiveIntensity = 0;
					
				behindMesh = new THREE.Mesh(geometry, material);
				behindMesh.visible = SHOW_MAP_BG;
				let mscale = 1;
				behindMesh.position.x = 0;
				behindMesh.position.y = Z_MAP_BEHIND;
				behindMesh.position.z = 0;
				
				behindMesh.rotation.x = -Math.PI/2;
				behindMesh.scale.set(mscale,mscale,mscale);
				scene.add(behindMesh);
			}
		}, null, function(err){
			loaded.map_behind = true;
			console.log("error loading texture: "+err.path.baseURI);
		});
		
		
		
		maptexImg4 = new THREE.TextureLoader().load(texture_path('map_front_url'), function ( tex ) {
			tex.image = correct_texture_size(tex.image);
			loaded.map_front = true;
			set_loading_desc("Map front loaded");
			
			maptexImg4.minFilter = globalFilter;
			maptexImg4.magFilter = globalFilter;

			{
				let geometry = new THREE.PlaneGeometry(maptex_w, maptex_h);
				let material = new THREE.MeshPhongMaterial({map: maptexImg4, color: 0xFFFFFF});  
				material.transparent = true;
				material.opacity = 1;
				material.alphaTest = 0.5;
				material.side = THREE.DoubleSide;
					
				let mapobj2 = new THREE.Mesh(geometry, material);
				mapobj2.visible = SHOW_MAP_BG;
				let mscale = 1;
				mapobj2.position.x = 0;
				mapobj2.position.y = Z_MAP_FRONT;
				mapobj2.position.z = 0;
				
				mapobj2.rotation.x = -Math.PI/2;
				mapobj2.scale.set(mscale,mscale,mscale);
				scene.add(mapobj2);
			}
		}, null, function(err){
			loaded.map_front = true;
			console.log("error loading texture: "+err.path.baseURI);
		});

		
		
		// load second background layer (parallax):
		maptexImg2 = new THREE.TextureLoader().load(texture_path('map_bg_url'), function ( tex ) {
			tex.image = correct_texture_size(tex.image);
			loaded.map_bg = true;
			set_loading_desc("Map background loaded");
			
			maptexImg2.minFilter = THREE.LinearFilter; // makes rain more crispy looking (=better).
			maptexImg2.magFilter = THREE.LinearFilter;
			
			{
				let geometry = new THREE.PlaneGeometry(maptex_w, maptex_h);
				let material = new THREE.MeshPhongMaterial({map: maptexImg2, color: 0x666666});  
				material.transparent = true;
				material.opacity = 1;
				material.side = THREE.DoubleSide;
					
				let mapobj2 = new THREE.Mesh(geometry, material);
				mapobj2.visible = SHOW_MAP_BG;
				let mscale = 1;
				mapobj2.position.x = 0;
				mapobj2.position.y = Z_MAP_BG;
				mapobj2.position.z = 0;
			
				mapobj2.rotation.x = -Math.PI/2;
				mapobj2.scale.set(mscale,mscale,mscale);
				scene.add(mapobj2);
			}
		}, null, function(err){
			loaded.map_bg = true;
			console.log("error loading texture: "+err.path.baseURI);
		});
		
		
		
		// load "skybox" parallax:
		skyboxImg = new THREE.TextureLoader().load(texture_path('skybox_url'), function ( tex ) {
			tex.image = correct_texture_size(tex.image);
			loaded.skybox = true;
			set_loading_desc("Sky loaded");
			
			skyboxImg.minFilter = THREE.LinearFilter;
			skyboxImg.magFilter = THREE.LinearFilter;
			
			skyboxImg.repeat.x = 20.8;
			skyboxImg.repeat.y = 17.3316;
			
			skyboxImg.wrapS = THREE.RepeatWrapping;
			skyboxImg.wrapT = THREE.RepeatWrapping;

			{
			
				let geometry = new THREE.PlaneGeometry(maptex_w*4, maptex_h*20);
				let material = new THREE.MeshPhongMaterial({map: skyboxImg, color: skyboxColor});
				material.transparent = true;
				material.opacity = SHOW_NIGHTSKY_BG ? 0 : 1;
				material.side = THREE.DoubleSide;
					
				skyboxMesh = new THREE.Mesh(geometry, material);
				let mscale = 1;
				skyboxMesh.visible = !SHOW_NIGHTSKY_BG;
				skyboxMesh.position.x = 0;
				skyboxMesh.position.y = Z_SKYBOX;
				skyboxMesh.position.z = 0;

				skyboxMesh.rotation.x = -Math.PI/2;
				skyboxMesh.scale.set(mscale,mscale,mscale);
				scene.add(skyboxMesh);
			}
		});
		
		

		// load "skybox" parallax:
		nightskyImg = new THREE.TextureLoader().load(texture_path('nightsky_url'), function ( tex ) {
			tex.image = correct_texture_size(tex.image);
			loaded.nightsky = true;
			set_loading_desc("Nightsky loaded");
			
			nightskyImg.minFilter = THREE.LinearFilter;
			nightskyImg.magFilter = THREE.LinearFilter;
			
			rescale_skybox();
			
			nightskyImg.wrapS = THREE.RepeatWrapping;
			nightskyImg.wrapT = THREE.RepeatWrapping;
			/*

			{
				let geometry = new THREE.PlaneGeometry(maptex_w*4, maptex_h*20);
				let material = new THREE.MeshBasicMaterial({map: nightskyImg, color: skyboxColor});
				material.transparent = true;
				material.opacity = SHOW_NIGHTSKY_BG ? nightskyMaxOpacity : 0;
				material.side = THREE.DoubleSide;
					
				nightskyMesh = new THREE.Mesh(geometry, material);
				let mscale = 1;
				nightskyMesh.visible = SHOW_NIGHTSKY_BG;
				nightskyMesh.position.x = 0;
				nightskyMesh.position.y = Z_SKYBOX;
				nightskyMesh.position.z = 0;
			
				nightskyMesh.rotation.x = -Math.PI/2;
				nightskyMesh.scale.set(mscale,mscale,mscale);
				scene.add(nightskyMesh);
				
			}
			*/
		});
		
		
		scene.background = nightskyImg; // add skybox. this simple!
		
		
		
		// load clouds parallax:
		bgTexClouds = new THREE.TextureLoader().load(texture_path('clouds_bg_url'), function ( tex ) {
			tex.image = correct_texture_size(tex.image);
			loaded.clouds = true;
			set_loading_desc("Clouds loaded");
			
			// make texture pixelized (min and mag needed both!):
			bgTexClouds.minFilter = THREE.LinearFilter;
			bgTexClouds.magFilter = THREE.LinearFilter;
			bgTexClouds.repeat.x = 20*0.26*2;
			bgTexClouds.repeat.y = 5*0.26*6.666;
			
			bgTexClouds.wrapS = THREE.RepeatWrapping;
			bgTexClouds.wrapT = THREE.RepeatWrapping;

			{
				let geometry = new THREE.PlaneGeometry(maptex_w*4, maptex_h*20);
				let material = new THREE.MeshPhongMaterial({map: bgTexClouds, color: cloudsColor});
				material.transparent = true;
				material.opacity = 0.9;
				material.side = THREE.DoubleSide;
					
				cloudsMesh = new THREE.Mesh(geometry, material);
				let mscale = 1;
				cloudsMesh.position.x = 0;
				cloudsMesh.position.y = Z_CLOUDS;
				cloudsMesh.position.z = 0;
				
			
				cloudsMesh.rotation.x = -Math.PI/2;
				cloudsMesh.scale.set(mscale,mscale,mscale);
				scene.add(cloudsMesh);
				
				//console.log(cloudsMesh);
				
				//console.log(bgTexClouds);
				
			}
		});
		
		
		

		// load rain rainfall:
		bgTexImg2 = new THREE.TextureLoader().load(texture_path('bg2_url'), function ( tex ) {
			tex.image = correct_texture_size(tex.image);
			loaded.rain = true;
			set_loading_desc("Rain loaded");
			
			// make texture pixelized (min and mag needed both!):
			bgTexImg2.minFilter = THREE.NearestFilter; // makes rain more crispy looking (=better).
			bgTexImg2.magFilter = THREE.NearestFilter;
			bgTexImg2.repeat.x = 20*2*(5/10)*2;
			bgTexImg2.repeat.y = 20*2*(3/10)*6.666;
			
			bgTexImg2.wrapS = THREE.RepeatWrapping;
			bgTexImg2.wrapT = THREE.RepeatWrapping;
			
			// create playable map plane:
			{
			
				let geometry = new THREE.PlaneGeometry(maptex_w*4, maptex_h*20);
				let material = new THREE.MeshPhongMaterial({map: bgTexImg2, color: 0xFFFFFF});  
				material.transparent = true;
				material.opacity = SHOW_RAIN_BG ? rainMaxOpacity : 0;
				//material.blending = THREE.AdditiveBlending;
				material.side = THREE.DoubleSide;
					
				rainfallMesh = new THREE.Mesh(geometry, material);
				rainfallMesh.visible = SHOW_RAIN_BG; 
				let mscale = 1;
				rainfallMesh.position.x = 0;
				rainfallMesh.position.y = Z_RAIN;
				rainfallMesh.position.z = 0;
				
			
				rainfallMesh.rotation.x = -Math.PI/2;
				rainfallMesh.scale.set(mscale,mscale,mscale);
				scene.add(rainfallMesh);
				
				//console.log(rainfallMesh);
				
				//console.log(bgTexImg2);
				
			}
		});
		
		
	});
	
	
	
	
	
	/*
	
	marioSpriteTest = new THREE.TextureLoader().load(texture_path('mario_sprite_url'), function(tex){
		tex.image = correct_texture_size(tex.image);
		loaded.antiair = true;
		set_loading_desc("Antiair loaded");
		
		let frameW = 28;
		let frameH = 19;
		let frames_x = 2;
	
		initialize_sprite('antiair', frameW, frameH, tex.image.width, tex.image.height, frames_x);
		//console.log(SPRITES);

		marioSpriteTest.minFilter = THREE.NearestFilter;//globalFilter;
		marioSpriteTest.magFilter = THREE.NearestFilter;//globalFilter;
		marioSpriteTest.repeat.x = frameW/tex.image.width;
		marioSpriteTest.repeat.y = frameH/tex.image.height;
		marioSpriteTest.offset.x = 0;
		marioSpriteTest.offset.y = 0;
		marioSpriteTest.flipY = false;
		
		{
			let geometry = new THREE.PlaneGeometry(frameW,frameH);
			let material = new THREE.MeshPhongMaterial({map: marioSpriteTest, color: 0xFFFFFF});  			
			material.color.set(0xFFFFFF);
			material.transparent = true;
			material.side = THREE.DoubleSide;

			let mesh = new THREE.Mesh(geometry, material);
			let mscale = 1;
			mesh.position.x = 300;
			mesh.position.y = Z_SOLDIER;
			mesh.position.z = 330;

			mesh.rotation.x = -Math.PI/2;
			mesh.scale.set(mscale,mscale,mscale);
			
			var i = add_player(mesh, TYPE_SOLDIER);
			scene.add(players[i].mesh);
		}
		
	});
	*/
	
	// antiair_sprite antiairSprite
	turretSpriteTest = new THREE.TextureLoader().load(texture_path('turret_sprite_url'), function(tex){
		tex.image = correct_texture_size(tex.image);
		loaded.turret = true;
		set_loading_desc("Turret loaded");
		
		let frameW = 32*3;
		let frameH = 19*3;
		let frames_x = 2;
	
		initialize_sprite('turret', frameW, frameH, tex.image.width, tex.image.height, frames_x);
		//console.log(SPRITES);

		turretSpriteTest.minFilter = globalFilter;
		turretSpriteTest.magFilter = globalFilter;
		turretSpriteTest.repeat.x = frameW/tex.image.width;
		turretSpriteTest.repeat.y = frameH/tex.image.height;
		turretSpriteTest.offset.x = 0;
		turretSpriteTest.offset.y = 0;
		turretSpriteTest.flipY = false;

	});

	
	
	
	soldierSpriteTest = new THREE.TextureLoader().load(texture_path('soldier_sprite_url'), function(tex){
		tex.image = correct_texture_size(tex.image);
		loaded.soldier = true;
		set_loading_desc("Soldier loaded");
		
		let scale = 3;
		let frameW = 52*scale;
		let frameH = 43*scale;
		let frames_x = 6;
		
	
		initialize_sprite('soldier', frameW, frameH, tex.image.width, tex.image.height, frames_x);
		console.log(SPRITES);

		soldierSpriteTest.minFilter = globalFilter;
		soldierSpriteTest.magFilter = globalFilter;
		soldierSpriteTest.repeat.x = frameW/tex.image.width;
		soldierSpriteTest.repeat.y = frameH/tex.image.height;
		soldierSpriteTest.offset.x = 0;
		soldierSpriteTest.offset.y = 0;
		soldierSpriteTest.flipY = false;
		
		{
			let geometry = new THREE.PlaneGeometry(frameW/scale,frameH/scale);
			let material = new THREE.MeshPhongMaterial({map: soldierSpriteTest, color: 0xFFFFFF});  			
			material.color.set(0xFFFFFF);
			material.transparent = true;
			material.alphaTest = 0.5;
			material.side = THREE.DoubleSide;

			let mesh = new THREE.Mesh(geometry, material);
			let mscale = 1;
			mesh.position.x = -941;
			mesh.position.y = Z_SOLDIER;
			mesh.position.z = 450;

			mesh.rotation.x = -Math.PI/2;
			mesh.scale.set(mscale,mscale,mscale);
			
			var i = add_player(mesh, TYPE_SOLDIER);
			soldierPlayer = i;
			scene.add(players[i].mesh);
		}
		
	});
	
	

	bomberEmissiveTex = new THREE.TextureLoader().load(texture_path('bomber_lights_sprite_url'), function(tex){
		tex.image = correct_texture_size(tex.image);
		loaded.bomber_lights = true;
		set_loading_desc("Bomber lights loaded");
		
		let w = 1024;
		let h = 256;

		bomberEmissiveTex.minFilter = THREE.LinearFilter;//globalFilter;
		bomberEmissiveTex.magFilter = THREE.LinearFilter;//globalFilter;
		bomberEmissiveTex.repeat.x = w/tex.image.width;
		bomberEmissiveTex.repeat.y = h/tex.image.height;
		bomberEmissiveTex.offset.x = 0;
		bomberEmissiveTex.offset.y = 0;
		bomberEmissiveTex.flipY = false;
	});
	
	
	
	bomberSpriteTest = new THREE.TextureLoader().load(texture_path('bomber_sprite_url'), function(tex){
		tex.image = correct_texture_size(tex.image);
		loaded.bomber = true;
		set_loading_desc("Bomber loaded");
		
		let w = 1024;
		let h = 256;

		bomberSpriteTest.minFilter = THREE.LinearFilter;//globalFilter;
		bomberSpriteTest.magFilter = THREE.LinearFilter;//globalFilter;
		bomberSpriteTest.repeat.x = w/tex.image.width;
		bomberSpriteTest.repeat.y = h/tex.image.height;
		bomberSpriteTest.offset.x = 0;
		bomberSpriteTest.offset.y = 0;
		bomberSpriteTest.flipY = false;
		
		set_loading_desc("Creating hit data");
		
		COLLISION_DATA['bomber'] = new generate_hit_data(tex);
		
		set_loading_desc("Hit data created");
		
	});
	
	
	
	
	

	streamSpriteTest = new THREE.TextureLoader().load(texture_path('stream_sprite_url'), function(tex){
		tex.image = correct_texture_size(tex.image);
		loaded.stream = true;
		set_loading_desc("Stream loaded");
		
		let w = 256;
		let h = 32;

		streamSpriteTest.minFilter = THREE.LinearFilter;//globalFilter;
		streamSpriteTest.magFilter = THREE.LinearFilter;//globalFilter;
		streamSpriteTest.repeat.x = w/tex.image.width;
		streamSpriteTest.repeat.y = h/tex.image.height;
		streamSpriteTest.offset.x = 0;
		streamSpriteTest.offset.y = 0;
		streamSpriteTest.flipY = false;
	});
	
	

	shotSpriteTest = new THREE.TextureLoader().load(texture_path('shots_sprite_url'), function(tex){
		tex.image = correct_texture_size(tex.image);
		loaded.shots = true;
		set_loading_desc("Shots loaded");
		
		let w = 64;
		let h = 16;

		shotSpriteTest.minFilter = THREE.LinearFilter;
		shotSpriteTest.magFilter = THREE.LinearFilter;
		shotSpriteTest.repeat.x = w/tex.image.width;
		shotSpriteTest.repeat.y = h/tex.image.height;
		shotSpriteTest.offset.x = 0;
		shotSpriteTest.offset.y = 0;
		shotSpriteTest.flipY = false;
		
		shotlightsTex = new THREE.TextureLoader().load(texture_path('shots_lights_sprite_url'), function(tex){
			tex.image = correct_texture_size(tex.image);
			loaded.shots_lights = true;
			set_loading_desc("Shots loaded");
			
			let w = 64;
			let h = 16;

			shotlightsTex.minFilter = THREE.LinearFilter;
			shotlightsTex.magFilter = THREE.LinearFilter;
			shotlightsTex.repeat.x = w/tex.image.width;
			shotlightsTex.repeat.y = h/tex.image.height;
			shotlightsTex.offset.x = 0;
			shotlightsTex.offset.y = 0;
			shotlightsTex.flipY = false;
		});
	});
	
	
	
	
	bombSpriteTest = new THREE.TextureLoader().load(texture_path('bombs_sprite_url'), function(tex){
		tex.image = correct_texture_size(tex.image);
		loaded.bombs = true;
		set_loading_desc("Bombs loaded");
		
		let w = 25;
		let h = 17;

		bombSpriteTest.minFilter = globalFilter;
		bombSpriteTest.magFilter = globalFilter;
		bombSpriteTest.repeat.x = w/tex.image.width;
		bombSpriteTest.repeat.y = h/tex.image.height;
		bombSpriteTest.offset.x = 0;
		bombSpriteTest.offset.y = 0;
		bombSpriteTest.flipY = false;
	});
	
	
	
	
	splashSpriteTest = new THREE.TextureLoader().load(texture_path('splash_sprite_url'), function(tex){
		tex.image = correct_texture_size(tex.image);
		loaded.splashes = true;
		set_loading_desc("Splash loaded");
		
		let w = 128;
		let h = 128;

		splashSpriteTest.minFilter = globalFilter;
		splashSpriteTest.magFilter = globalFilter;
		splashSpriteTest.repeat.x = w/tex.image.width;
		splashSpriteTest.repeat.y = h/tex.image.height;
		splashSpriteTest.offset.x = 0;
		splashSpriteTest.offset.y = 0;
		splashSpriteTest.flipY = false;
	});
	




	glowspriteTex = new THREE.TextureLoader().load(texture_path('glowsprite_url'), function(tex){
		tex.image = correct_texture_size(tex.image);
		loaded.glowsprite = true;
		set_loading_desc("Glowsprite loaded");
		
		let w = 128;
		let h = 128;

		glowspriteTex.minFilter = globalFilter;
		glowspriteTex.magFilter = globalFilter;
		glowspriteTex.repeat.x = w/tex.image.width;
		glowspriteTex.repeat.y = h/tex.image.height;
		glowspriteTex.offset.x = 0;
		glowspriteTex.offset.y = 0;
		glowspriteTex.flipY = false;
	});
	
	
	
	explosionSpriteTest = new THREE.TextureLoader().load(texture_path('explosion_sprites_url'), function(tex){
		tex.image = correct_texture_size(tex.image);
		loaded.explosions = true;
		set_loading_desc("Explosions loaded");
		
		let w = 128;
		let h = 128;

		explosionSpriteTest.minFilter = globalFilter;
		explosionSpriteTest.magFilter = globalFilter;
		explosionSpriteTest.repeat.x = w/tex.image.width;
		explosionSpriteTest.repeat.y = h/tex.image.height;
		explosionSpriteTest.offset.x = 0;
		explosionSpriteTest.offset.y = 0;
		explosionSpriteTest.flipY = false;
	});
	
	
	
	
	santaSpriteTest = new THREE.TextureLoader().load(texture_path('santa_sprite_url'), function(tex){
		tex.image = correct_texture_size(tex.image);
		loaded.santa = true;
		set_loading_desc("Santa loaded");
		
		let w = 167;
		let h = 58;

		santaSpriteTest.minFilter = globalFilter;
		santaSpriteTest.magFilter = globalFilter;
		santaSpriteTest.repeat.x = w/tex.image.width;
		santaSpriteTest.repeat.y = h/tex.image.height;
		santaSpriteTest.offset.x = 0;
		santaSpriteTest.offset.y = 0;
		santaSpriteTest.flipY = false;
		
		
		santaEmissiveTex = new THREE.TextureLoader().load(texture_path('santa_lights_sprite_url'), function(tex){
			tex.image = correct_texture_size(tex.image);
			loaded.santa_lights = true;
			set_loading_desc("Santa lights loaded");
			
			let w = 167;
			let h = 58;

			santaEmissiveTex.minFilter = globalFilter;
			santaEmissiveTex.magFilter = globalFilter;
			santaEmissiveTex.repeat.x = w/tex.image.width;
			santaEmissiveTex.repeat.y = h/tex.image.height;
			santaEmissiveTex.offset.x = 0;
			santaEmissiveTex.offset.y = 0;
			santaEmissiveTex.flipY = false;
			


			
			let geometry = new THREE.PlaneGeometry(w, h);
			let material = new THREE.MeshPhongMaterial({map: santaSpriteTest, color: 0xFFFFFF});  			
			material.color.set(0xFFFFFF);
			material.transparent = true;
			material.alphaTest = 0.5;
			material.side = THREE.DoubleSide;
			material.emissive.set(0xFFFF88);
			material.emissiveMap = santaEmissiveTex;
			material.emissiveIntensity = 0.9;

			let mesh = new THREE.Mesh(geometry, material);
			let mscale = 1;

			mesh.position.x = 335;
			mesh.position.y = Z_PLANE;
			mesh.position.z = -380;

			mesh.rotation.x = -Math.PI/2;
			mesh.scale.set(mscale,mscale,mscale);
			
			var i = add_player(mesh, TYPE_SANTA);
			santaPlayer = i;
			scene.add(players[i].mesh);
		});
	});
	
	



	helicopterSpriteTest = new THREE.TextureLoader().load(texture_path('helicopter_test_url'), function(tex){
		tex.image = correct_texture_size(tex.image);
		loaded.helicopter = true;
		set_loading_desc("Helicopter loaded");
		
		let image_scale = 2;
		
		let sprite_w = 268; //tex.image.width;
		let sprite_h = 98; // tex.image.height;
		
		let object_w = sprite_w/image_scale;
		let object_h = sprite_h/image_scale;
				
		helicopterSpriteTest.minFilter = globalFilter;
		helicopterSpriteTest.magFilter = globalFilter;
		helicopterSpriteTest.repeat.x = sprite_w/tex.image.width;
		helicopterSpriteTest.repeat.y = sprite_h/tex.image.height;
		helicopterSpriteTest.offset.x = 0;
		helicopterSpriteTest.offset.y = 0;
		helicopterSpriteTest.flipY = false;
		
		
		

		helicopterEmissiveTex = new THREE.TextureLoader().load(texture_path('helicopter_lights_sprite_url'), function(tex){
			tex.image = correct_texture_size(tex.image);
			loaded.helicopter_lights = true;
			set_loading_desc("Helicopter lights loaded");

			let image_scale = 2;
			
			let sprite_w = 268; //tex.image.width;
			let sprite_h = 98; // tex.image.height;
			
			let object_w = sprite_w/image_scale;
			let object_h = sprite_h/image_scale;

			helicopterEmissiveTex.minFilter = globalFilter;
			helicopterEmissiveTex.magFilter = globalFilter;
			helicopterEmissiveTex.repeat.x = sprite_w/tex.image.width;
			helicopterEmissiveTex.repeat.y = sprite_h/tex.image.height;
			helicopterEmissiveTex.offset.x = 0;
			helicopterEmissiveTex.offset.y = 0;
			helicopterEmissiveTex.flipY = false;


			let geometry = new THREE.PlaneGeometry(object_w, object_h);
			let material = new THREE.MeshPhongMaterial({map: helicopterSpriteTest, color: 0xFFFFFF});  			
			material.color.set(0xFFFFFF);
			material.transparent = true;
			material.alphaTest = 0.5;
			material.side = THREE.DoubleSide;
			material.emissive.set(0xFFFFFF);
			material.emissiveMap = helicopterEmissiveTex;
			material.emissiveIntensity = 0.6;

			let mesh = new THREE.Mesh(geometry, material);
			let mscale = 1;
			mesh.position.x = 94;
			mesh.position.y = Z_PLANE;
			mesh.position.z = -387;
			
			mesh.rotation.x = -Math.PI/2;
			mesh.scale.set(mscale,mscale,mscale);
			
		
			var i = add_player(mesh, TYPE_HELI);
			scene.add(players[i].mesh);
		});
	});
	
	

	
	
	playerSpriteTest = new THREE.TextureLoader().load(texture_path('plane_sprite_url'), function(tex){
		tex.image = correct_texture_size(tex.image);
		loaded.plane = true;
		set_loading_desc("Plane loaded");
		
		let image_scale = 2;
		
		let sprite_w = 98*2; //tex.image.width;
		let sprite_h = 54*2; // tex.image.height;
		
		let object_w = sprite_w/image_scale;
		let object_h = sprite_h/image_scale;
				
		playerSpriteTest.minFilter = globalFilter;
		playerSpriteTest.magFilter = globalFilter;
		playerSpriteTest.repeat.x = sprite_w/tex.image.width;
		playerSpriteTest.repeat.y = sprite_h/tex.image.height;
		playerSpriteTest.offset.x = 0;
		playerSpriteTest.offset.y = 0;
		playerSpriteTest.flipY = false;
		
		planeEmissiveTex = new THREE.TextureLoader().load(texture_path('plane_lights_sprite_url'), function(tex){
			tex.image = correct_texture_size(tex.image);
			loaded.plane_lights = true;
			set_loading_desc("Plane lights loaded");
			
			let image_scale = 2;
			
			let sprite_w = 98*2; //tex.image.width;
			let sprite_h = 54*2; // tex.image.height;
			
			let object_w = sprite_w/image_scale;
			let object_h = sprite_h/image_scale;
					
			planeEmissiveTex.minFilter = globalFilter;
			planeEmissiveTex.magFilter = globalFilter;
			planeEmissiveTex.repeat.x = sprite_w/tex.image.width;
			planeEmissiveTex.repeat.y = sprite_h/tex.image.height;
			planeEmissiveTex.offset.x = 0;
			planeEmissiveTex.offset.y = 0;
			planeEmissiveTex.flipY = false;
			
			


			let geometry = new THREE.PlaneGeometry(object_w, object_h);
			let material = new THREE.MeshPhongMaterial({map: playerSpriteTest, color: 0xFFFFFF});  			
			material.color.set(0xFFFFFF);
			material.transparent = true;
			material.alphaTest = 0.5;
			material.side = THREE.DoubleSide;
			material.emissive.set(0xFFFF55);
			material.emissiveMap = planeEmissiveTex;
			material.emissiveIntensity = 1;
			
			let mesh = new THREE.Mesh(geometry, material);
			let mscale = 1;
			mesh.position.x = 625;
			mesh.position.y = Z_PLANE;
			mesh.position.z = -589;
			
			mesh.rotation.x = -Math.PI/2;
			mesh.scale.set(mscale,mscale,mscale);
			
		
			var i = add_player(mesh, TYPE_PLANE);
			change_player(i);
			scene.add(players[i].mesh);
		});
	
	

	});

	
	

	// create map plane:
	{
		set_loading_desc("Generating reflection layer");
		
		var mapMaterial = new THREE.MeshLambertMaterial( { envMap: textureCube } );
		mapMaterial.color.set(0xffffff);
		mapMaterial.vertexColors = THREE.VertexColors;
		
		//mapMaterial.transparent = true;
		//mapMaterial.opacity = 0.5;
		//mapMaterial.side = THREE.DoubleSide;

		var geometry = new THREE.PlaneBufferGeometry( mapsize, mapsize, terrainVerts, terrainVerts );
		var count = geometry.attributes.position.count;
		geometry.addAttribute('color', new THREE.BufferAttribute(new Float32Array(count*3), 3));
		
		terrain = new THREE.Mesh(geometry, mapMaterial);
		terrain.visible = SHOW_WAVE_BG;
		terrain.rotation.x = -Math.PI / 2;
		

		var peak = 8;
		var smoothing = 600;
		var vertices = terrain.geometry.attributes.position.array;
		var perlin = new Perlin();
		for(var i = 0; i <= vertices.length; i += 3){
			vertices[i+2] = peak * perlin.noise(
				(terrain.position.x + vertices[i+0])/smoothing, 
				(terrain.position.z + vertices[i+1])/smoothing
			);
		}
		terrain.geometry.attributes.position.needsUpdate = true;
		terrain.geometry.computeVertexNormals();
		
		// flatten the terrain:
		vertices = terrain.geometry.attributes.position.array;
		var colors = terrain.geometry.attributes.color.array;
		for(var i = 0, c = 0; i <= vertices.length; i += 3, c+=3){
			vertices[i+2] = Z_SKYBOX+5;
		
			// default color to white:
			colors[c+0] = 1.16;//1.2+(Math.random())*0.5;//Math.random()*3;
			colors[c+1] = 1.16;//1.2+(Math.random())*0.5;//Math.random()*3;
			colors[c+2] = 1.10;//1.2+(Math.random())*0.5;
			
			// stretch edge + fade to black:
			if(vertices[i+0] <= -mapsize/2){
				vertices[i+0] = -mapsize;
				colors[c+0] = 0;
				colors[c+1] = 0;
				colors[c+2] = 0;
			}
			if(vertices[i+0] >= mapsize/2){
				vertices[i+0] = mapsize;
				colors[c+0] = 0;
				colors[c+1] = 0;
				colors[c+2] = 0;
			}
			if(vertices[i+1] <= -mapsize/2){
				vertices[i+1] = -mapsize;
				colors[c+0] = 0;
				colors[c+1] = 0;
				colors[c+2] = 0;
			}
			if(vertices[i+1] >= mapsize/2){
				vertices[i+1] = mapsize;
				colors[c+0] = 0;
				colors[c+1] = 0;
				colors[c+2] = 0;
			}
		}
		terrain.geometry.attributes.position.needsUpdate = true;
		//console.log("terrain.geometry.attributes");
		//console.log(terrain.geometry.attributes);
		//terrain.geometry.attributes.color.needsUpdate = true;
		
		
		scene.add(terrain);
		
		set_loading_desc("Reflection layer loaded");
	}
	

	
	renderer = new THREE.WebGLRenderer( { antialias: antialiasing });
	renderer.autoClear = false;
	renderer.setPixelRatio(window.devicePixelRatio);
	renderer.setSize(window.innerWidth, window.innerHeight);
	document.body.appendChild(renderer.domElement);
	
	MAX_TEX_SIZE = renderer.capabilities.maxTextureSize;
	
	console.log("maxTextureSize = "+MAX_TEX_SIZE);
		
		/*
		
	{
		var container = document.getElementById( 'container' );

		camera2 = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 5000 );
		camera2.position.set( 500, 350, 750 );

		scene2 = new THREE.Scene();

		renderer2 = new CSS3DRenderer();
		renderer2.setSize( window.innerWidth, window.innerHeight );
		container.appendChild( renderer2.domElement );
		
		// Block iframe events when dragging camera

		var blocker = document.getElementById('blocker');
		blocker.style.display = 'none';

		document.addEventListener('mousedown', function (){
			blocker.style.display = '';
		});
		document.addEventListener('mouseup', function (){
			blocker.style.display = 'none';
		});
	}
*/
	//var container = document.getElementById( 'container' );
	
	//renderer2 = new CSS3DRenderer();
	//renderer2.setSize( window.innerWidth, window.innerHeight );
	//container.appendChild( renderer2.domElement );

/*
	var group = new THREE.Group();
	group.add( new YoutubeEmbed( 'TlLijkYQjlw', 0, 0, 240, 0 ) );
	group.add( new YoutubeEmbed( 'RbtgTFGDkxA', 240, 0, 0, Math.PI / 2 ) );
	group.add( new YoutubeEmbed( 'fuyZFMRtXGs', 0, 0, - 240, Math.PI ) );
	group.add( new YoutubeEmbed( 'uqj9j-qz4AE', - 240, 0, 0, - Math.PI / 2 ) );
	scene.add( group );
*/
	//controls = new TrackballControls( camera, renderer.domElement );
	//controls.rotateSpeed = 4;


	

	window.addEventListener('resize', onWindowResize, false);

	
	
	set_loading_desc("Initialization done");
		
	init_gui();
}





function onWindowResize() {
	CANVAS_W = window.innerWidth;
	CANVAS_H = window.innerHeight;
	rescale_skybox();

	camera.aspect = window.innerWidth / window.innerHeight;

	camera.left = window.innerWidth * camera.aspect / -2;
    camera.right = window.innerWidth * camera.aspect / 2;
	
	camera.top = window.innerHeight * camera.aspect / 2;
    camera.bottom = window.innerHeight * camera.aspect / -2;
	
	camera.updateProjectionMatrix();
	
	renderer.setSize(window.innerWidth, window.innerHeight);
	
	console.log("window new size: "+window.innerWidth+"x"+window.innerHeight);

}




$(window).focus(function() {
    window_focus = true;
	play_sound("_blip");
}).blur(function() {
    window_focus = false;
	play_sound("_blip");
});




function animate() {
	let f = requestAnimationFrame(animate); // pauses when window not visible.
	render(f);
}



function restartGame(){
	console.log("restarting game...");
	hideEndingScores();
	resetVars();
	updateScoreTable();
}

function checkGameState(){
	if(getGameTimeLeft() <= 0){
		gameEnding = true;
	}
}

function switchGameState(newState){
	if(prevEndingState === newState){
		return; // do nothing if state doesnt change.
	}
	
	gameEnding = newState;
	
	var offsetY = 0;
	if(gameEnding){
		offsetY = 0;
	}else{
		offsetY = -100;
	}

	
	prevEndingState = newState;
	console.log("state changed to: "+newState);
	if(newState === true){
		gameStartTime = getTimeMillis();
		updateTimer();
	}else{
		gameStartTime = -1;
		updateTimer();
	}
}



function updateFPS(){
	if(prevFpsTime == 0){
		prevFpsTime = getTimeMillis();
		return;
	}
	let ms = getTimeMillis()-prevFpsTime;
	let fps = 1000/(ms/framesPerFps);
	$('#fps').html("FPS: "+fps.toFixed(1));
	prevFpsTime = getTimeMillis();
}





function post_init(){
	generate_sounds();
	
	spawn_bombers();
	
			
	if(mapinfo.hasOwnProperty("units")){
		load_units(mapinfo.units);
	}
}




function reset_globals(){
	gameLoadedVar = false;
	// todo, add all other globals, or better, make it into a class...
	
	for(let key in loaded){
		if(loaded.hasOwnProperty(key)){
			loaded[key] = false;
		}
	}
	
}




// map_loaded
function game_loaded(){

	if(gameLoadedVar) return true;
	
	for(let key in loaded){
		if(loaded.hasOwnProperty(key)){
			if(!loaded[key]){
				return false;
			}
		}
	}
	
	gameLoadedVar = true;
	
	set_loading_desc("Post-initialization");
		
	console.log("game loaded... post initializating...");
	post_init();

	
	return true;
}






function hits_turret(owner, x, z){
	let offset_x = 0;
	let offset_z = 0;
	let object_w = 40; // hitbox size
	let object_h = 40;
	let hw = object_w/2;
	let hh = object_h/2;
	
	for(var i = 0; i < turrets.length; i++){
		let turret = turrets[i];
		if(turret.alive && turret.owner != owner){
			if(point_inside_rect(x, z, 
				turret.mesh.position.x-hw+offset_x, 
				turret.mesh.position.z-hh+offset_z, 
				turret.mesh.position.x+hw+offset_x, 
				turret.mesh.position.z+hh+offset_z
			)){
				return i;
			}
		}
	}
	return -1;
}


function hits_player(owner, x, z){
	let offset_x = 0;
	let offset_z = 0;
	let object_w = 40; // hitbox size
	let object_h = 40;
	let hw = object_w/2;
	let hh = object_h/2;
	
	for(var i = 0; i < players.length; i++){
		let player = players[i];
		if(player.alive && player.owner != owner){
			if(point_inside_rect(x, z, 
				player.mesh.position.x-hw+offset_x, 
				player.mesh.position.z-hh+offset_z, 
				player.mesh.position.x+hw+offset_x, 
				player.mesh.position.z+hh+offset_z
			)){
				return i;
			}
		}
	}
	return -1;
}


function hits_bomber(owner, x, z){
	let offset_x = 20;
	let offset_z = 30;
	let bomber_w = 740; // hitbox size
	let bomber_h = 80;
	let hw = bomber_w/2;
	let hh = bomber_h/2;
	
	for(var i = 0; i < bombers.length; i++){
		let bomber = bombers[i];
		if(bomber.alive && bomber.owner != owner){
			if(point_inside_rect(x, z, 
				bomber.x-hw+offset_x, 
				bomber.z-hh+offset_z, 
				bomber.x+hw+offset_x, 
				bomber.z+hh+offset_z
			)){
				return i;
			}
		}
	}
	return -1;
}

function explode_bomber(bomberHit, explosion_type){
	if(typeof explosion_type === "undefined"){
		explosion_type = EXPLOSION_ROUND;
	}
	let bomber = bombers[bomberHit];
	if(bomber.explode_time == -1){
		bomber.health = 0;
		bomber.explode_time = getTimeMillis();
		
		bomber.alive = false;
		bomber.mesh.visible = false;
		
		play_sound("explosion_bomb", bomber.x, bomber.z);
		explode_at(bomber.x, bomber.z, explosion_type, EXPLOSION_HUGE3);
		
		if(total_bombers_alive() == 0){
			spawn_bombers();
		}
	}
}


function explode_turret(turretHit, explosion_type){
	if(typeof explosion_type === "undefined"){
		explosion_type = EXPLOSION_ROUND;
	}
	let turret = turrets[turretHit];
	//if(turret.explode_time == -1){
		turret.health = 0;
		//turret.explode_time = getTimeMillis();
		
		turret.alive = false;
		//turret.mesh.visible = false;
		
		play_sound("explosion_bomb", turret.x, turret.z);
		explode_at(turret.x, turret.z, explosion_type, EXPLOSION_LARGE);
	//}
}

function respawn_turret(turretIndex){
	let turret = turrets[turretIndex];
	turret.health = 400;
	turret.alive = true;
	
	let framename = turret_type_to_idleframe(turret.type);
	let pos = frame_offset('turret', framename, 0);
	turret.texture.offset.x = pos.x;
	turret.texture.offset.y = pos.y;
}


function hit_bomber(bomberHit, damage){
	let bomber = bombers[bomberHit];				
	bomber.hit_time = getTimeMillis();
	bomber.health -= damage;
	if(bomber.health <= 0){
		explode_bomber(bomberHit);
	}else if(bomber.health <= bomber.health_falling){
		bomber.falling = true;
	}else if(bomber.health <= bomber.health_smokestart){
		bomber.smokestart = true;
	}
}
	
function hit_player(i, damage){
	let player = players[i];
	player.hit_time = getTimeMillis();
	player.health -= damage;
	/*
	if(player.health <= 0){
		explode_bomber(i);
	}else if(player.health <= player.health_smokestart){
		player.smokestart = true;
	}
	*/
}


function hit_turret(turretHit, damage){
	let turret = turrets[turretHit];				
	turret.hit_time = getTimeMillis();
	turret.health -= damage;
	if(turret.health <= 0){
		// update frame to dead:
		let framename = turret_type_to_deadframe(turret.type);
		let pos = frame_offset('turret', framename, 0);
		turret.texture.offset.x = pos.x;
		turret.texture.offset.y = pos.y;
		
		explode_turret(turretHit);
	}else if(turret.health <= turret.health_smokestart){
		turret.smokestart = true;
	}
}


var loadingTextVisible = true;


var santaFrameNumber = 0;
var explosionFrameNumber = 0;
var soldierFrameNum = 0;

var prevShootTime = 0;
var shooting_started = false;
var can_shoot = false;

var shooting_imprecision = 0.5; // in degrees.
var frameTime = 0;


var rotatePlayer = 0;





function render(renderFrame){
	frameNumber++;
	frameTime = getTimeMillis();
	
	if((frameNumber % framesPerFps) == 0){
		updateFPS();
	}
	
	if(!game_loaded()){
		return;
	}else{
		if(loadingTextVisible){
			$("#loading_container").hide();
			loadingTextVisible = false;
		}
	}
	
	
	//checkGameState();



	if((frameNumber % 3) == 0){
		updateBoostCount();
		updateInfo();
		updateTimer();
	}
	
	

	/*
	// bright day:
	ambient.color.r = 1.2;
	ambient.color.g = 1.2;
	ambient.color.b = 1.4;
	
	// night:
	ambient.color.r = 0.2;
	ambient.color.g = 0.2;
	ambient.color.b = 0.2;
	*/
	

	if(shooting_started){
		
		if(getTimeMillis()-prevShootStartTime > continuous_shoot_delay){
			can_shoot = true;
		}
		
		if(can_shoot){
			if(getTimeMillis()-prevShootTime > planegun_delay){
				shoot_from_myplayer();
				prevShootTime = getTimeMillis();
			}
		}
	}
	
	let curplayer = players[myPlayer];
		

	
	if(curplayer.type == TYPE_HELI){
		let helispeed_x = 0.2;
		let helispeed_z = 0.1;
		let helimaxspeed_x = 13;
		let helimaxspeed_z = 15;
		if(key_down(65)){ // 'A'
			curplayer.speed_x -= helispeed_x;
		}
		if(key_down(68)){ // 'D'
			curplayer.speed_x += helispeed_x;
		}
		if(key_down(87)){ // 'W'
			curplayer.speed_z -= helispeed_z;
		}
		if(key_down(83)){ // 'S'
			curplayer.speed_z += helispeed_z;
		}
		
		if(curplayer.speed_x > helimaxspeed_x){
			curplayer.speed_x = helimaxspeed_x;
		}else if(curplayer.speed_x < -helimaxspeed_x){
			curplayer.speed_x = -helimaxspeed_x;
		}
		if(curplayer.speed_z > helimaxspeed_z){
			curplayer.speed_z = helimaxspeed_z;
		}else if(curplayer.speed_z < -helimaxspeed_z){
			curplayer.speed_z = -helimaxspeed_z;
		}
		curplayer.angle = get_angle(0, 0, curplayer.speed_x, curplayer.speed_z);
		curplayer.speed = get_dist_2d(0,0, curplayer.speed_x, curplayer.speed_z)*10;
	}else{
		if(curplayer.type == TYPE_SOLDIER){
		
			
			if(key_down(65)){ // 'A'
				curplayer.angle += 4;
				setAngle(myPlayer, curplayer.angle);
			}
			if(key_down(68)){ // 'D'
				curplayer.angle -= 4;
				setAngle(myPlayer, curplayer.angle);
			}
			if(key_down(87)){ // 'W'
				curplayer.internal_speed += 0.5;
				if(curplayer.type == TYPE_SOLDIER){
					if(curplayer.internal_speed > 20){
						curplayer.internal_speed = 20;
					}
				}
				setSpeed(myPlayer, curplayer.internal_speed);
			}
			if(key_down(83)){ // 'S'
				curplayer.internal_speed -= 1.5;
				setSpeed(myPlayer, curplayer.internal_speed);
			}
		}else{
			if(key_down(65)){ // 'A'
				curplayer.angle += 2;
				setAngle(myPlayer, curplayer.angle);
			}
			if(key_down(68)){ // 'D'
				curplayer.angle -= 2;
				setAngle(myPlayer, curplayer.angle);
			}
			if(key_down(87)){ // 'W'
				curplayer.internal_speed += 0.5;
				setSpeed(myPlayer, curplayer.internal_speed);
			}
			if(key_down(83)){ // 'S'
				curplayer.internal_speed -= 1.5;
				setSpeed(myPlayer, curplayer.internal_speed);
			}
		}
	}
	if(key_down(32)){ // 'space'
		
		
		let allow_bombing = false;
		if(!bombingStarted){
			bombingStarted = true;
			bombStartTime = getTimeMillis();
			allow_bombing = true;
		}
		if(getTimeMillis()-bombStartTime > continuous_shoot_delay){
			if(getTimeMillis()-prevBombTime > bombgun_delay){
				allow_bombing = true;
			}
		}
		if(allow_bombing){
			let x = players[myPlayer].mesh.position.x;
			let z = players[myPlayer].mesh.position.z;
			let dire = new get_kxy_angle(players[myPlayer].angle);
			let speed = 0.1*players[myPlayer].speed;
			drop_bomb(players[myPlayer].owner, x, z, dire, speed);
			prevBombTime = getTimeMillis();
		}
	}



	for(var i = 0; i < shots.length; i++){
		let shot = shots[i];
		
		if(shot.alive){
			shot.x += shot.kx;
			shot.z += shot.kz;
			
			shot.kx *= AIR_RESISTANCE;
			shot.kz += GRAVITY_CONSTANT;
			
			// teleport from edges:
			if(shot.x < -MAP_W/2-edgePadX){
				shot.x = MAP_W/2+edgePadX;
			}

			if(shot.x > MAP_W/2+edgePadX){
				shot.x = -MAP_W/2-edgePadX;
			}
			
			let hit_sound = "explosion_bullet";
			let splash_sound = "bullet_splash";
			let explode = true;
			let explosion_size = EXPLOSION_TINY;
			let glow = true;
			if(shot.type == WEAPON_SHOTGUN){
				hit_sound = "shotgun_bullet";
				splash_sound = "shotgun_splash";
				explode = true;
				explosion_size = EXPLOSION_SHOTGUN;
				glow = false;
			}
			
			let bomberHit = hits_bomber(shot.owner, shot.x, shot.z);
			let playerHit = hits_player(shot.owner, shot.x, shot.z);
			let turretHit = hits_turret(shot.owner, shot.x, shot.z);
			
			if(bomberHit != -1){
				
				play_sound(hit_sound, shot.x, shot.z);
				if(explode){
					explode_at(shot.mesh.position.x, shot.mesh.position.z, EXPLOSION_ROUND, explosion_size, glow);
				}

				hit_bomber(bomberHit, 20);
				
				shot.alive = false;
				scene.remove(shots[i].mesh);
			}else if(playerHit != -1){
				play_sound(hit_sound, shot.x, shot.z);
				if(explode){
					explode_at(shot.mesh.position.x, shot.mesh.position.z, EXPLOSION_ROUND, explosion_size, glow);
				}

				hit_player(playerHit, 20);
				
				shot.alive = false;
				scene.remove(shots[i].mesh);
			}else if(turretHit != -1){
				play_sound(hit_sound, shot.x, shot.z);
				if(explode){
					explode_at(shot.mesh.position.x, shot.mesh.position.z, EXPLOSION_ROUND, explosion_size, glow);
				}

				hit_turret(turretHit, 20);
				
				shot.alive = false;
				scene.remove(shots[i].mesh);
			}else{
			
				let ground_found = is_ground(shot.x, shot.z);
		
				if(ground_found || shot.mesh.position.z > MAP_H/2){

					shot.alive = false;
					scene.remove(shots[i].mesh);
					
					if(ground_found){
						play_sound(hit_sound, shot.x, shot.z);
						if(explode){
							explode_at(shot.mesh.position.x, shot.mesh.position.z, EXPLOSION_ROUND, explosion_size, glow);
						}
					}else{
						play_sound(splash_sound, shot.x, shot.z);
						splash_at(shot.mesh.position.x, shot.mesh.position.z, SPLASH_SMALL);
					}
				}
			}
			
			shot.mesh.position.x = shot.x;
			shot.mesh.position.z = shot.z;
			let angle = get_angle(0, 0, shot.kx, -shot.kz);
			
			shot.mesh.rotation.z = (angle+180)*(Math.PI/180.0);
		}
	} // shots
	
	
	
	
	
	for(var i = 0; i < bombs.length; i++){
		let bomb = bombs[i];
		
		if(bomb.alive){
			bomb.x += bomb.kx;
			bomb.z += bomb.kz;
			
			bomb.kx *= AIR_RESISTANCE;
			bomb.kz += GRAVITY_CONSTANT;
			
			// teleport from edges:
			if(bomb.x < -MAP_W/2-edgePadX){
				bomb.x = MAP_W/2+edgePadX;
			}

			if(bomb.x > MAP_W/2+edgePadX){
				bomb.x = -MAP_W/2-edgePadX;
			}
			
			let bomb_speed = get_dist_2d(0, 0, bomb.kx, bomb.kz);
			
			if(!bomb.whistling){
				if(bomb_speed > 7){
					//play_sound("bomb_drop", bomb.x, bomb.z);
					bomb.whistling = true;
				}
			}
			
			let bomberHit = -1;
			if(bomb.owner >= 0){ // only players can hit AI bombers. 
				bomberHit = hits_bomber(bomb.owner, bomb.x, bomb.z);
			}
			let playerHit = hits_player(bomb.owner, bomb.x, bomb.z);
			let turretHit = hits_turret(bomb.owner, bomb.x, bomb.z);
			
			if(bomberHit != -1){
				
				play_sound("explosion_bomb", bomb.x, bomb.z);
				explode_at(bomb.mesh.position.x, bomb.mesh.position.z, EXPLOSION_ROUND, EXPLOSION_LARGE);
				
				hit_bomber(bomberHit, 200);
				
				bomb.alive = false;
				scene.remove(bombs[i].mesh);
			}else if(playerHit != -1){
				play_sound("explosion_bomb", bomb.x, bomb.z);
				explode_at(bomb.mesh.position.x, bomb.mesh.position.z, EXPLOSION_ROUND, EXPLOSION_LARGE);

				hit_player(playerHit, 200);
				
				bomb.alive = false;
				scene.remove(bombs[i].mesh);
			}else if(turretHit != -1){
				play_sound("explosion_bomb", bomb.x, bomb.z);
				explode_at(bomb.mesh.position.x, bomb.mesh.position.z, EXPLOSION_ROUND, EXPLOSION_LARGE);

				hit_turret(turretHit, 200);
				
				bomb.alive = false;
				scene.remove(bombs[i].mesh);
			}else{
			
				let ground_found = is_ground(bomb.x, bomb.z);
						
				if(ground_found || bomb.mesh.position.z > MAP_H/2){
				
					
					bomb.alive = false;
					//bomb.mesh.visible = false;
					scene.remove(bombs[i].mesh);
					
					
					if(ground_found){
						play_sound("explosion_bomb", bomb.x, bomb.z);
						explode_at(bomb.mesh.position.x, bomb.mesh.position.z, EXPLOSION_FLAT, EXPLOSION_LARGE);
					}else{
						play_sound("bomb_splash", bomb.x, bomb.z);
						splash_at(bomb.mesh.position.x, bomb.mesh.position.z, SPLASH_MEDIUM);
					}
				}
			}
			
			
			bomb.mesh.position.x = bomb.x;
			bomb.mesh.position.z = bomb.z;
			let angle = get_angle(0, 0, bomb.kx, -bomb.kz);
			bomb.mesh.rotation.z = (angle+180)*(Math.PI/180.0);
		}
	} // bombs
	
	
	
	

	if(turrets_enabled){
		for(var i = 0; i < turrets.length; i++){
			let turret = turrets[i];
			
			if(turret.alive){
				let can_shoot = false;
				if(turret.type == TURRET_ANTIAIR){
					if(frameNumber % 10 == 0){
						can_shoot = true;
					}
				}else if(turret.type == TURRET_BOMBER){
					if(frameNumber % 90 == 0){
						can_shoot = true;
					}
				}
				if(can_shoot){
					shoot_turret(turret, OWNER_AI);
				}
			}
		} // turrets
	}
	

	for(var i = 0; i < bombers.length; i++){
		let bomber = bombers[i];
		
		if(bomber.alive){
			let angle = get_angle(0, 0, bomber.kx, -bomber.kz);
			
			let framesX = 1;
			
			let startX = 0;
			let startY = 0;
			
			let maxFrames = 2; // debug value.
			
			if(bomber.type == PLANE_BOMBER){
				startX = 0;
				startY = 0;
				maxFrames = 1;
			}else if(bomber.type == PLANE_HORNET){
				startX = 0;
				startY = 1;
				maxFrames = 1;
			}else if(bomber.type == PLANE_UFO){
				startX = 0;
				startY = 2;
				maxFrames = 1;
			}
			
			bomber.x += bomber.kx;
			bomber.z += bomber.kz;
			
			if(bomber.falling){
				//bomber.kx *= 0.995;
				bomber.kz += 0.02;
			}
			
			
			// teleport from edges:
			if(bomber.x < -MAP_W/2-edgePadX){
				bomber.x = MAP_W/2+edgePadX;
			}

			if(bomber.x > MAP_W/2+edgePadX){
				bomber.x = -MAP_W/2-edgePadX;
			}

		
			let ground_found = is_ground(bomber.x, bomber.z);
					
			if(ground_found || bomber.z > MAP_H/2){
			
				bomber.alive = false;
				bomber.mesh.visible = false;
				
				if(ground_found){
					play_sound("explosion_bomb", bomber.x, bomber.z);
					
					explode_bomber(i, EXPLOSION_FLAT);
				}else{
					play_sound("plane_splash", bomber.x, bomber.z);
					
					splash_at(bomber.x, bomber.z, SPLASH_HUGE2);
					explode_bomber(i, EXPLOSION_FLAT);
				}
			}
			

			if(bomber.bombing_start_time != -1){
				if(frameTime - bomber.bombing_start_time < 2000){
					if(frameTime - bomber.last_bomb_time > 250){
						let dire = new get_kxy_angle(angle);
						let speed = 0.1*bomber.kx;
						drop_bomb(bomber.owner, bomber.x, bomber.z+33, dire, speed, true);
						bomber.last_bomb_time = getTimeMillis();
					}
				}else{
					bomber.bombing_start_time = -1;
					bomber.last_bomb_time = -1;
				}
			}else{
				if(Math.random() < 0.002){
					bomber.bombing_start_time = getTimeMillis();
					bomber.last_bomb_time = -1;
				}
			}


			bomber.mesh.position.x = bomber.x;
			bomber.mesh.position.z = bomber.z;


			if(frameNumber % 3 == 0){
				bomber.frame++;
			}
			if(bomber.frame > maxFrames-1){
				bomber.frame = 0;
			}

			let frameY = startY+Math.floor(bomber.frame/framesX);
			let frameX = startX+bomber.frame % framesX;
		
			bomber.texture.offset.x = (frameX*1024)/1024;
			bomber.texture.offset.y = (frameY*256)/256;
			
			if(bomber.hit_time != -1){
				bomber.mesh.material.color.set(0xFF8888);
				if(frameTime - bomber.hit_time > 50){
					bomber.mesh.material.color.set(0xFFFFFF);
					bomber.hit_time = -1;
				}
			}
			
			
			bomber.mesh.rotation.z = (angle+180)*(Math.PI/180.0);
			
			let dire = new get_kxy_angle(angle);
			
			if(dire.x < 0){
				
				bomber.mesh.scale.y = -1;
			}else{
				
				bomber.mesh.scale.y = 1;
			}
			
		}
	} // bombers






	for(var i = 0; i < explosions.length; i++){
		let explosion = explosions[i];
		
		if(explosion.alive){
			let framesX = 8;
			let framesY = 8;
			let startX = 0;
			let startY = 0;
			let maxFrames = 2; // debug value.
			
			if(explosion.type == EXPLOSION_ROUND){
				startX = 0;
				startY = 0;
				maxFrames = 20;
			}else if(explosion.type == EXPLOSION_FLAT){
				startX = 0;
				startY = 3;
				maxFrames = 24;
			}



			if(frameNumber % 3 == 0){
				explosion.frame++;
			}
			if(explosion.frame > maxFrames-1){
				explosion.frame = 0;
				explosion.alive = false;
				explosion.mesh.visible = false;
				//scene.remove(explosions[i].mesh);
			}

			let frameY = startY+Math.floor(explosion.frame/framesX);
			let frameX = startX+explosion.frame % framesX;
		
			explosion.texture.offset.x = (frameX*128)/1024;
			explosion.texture.offset.y = (frameY*128)/1024;
			
			if(explosion.speed > 0){
				explosion.x += explosion.kx;
				explosion.z += explosion.kz;
				
				explosion.kx *= 0.95;
				
				explosion.mesh.position.x = explosion.x;
				explosion.mesh.position.z = explosion.z;
			}
		}
	} // explosions





	for(var i = 0; i < lights.length; i++){
		let light = lights[i];
		
		if(light.alive){
			let framesX = 8;
			let framesY = 8;
			let startX = 0;
			let startY = 0;
			let maxFrames = 2; // debug value.
			
			if(light.type == EXPLOSION_ROUND){
				startX = 0;
				startY = 0;
				maxFrames = 20;
			}else if(light.type == EXPLOSION_FLAT){
				startX = 0;
				startY = 3;
				maxFrames = 24;
			}
			
			if(frameNumber % 3 == 0){
				light.frame++;
			}
			
			//light.mesh.material.opacity = 1-(light.frame/(maxFrames-1));
			light.mesh.intensity = (1-(light.frame/(maxFrames-1)))*light.brightness;
			
			if(light.frame > maxFrames-1){
				light.frame = 0;
				light.alive = false;
				light.mesh.visible = false;
			}
		}
	} // lights



	for(var i = 0; i < visuals.length; i++){
		let visual = visuals[i];
		
		if(visual.alive){
			let framesX = 8;
			let framesY = 8;
			let startX = 0;
			let startY = 0;
			let maxFrames = 2; // debug value.
			
			if(visual.type == EXPLOSION_ROUND){
				startX = 0;
				startY = 0;
				maxFrames = 20;
			}else if(visual.type == EXPLOSION_FLAT){
				startX = 0;
				startY = 3;
				maxFrames = 24;
			}
			
			if(frameNumber % 3 == 0){
				visual.frame++;
			}
			
			visual.mesh.material.opacity = 1-(visual.frame/(maxFrames-1));
			
			if(visual.frame > maxFrames-1){
				visual.frame = 0;
				visual.alive = false;
				visual.mesh.visible = false;
				//scene.remove(explosions[i].mesh);
			}
		}
	} // visuals


	for(var i = 0; i < splashes.length; i++){
		let splash = splashes[i];
		
		if(splash.alive){
			if(frameNumber % 3 == 0){
				splash.frame++;
			}
			if(splash.frame >= 14-1){
				splash.frame = 0;
				splash.alive = false;
				splash.mesh.visible = false;
				//scene.remove(splashes[i].mesh);
			}
			let framesX = 4;
			let framesY = 4;

			let frameY = Math.floor(splash.frame/framesX);
			let frameX = splash.frame % framesX;
			splash.texture.offset.x = (frameX*128)/512;
			splash.texture.offset.y = (frameY*128)/512;
		}
	} // splashes





	for(var i = 0; i < players.length; i++){
		let player = players[i];
		
		if(!gameEnded){
		
			// handle lane changes:
			if(player.lane == 1){
				player.mesh.position.y = Z_MAP_COLLISION_FRONT;
			}else if(player.lane == -1){
				player.mesh.position.y = Z_MAP_BEHIND_FRONT;
			}else{
				// lane '0' (collision layer)
				if(player.type == TYPE_SOLDIER){
					player.mesh.position.y = Z_SOLDIER;
				}else{
					player.mesh.position.y = Z_PLANE;
				}
			}

			
			let dir = 1;

			
			if(player.type == TYPE_HELI){
				player.mesh.position.x += player.speed_x;
				player.mesh.position.z += player.speed_z;
				
				if(player.speed_x < 0){
					dir = -1;
				}
			}else{
				let dire = new get_kxy_angle(player.angle);
			
				player.mesh.position.x += dire.x*player.speed*sizemulti;
				player.mesh.position.z += dire.z*player.speed*sizemulti;
				
				if(dire.x < 0){
					dir = -1;
				}
			}

		
			
			// teleport from edges:
			if(player.mesh.position.x < -MAP_W/2-edgePadX){
				player.mesh.position.x = MAP_W/2+edgePadX;
			}
			if(player.mesh.position.z < -MAP_H-edgePadY){
				player.mesh.position.z = MAP_H/2+edgePadY/2;
			}
			if(player.mesh.position.x > MAP_W/2+edgePadX){
				player.mesh.position.x = -MAP_W/2-edgePadX;
			}
			if(player.mesh.position.z > MAP_H/2+edgePadY/2){
				player.mesh.position.z = -MAP_H-edgePadY;
			}
			
			let splash_size = SPLASH_LARGE;
			let splash_offset_z = 0;
			
			if(player.type == TYPE_SOLDIER){
				splash_size = SPLASH_SMALL;
				splash_offset_z = 6;
			}
			
			// test if gets under water:
			if(player.mesh.position.z > MAP_H/2){
				if(!player.underwater){
					play_sound("plane_splash", player.mesh.position.x, player.mesh.position.z);
					splash_at(player.mesh.position.x, player.mesh.position.z+splash_offset_z, splash_size);
					player.underwater = true;
					
					// dampen player speed:
					player.kx *= 0.3;
					player.kz *= 0.3;
					player.internal_speed *= 0.3;
					setSpeed(i, player.internal_speed);
					
				}
			}else{
				// test if gets out of water:
				if(player.underwater){
					play_sound("plane_splash", player.mesh.position.x, player.mesh.position.z);
					splash_at(player.mesh.position.x, player.mesh.position.z+splash_offset_z, splash_size);
					player.underwater = false;
					//player.kz *= 0.5;
				}
			}
			

			
			if(player.type == TYPE_PLANE){
				// no flipping in x axis.
			}else{
				if(player.type == TYPE_HELI){
					if(dir < 0){
						player.mesh.scale.x = 1;
					}else{
						player.mesh.scale.x = -1;
					}
				}else{
					if(dir < 0){
						player.mesh.scale.y = 1;
					}else{
						player.mesh.scale.y = -1;
					}
				}
			}
			
			
			if(player.type == TYPE_SOLDIER){
				let ground_found = is_ground(player.mesh.position.x, player.mesh.position.z+18);
			
				if(ground_found){
					player.kz = 0;
				}else{
					player.mesh.position.z += player.kz;
					
					if(player.underwater){
						if(player.mesh.position.z > MAP_H/2+10){
							player.kz -= BUOYANCY_CONSTANT*5;
							
						}
						player.kz *= WATER_RESISTANCE; // inertia caused by thick water.
						
					}else{
						player.kz += GRAVITY_CONSTANT;
					}
				}
			}
			
			if(player.type == TYPE_HELI){
				let max_tilt_speed = 25;
				let max_tilt_angle = 60;
				let tilt_speed = player.speed_x*2;
				if(tilt_speed > max_tilt_speed) tilt_speed = max_tilt_speed;
				if(tilt_speed < -max_tilt_speed) tilt_speed = -max_tilt_speed;
				let tilt_angle = (-tilt_speed/max_tilt_speed)*max_tilt_angle;
				player.mesh.rotation.z = get_rads(tilt_angle+180);
			}else{
				player.mesh.rotation.z = get_rads(player.angle+180);
			}

			//let light_on_time = 20;
			//let light_off_time = 50;
			if(player.mesh.material.emissiveMap){
			
				if(player.type == TYPE_PLANE){
					if(Math.round(frameNumber/30) % 3 == 0){
						player.mesh.material.emissive.set(0x000000);
					}else{
						player.mesh.material.emissive.set(0xFFFF55);
					}
				}
			}
			
			
			if(player.underwater){
				player.internal_speed *= 0.96;
				if(player.internal_speed <= 0.01){
					player.internal_speed = 0;
					// blow it up? 
				}
				setSpeed(i, player.internal_speed);
			}
		}
	} // players
	




	{


		
		bgTexImg2.offset.x+=0.002*rainspeed;
		bgTexImg2.offset.y+=0.01*rainspeed;
		
		
		// nightmode night_mode
		if(night_fade_dir){
		

			if(night_fade_dir == 1){ // disable night
			

			
				skyboxMesh.material.opacity += night_fade_speed;
				if(skyboxMesh.material.opacity >= 1){
					skyboxMesh.material.opacity = 1;
				}
				

				
				cloudsMesh.material.opacity += night_fade_speed;
				if(cloudsMesh.material.opacity >= 1){
					cloudsMesh.material.opacity = 1;
					//cloudsMesh.visible = false;
				}
				
				ambient_light += night_fade_speed;
				if(ambient_light > max_ambient_light){
					ambient_light = max_ambient_light;
				}
				
			}else if(night_fade_dir == 2){ // enable night (remove skyboxMesh)
				skyboxMesh.material.opacity -= night_fade_speed;
				if(skyboxMesh.material.opacity <= 0){
					skyboxMesh.material.opacity = 0;
					skyboxMesh.visible = false;

				}
				
				cloudsMesh.material.opacity -= night_fade_speed;
				if(cloudsMesh.material.opacity <= min_cloud_opa){
					cloudsMesh.material.opacity = min_cloud_opa;
					//cloudsMesh.visible = false;
				}
				
				ambient_light -= night_fade_speed;
				if(ambient_light < min_ambient_light){
					ambient_light = min_ambient_light;
				}
			}
			
			ambient.color.r = ambient_light;
			ambient.color.g = ambient_light;
			ambient.color.b = ambient_light;
		
			
			let waterFadePercent = 1-skyboxMesh.material.opacity; // 1 = day, 0 = night
			
			{
			
				// animate behind.png lightmap color:
				let opa = 1-skyboxMesh.material.opacity;
				let bounce_opacity = true;
				let color_opa = 1-skyboxMesh.material.opacity;
				if(bounce_opacity){
					//opa = (Math.sin(frameNumber/20)+1)/2;
					//opa *= opa;
					color_opa = (Math.sin(frameNumber/30)+1)/2;
				}
				behindMesh.material.emissiveIntensity = opa;//opa;
				
				
				let color = colorBetweenRGBA_array([0xFF0000, 0xFFFF00, 0x00FF00, 0x00FFFF, 0x0000FF, 0xFF00FF, 0xFF0000], color_opa);
				//let color = colorBetweenRGBA_array([0xFF5555, 0xFFFF55, 0x55FF55, 0x55FFFF, 0x5555FF, 0xFF55FF, 0xFF5555], color_opa);
				//if((frameNumber % 10) == 0){
//					console.log(color);
				//}
				behindMesh.material.emissive.set(color);
			
			}
			
			
			let refopaFrom = 0.2;
			let refopaTo = 0.5;
			
			mapMeshFlipped.material.opacity = waterFadePercent*(refopaTo-refopaFrom)+refopaFrom;
			
			let waterColorFrom = 0xDDDDDD;
			let waterColorTo = 0x666666;
			
			
			//waterDownBack.material.opacity = 0.4;
			waterDownBack.material.color.set(colorBetweenRGBA(waterColorFrom, waterColorTo, waterFadePercent));
			
			//waterDownFront.material.opacity = 0.6;
			waterDownFront.material.color.set(colorBetweenRGBA(waterColorFrom, waterColorTo, waterFadePercent));
			
		}
		

		if(fade_dir){
			if(fade_dir == 1){ // disable rain
				rainfallMesh.material.opacity -= rain_fade_speed;

				if(rainfallMesh.material.opacity <= 0){
					rainfallMesh.material.opacity = 0;
					rainfallMesh.visible = false;
					fade_dir = 0;
				}
			}else if(fade_dir == 2){ // enable rain
				rainfallMesh.material.opacity += rain_fade_speed;
				
				if(rainfallMesh.material.opacity >= rainMaxOpacity){
					rainfallMesh.material.opacity = rainMaxOpacity;
					fade_dir = 0;
				}
			}
			
			if(fade_dir == 1){ // disable rain
				waterdropsMesh.material.opacity -= rain_fade_speed;

				if(waterdropsMesh.material.opacity <= 0){
					waterdropsMesh.material.opacity = 0;
					waterdropsMesh.visible = false;
					//fade_dir = 0;
				}
			}else if(fade_dir == 2){ // enable rain
				waterdropsMesh.material.opacity += rain_fade_speed;
				
				if(waterdropsMesh.material.opacity >= raindropsMaxOpacity){
					waterdropsMesh.material.opacity = raindropsMaxOpacity;
					//fade_dir = 0;
				}
			}
			
			
		
			// interpolate cloud colors:
			let cloudFadePercent = rainfallMesh.material.opacity/rainMaxOpacity;
			
			cloudsMesh.material.color.set(
				colorBetweenRGBA(cloudColorFrom, cloudColorTo, cloudFadePercent)
			);
			
			skyboxMesh.material.color.set(
				colorBetweenRGBA(skyboxColorFrom, skyboxColorTo, cloudFadePercent)
			);
		}
	}
	
	
	
		
	{
	
		let px = players[myPlayer].mesh.position.x;
		let pz = players[myPlayer].mesh.position.z;
		
		let scrollFrameNum = frameNumber*0.5;

		let mul = 0.8;
		skyboxImg.offset.x = ((-px/(0.5*mul))/MAP_W)+scrollFrameNum/1000*.3;
		skyboxImg.offset.y = ((pz/(3*mul))/MAP_H);

		let aspect = CANVAS_W/CANVAS_H;
		nightskyImg.offset.x = ((px/10*aspect)/CANVAS_W);
		nightskyImg.offset.y = ((-pz/10)/CANVAS_H);

		if(flip_dir && (frameNumber % 2) == 0){
		
			// flip
			planeFrameNum++;
			if(planeFrameNum >= 15-1){
				planeFrameNum = 0;
				planeFrameNumX++;
				if(planeFrameNumX >= 2){
					planeFrameNumX = 0;
				}
		
				flip_dir = 0;
			}

			
			playerSpriteTest.offset.x = (planeFrameNumX*98)/256;//+(1/256);
			playerSpriteTest.offset.y = (planeFrameNum*54)/1024;
			
			planeEmissiveTex.offset.x = (planeFrameNumX*98)/256;//+(1/256);
			planeEmissiveTex.offset.y = (planeFrameNum*54)/1024;
			
			
		}



		maptexImg2.offset.x = ((px/10)/MAP_W);
		maptexImg2.offset.y = ((-pz/15)/MAP_H);
		
		bgTexClouds.offset.x = ((px/5)/MAP_W)+scrollFrameNum/1500;
		bgTexClouds.offset.y = ((-pz/20)/MAP_H);
		
		let waterSpeed = 0.1;
		mapTexWater.offset.x = scrollFrameNum/1600*waterSpeed*1.5;
		mapTexWater.offset.y = scrollFrameNum/250*waterSpeed;
		
		mapTexWaterDrops.offset.x = scrollFrameNum/15;




		{

			let speedAdd = players[santaPlayer].speed/150;
			santaFrameNumber += speedAdd;
			
			if(santaFrameNumber >= 22-1){
				santaFrameNumber = 0;
			}
			
			let intnum = Math.round(santaFrameNumber);
			
			
			let framesX = 3;
			let framesY = 8;
			
			//let w = 165;
			//let h = 56;

			let santaFrameY = Math.floor(intnum/3);
			let santaFrameX = intnum % 3;
			santaSpriteTest.offset.x = (santaFrameX*167)/512;//+(1/256);
			santaSpriteTest.offset.y = (santaFrameY*58)/512;
			
			santaEmissiveTex.offset.x = (santaFrameX*167)/512;//+(1/256);
			santaEmissiveTex.offset.y = (santaFrameY*58)/512;
		}
		
		
		
		{
			// TYPE_SOLDIER animation: soldier player animation:
			let thisplayer = players[soldierPlayer];
			
			let speedAdd = thisplayer.speed/150;
			soldierFrameNum += speedAdd;
			
			let animation_name = 'stand_idle';
			if(thisplayer.underwater){
				animation_name = 'basic_swim';
			}else{
				animation_name = 'running';
			}
			
			let anim_frames = SPRITES['soldier']['anims'][animation_name].length;
			
			if(soldierFrameNum >= anim_frames-1){
				soldierFrameNum = 0;
			}
			
			
			let pos = frame_offset('soldier', animation_name, Math.round(soldierFrameNum));
			soldierSpriteTest.offset.x = pos.x;
			soldierSpriteTest.offset.y = pos.y;
						
		}
		

		
		
	}





	let camstyle = 10;

	if(camstyle == 0){
		camera.lookAt( scene.position );
		cameraCube.rotation.copy( camera.rotation );
	}else{
		
		let cpx = players[myPlayer].mesh.position.x;
		let cpy = players[myPlayer].mesh.position.y;
		let cpz = players[myPlayer].mesh.position.z; // originally +23 to make the view skewed so it is not straight up view.
		
		let offset_x = 0;
		let offset_z = 0;
		if(MOUSE_X != -1){
			offset_x = (MOUSE_X-(CANVAS_W/2))*2;
			offset_z = (MOUSE_Y-(CANVAS_H/2))*2;
		}
		
		camera.position.x = cpx+offset_x; // for some reason adjusting these will fuck camera rotation...
		camera.position.y = cpy+2000; // how far camera is from ground; can see only things under it.
		camera.position.z = cpz+offset_z;
		
		//camera.lookAt( players[myPlayer].mesh.position );
		camera.lookAt(
			cpx + offset_x, 
			cpy, 
			cpz + offset_z
		);
		
	}
	
	renderer.render(scene, camera);
}



function find_free_light(){
	for(let i = 0; i < lights.length; i++){
		let light = lights[i];
		if(!light.alive){
			return i;
		}
	}
	return -1;
}



function find_free_visual(type){
	for(let i = 0; i < visuals.length; i++){
		let visual = visuals[i];
		if(!visual.alive && visual.type == type){
			return i;
		}
	}
	return -1;
}


function find_free_explosion(type){
	for(let i = 0; i < explosions.length; i++){
		let explosion = explosions[i];
		if(!explosion.alive && explosion.type == type){
			return i;
		}
	}
	return -1;
}




function find_free_splash(){
	for(let i = 0; i < splashes.length; i++){
		let splash = splashes[i];
		if(!splash.alive){
			return i;
		}
	}
	return -1;
}


function total_bombers_alive(){
	let total = 0;
	for(let i = 0; i < bombers.length; i++){
		if(bombers[i].alive){
			total++;
		}
	}
	return total;
}

function find_free_bomber(){
	for(let i = 0; i < bombers.length; i++){
		let bomber = bombers[i];
		if(!bomber.alive){
			return i;
		}
	}
	return -1;
}




function explode_at(x, z, type, size, glowing){

	if(typeof glowing === "undefined"){
		glowing = true;
	}

	// spawn glowing...
	if(glowing){
		glow_at(x, z, type, size);
		//light_at(x, z, type, size);
		
		//light_at(x, z, type, 500, 4);
	}

	let random_rotation = false;
	if(type == EXPLOSION_ROUND){
		// only round explosions can be rotated around their center point.
		random_rotation = true;
	}

	let mscale = 1; // default EXPLOSION_MEDIUM.
	if(size == EXPLOSION_SHOTGUN){
		mscale = 1/8;
	}else if(size == EXPLOSION_TINY){
		mscale = 1/4;
	}else if(size == EXPLOSION_SMALL){
		mscale = 1/2;
	}else if(size == EXPLOSION_MEDIUM){
		mscale = 1;
	}else if(size == EXPLOSION_LARGE){
		mscale = 1*2;
	}else if(size == EXPLOSION_HUGE){
		mscale = 1*3;
	}else if(size == EXPLOSION_HUGE2){
		mscale = 1*5;
	}else if(size == EXPLOSION_HUGE3){
		mscale = 1*6;
	}


	let w = 128;
	let h = 128;
	
	let foundIndex = find_free_explosion(type);
	
	let mesh;
	let texture;

	if(foundIndex == -1){
		texture = explosionSpriteTest.clone();
		texture.needsUpdate = true;

		let geometry = new THREE.PlaneGeometry(w, h);
		let material = new THREE.MeshBasicMaterial({map: texture, color: 0xFFFFFF});
		material.color.set(0xFFFFFF);
		material.transparent = true;
		material.opacity = 1;
		material.side = THREE.DoubleSide;
		//material.blending = THREE.AdditiveBlending;

		mesh = new THREE.Mesh(geometry, material);
	}else{
		mesh = explosions[foundIndex].mesh;
		mesh.visible = true;
	}
	
	
	
	mesh.rotation.x = Math.PI/2;
	if(random_rotation){
		mesh.rotation.z = Math.random()*Math.PI*2;
	}

	mesh.position.x = x;
	mesh.position.y = Z_MAP_EXPLOSIONS+Math.random()+(ZINSTEP/2);
	if(type == EXPLOSION_FLAT){
		mesh.position.z = z-Math.round(h*(mscale/2)*0.7); // centered to bottom of the image.
	}else{
		mesh.position.z = z; // default as fully centered to image.
	}
	
	mesh.scale.set(mscale,mscale,mscale);

	
	
	if(foundIndex == -1){
		let explosion = {
			'x': x,
			'z': z,
			'kx': 0,
			'kz': 0,
			'speed': 0,
			'frame': 0,
			'alive': true,
			'mesh': mesh,
			'type': type,
			'size': size,
			'scale': mscale,
			'texture': texture,
		};
		explosions.push(explosion);
		scene.add(explosions[explosions.length-1].mesh);
	}else{
		explosions[foundIndex].frame = 0;
		explosions[foundIndex].alive = true;
	}
}



function light_at(x, z, type, size, brightness){

	let foundIndex = find_free_light();
	let mesh;
	if(foundIndex == -1){
		mesh = new THREE.PointLight(0xffee88, brightness, size, 1);
	}else{
		mesh = lights[foundIndex].mesh;
		mesh.visible = true;
	}
	
	mesh.position.x = x;
	mesh.position.y = Z_MAP_VISUALS+150;
	mesh.position.z = z;
	

	if(foundIndex == -1){
		let light = {
			'frame': 0,
			'alive': true,
			'type': type,
			'brightness': brightness,
			'size': size,
			'time': 2000,
			'mesh': mesh,
		};
		lights.push(light);
		scene.add(lights[lights.length-1].mesh);
	}else{
		lights[foundIndex].frame = 0;
		lights[foundIndex].alive = true;
	}
}



function glow_at(x, z, type, size){

	let mscale = 1; // default EXPLOSION_MEDIUM.
	
	if(size == EXPLOSION_SHOTGUN){
		mscale = 1/8;
	}else if(size == EXPLOSION_TINY){
		mscale = 1/4;
	}else if(size == EXPLOSION_SMALL){
		mscale = 1/2;
	}else if(size == EXPLOSION_MEDIUM){
		mscale = 1;
	}else if(size == EXPLOSION_LARGE){
		mscale = 1*2;
	}else if(size == EXPLOSION_HUGE){
		mscale = 1*3;
	}else if(size == EXPLOSION_HUGE2){
		mscale = 1*5;
	}else if(size == EXPLOSION_HUGE3){
		mscale = 1*6;
	}
	mscale *= 2; // double the size relative to explosion size.


	let w = 128;
	let h = 128;

	let foundIndex = find_free_visual(type);

	let mesh;
	let texture;

	if(foundIndex == -1){
		texture = glowspriteTex.clone();
		texture.needsUpdate = true;

		let geometry = new THREE.PlaneGeometry(w, h);
		let material = new THREE.MeshBasicMaterial({map: texture, color: 0x444444});
		material.color.set(0x444444);
		material.transparent = true;
		//material.opacity = 0.1; // doesnt seem to affect at all with additive blending.
		material.side = THREE.DoubleSide;
		material.blending = THREE.AdditiveBlending;

		mesh = new THREE.Mesh(geometry, material);
	}else{
		mesh = visuals[foundIndex].mesh;
		mesh.visible = true;
	}
	
	mesh.rotation.x = Math.PI/2;
	mesh.rotation.z = Math.random()*Math.PI*2; // random rotation.

	mesh.position.x = x;
	mesh.position.y = Z_MAP_VISUALS+Math.random()*(ZINSTEP/2);
	mesh.position.z = z; // default as fully centered to image.
	
	mesh.scale.set(mscale,mscale,mscale);

	if(foundIndex == -1){
		let visual = {
			'x': x,
			'z': z,
			'kx': 0,
			'kz': 0,
			'speed': 0,
			'frame': 0,
			'alive': true,
			'mesh': mesh,
			'type': type,
			'size': size,
			'scale': mscale,
			'texture': texture,
		};
		visuals.push(visual);
		scene.add(visuals[visuals.length-1].mesh);
	}else{
		visuals[foundIndex].frame = 0;
		visuals[foundIndex].alive = true;
	}
}






function splash_at(x, z, size){
	let mscale = 1;
	
	if(size == SPLASH_TINY){
		mscale = 1/8;
	}else if(size == SPLASH_SMALL){
		mscale = 1/4;
	}else if(size == SPLASH_MEDIUM){
		mscale = 1/2;
	}else if(size == SPLASH_LARGE){
		mscale = 1;
	}else if(size == SPLASH_HUGE){
		mscale = 1*2;
	}else if(size == SPLASH_HUGE2){
		mscale = 1*5;
	}

	let w = 128;
	let h = 128;
	
	let foundIndex = find_free_splash();
	
	let mesh;
	let texture;

	if(foundIndex == -1){
		texture = splashSpriteTest.clone();
		texture.needsUpdate = true;

		let geometry = new THREE.PlaneGeometry(w, h);
		let material = new THREE.MeshPhongMaterial({map: texture, color: 0xFFFFFF});  			
		material.color.set(0xFFFFFF);
		material.transparent = true;
		material.opacity = 1;
		material.side = THREE.DoubleSide;
		//material.blending = THREE.AdditiveBlending;

		mesh = new THREE.Mesh(geometry, material);
	}else{
		mesh = splashes[foundIndex].mesh;
		mesh.visible = true;
	}
	

	mesh.rotation.x = Math.PI/2;

	mesh.position.x = x;
	mesh.position.y = Z_MAP_SPLASHES;
	mesh.position.z = z-8;
	
	mesh.scale.set(mscale,mscale,mscale);

	if(foundIndex == -1){
		let splash = {
			'x': x,
			'z': z,
			'frame': 0,
			'alive': true,
			'mesh': mesh,
			'scale': mscale,
			'texture': texture,
		};
		splashes.push(splash);
		scene.add(splashes[splashes.length-1].mesh);
	}else{
		splashes[foundIndex].frame = 0;
		splashes[foundIndex].alive = true;
	}
}








// flying_angle 0 = left, 180 = right.
function spawn_bomber(owner, x, z, flying_angle, speed, type, size){

	let mscale = 1;
	
	if(typeof flying_angle === "undefined"){
		flying_angle = 180;
		console.log("flying_angle = 180");
	}
	if(typeof speed === "undefined"){
		speed = 10;
	}
	if(typeof type === "undefined"){
		type = PLANE_BOMBER;
	}
	if(typeof size !== "undefined"){
		mscale = size;
	}
	
	let dire = new get_kxy_angle(flying_angle);

	let w = 1024;
	let h = 256;
	
	let foundIndex = find_free_bomber(x, z);
	
	let mesh;
	let texture;

	if(foundIndex == -1){
		texture = bomberSpriteTest.clone();
		texture.needsUpdate = true;

		let geometry = new THREE.PlaneGeometry(w, h);
		let material = new THREE.MeshPhongMaterial({map: texture, color: 0xFFFFFF});  			
		material.color.set(0xFFFFFF);
		material.transparent = true;
		material.opacity = 1;
		material.side = THREE.DoubleSide;
		material.emissive.set(0xFFFFFF);
		material.emissiveMap = bomberEmissiveTex;
		material.emissiveIntensity = 1.2;

		mesh = new THREE.Mesh(geometry, material);
	}else{
		mesh = bombers[foundIndex].mesh;
		mesh.visible = true;
		mesh.material.color.set(0xFFFFFF);
	}
	

	mesh.rotation.x = Math.PI/2;

	mesh.position.x = x;
	mesh.position.y = Z_BOMBER;
	mesh.position.z = z;
	
	mesh.scale.set(mscale,mscale,mscale);
	
	let kx = dire.x*speed;
	let kz = dire.z*speed;
	let health = 1000;
	let health_smokestart = 500;
	let health_falling = 200;

	if(foundIndex == -1){
		let bomber = {
			'x': x,
			'z': z,
			'kx': kx,
			'kz': kz,
			'speed': speed,
			'hit_time': -1,
			'explode_time': -1,

			'health': health,
			'health_smokestart': health_smokestart, // hp when bomber starts to fall down.
			'health_falling': health_falling, // hp when bomber starts to fall down.
			'falling': false,
			
			'frame': 0,
			'alive': true,
			
			'mesh': mesh,
			'scale': mscale,
			'texture': texture,
			'type': type,
			'bombing_start_time': -1,
			'last_bomb_time': -1,
			'owner': owner,
		};
		bombers.push(bomber);
		scene.add(bombers[bombers.length-1].mesh);
	}else{
		let bomber = bombers[foundIndex];
		bomber.frame = 0;
		bomber.alive = true;
		bomber.x = x;
		bomber.z = z;
		bomber.kx = kx;
		bomber.kz = kz;
		bomber.speed = speed;
		bomber.hit_time = -1;
		bomber.explode_time = -1;
		bomber.falling = false;
		bomber.health = health;
		bomber.health_smokestart = health_smokestart;
		bomber.health_falling = health_falling;
		bomber.scale = mscale;
		bomber.type = type;
		bomber.bombing_start_time = -1;
		bomber.last_bomb_time = -1;
		bomber.owner = owner;
	}
	
}



function spawn_bombers(){
	// -1 = AI team.
	spawn_bomber(OWNER_AI, -MAP_W/2, -MAP_H+Math.random()*800-800, 180, Math.random()*10+5);
	spawn_bomber(OWNER_AI, MAP_W/2, -MAP_H+Math.random()*800-800, 0, Math.random()*10+5);
}




function find_free_turret(type){
	for(let i = 0; i < turrets.length; i++){
		if(!turrets[i].alive && turrets[i].type == type){
			return i;
		}
	}
	return -1;
}

function turret_type_to_idleframe(type){
	if(type == TURRET_ANTIAIR){
		return "aa_idle";
	}else if(type == TURRET_BOMBER){
		return "bomber_idle";
	}
	return "aa_idle";
}
function turret_type_to_deadframe(type){
	if(type == TURRET_ANTIAIR){
		return "aa_dead";
	}else if(type == TURRET_BOMBER){
		return "bomber_dead";
	}
	return "aa_dead";
}



function spawn_turret(owner, x, z, type){

	let mscale = 1;
	

	if(typeof type === "undefined"){
		type = TURRET_ANTIAIR;
	}

	
	let sprite = SPRITES['turret'];


	let foundIndex = find_free_turret(type);
	
	let mesh;
	let texture;
	let turret = {};
	
	
	if(foundIndex == -1){
		texture = turretSpriteTest.clone();
		texture.needsUpdate = true;

		let geometry = new THREE.PlaneGeometry(sprite.w, sprite.h);
		let material = new THREE.MeshPhongMaterial({map: texture, color: 0xFFFFFF});  			
		material.color.set(0xFFFFFF);
		material.transparent = true;
		material.opacity = 1;
		material.side = THREE.DoubleSide;

		mesh = new THREE.Mesh(geometry, material);
	}else{
		turret = turrets[foundIndex];
		mesh = turret.mesh;
		mesh.visible = true;
		mesh.material.color.set(0xFFFFFF);
		texture = turret.texture;
	}
	
	// set correct frame:
	let framename = turret_type_to_idleframe(type);
	let pos = frame_offset('turret', framename, 0);
	texture.offset.x = pos.x;
	texture.offset.y = pos.y;
	
	mesh.rotation.x = Math.PI/2;

	mesh.position.x = x;
	mesh.position.y = Z_TURRET;
	mesh.position.z = z;
	
	mesh.scale.set(mscale,mscale,mscale);

	// initialize data:
	turret['frame'] = 0;
	turret['alive'] = true;
	turret['x'] = x;
	turret['z'] = z;
	turret['ammo'] = 1000;
	turret['shoot_start'] = -1;
	turret['health'] = 400;
	turret['health_smokestart'] = 100;
	turret['scale'] = mscale;
	turret['type'] = type;
	turret['owner'] = owner;
	turret['smokestart'] = false;
	turret['explode_time'] = -1;
	
	// if was new turret, update mesh/texture too, and add to array/scene:
	if(foundIndex == -1){
		turret['mesh'] = mesh;
		turret['texture'] = texture;
		
		turrets.push(turret);
		scene.add(turrets[turrets.length-1].mesh);
	}
	
}











function drop_bomb(owner, x, z, dire, speed, owned_by_ai){

	if(typeof owned_by_ai === "undefined"){
		owned_by_ai = false;
	}
	
	//play_sound("bomb_drop", x, z);
	
	
	let w = 25;
	let h = 17;
	
	let geometry = new THREE.PlaneGeometry(w, h);
	let material = new THREE.MeshPhongMaterial({map: bombSpriteTest, color: 0xFFFFFF});  			
	material.color.set(0xFFFFFF);
	material.transparent = true;
	material.opacity = 1;
	material.side = THREE.DoubleSide;
	//material.blending = THREE.AdditiveBlending;

	let mesh = new THREE.Mesh(geometry, material);
	let mscale = 1;
	//mesh.position.x = 2117;
	mesh.position.y = Z_MAP_BOMBS;
	//mesh.position.z = 237;

	let angle = get_angle(0, 0, dire.x, dire.z);
	mesh.rotation.x = Math.PI/2;
	mesh.rotation.z = (180-angle)*(Math.PI/180.0);
	
	mesh.scale.set(mscale,mscale,mscale);
	

	
	
	//let dire = new get_kxy_angle(players[myPlayer].angle);
	//let speed = 0.1*players[myPlayer].speed;

	
	mesh.position.x = x;
	mesh.position.z = z;
	
	let bomb = {
		'x': x,
		'z': z,
		'kx': dire.x*speed,
		'kz': dire.z*speed,
		'alive': true,
		'mesh': mesh,
		'whistling': false,
		'owned_by_ai': owned_by_ai,
		'owner': owner,
	};
	bombs.push(bomb);
	scene.add(bombs[bombs.length-1].mesh);
}





function shoot_turret(turret, owner){
	//let angle = -(Math.random()*(160-20)+20); // -20 to -160
	
	let pred_amount = 200;
	let hpred = Math.round(pred_amount/2);
	let curplayer = players[myPlayer];
	
	let target_x = curplayer.mesh.position.x;
	let target_z = curplayer.mesh.position.z;
	
	let dist = get_dist_2d(turret.x, turret.z, target_x, target_z);
	
	let max_dist = 1200; // 1200
	let shot_minimum_acceptable_distance = 50;
	
	// quick check to not process too far away players:
	if(dist < max_dist){

		let shot_start_x = turret.x;
		let shot_start_z = turret.z-17;
		

		// todo: fix speeds and remove sizemulti shit from code.
		let bullet_speed = 20.1; // speed 1 = 1*0.1+20 (lol)
		let max_frames_per_dist = 30*(max_dist*2)/bullet_speed; // double in case needed

		// add prediction of player movement in the future:
		let max_frames = Math.floor((dist/bullet_speed));
		let dire = new get_kxy_angle(curplayer.angle);
		let pspeed = curplayer.speed * sizemulti * max_frames;
		let add_x = dire.x*pspeed;
		let add_z = dire.z*pspeed;
		target_x = curplayer.mesh.position.x + add_x;
		target_z = curplayer.mesh.position.z + add_z;
		
		
		
		let targeting_angle = get_angle(shot_start_x, shot_start_z, target_x, target_z);

		let best_angle = 999;
		let frames_used = 0;
		let found_target = false;
		
		
		// simulate bullet movement beforehand:
		{
			let min_dist = 999999;
			let min_frames_used = 999999;
			let total_grounds_found = 0;
			
			// alter the angle to find best angle:
			//for(let a = -hpred; a <= hpred; a++){
			for(let a = -hpred; a <= hpred; a++){
				let astep = a*2.0;
				let cur_angle = targeting_angle + astep;
				let dire_bullet = new get_kxy_angle(cur_angle);
				
				let shot = {
					'x': shot_start_x,
					'z': shot_start_z,
					'kx': dire_bullet.x*bullet_speed,
					'kz': dire_bullet.z*bullet_speed,
				};
							
				// find shortest distance to target at first shot:
				for(let i = 0; i < max_frames_per_dist; i++){
					shot.x += shot.kx;
					shot.z += shot.kz;
					shot.kx *= AIR_RESISTANCE;
					shot.kz += GRAVITY_CONSTANT;
					
					let ground_found = is_ground(shot.x, shot.z);
					if(ground_found){
						total_grounds_found++;
						break;
					}
					
					let shot_dist = get_dist_2d(shot.x, shot.z, target_x, target_z);
					if(shot_dist < shot_minimum_acceptable_distance){
						frames_used = i+1;
						if(shot_dist < min_dist){
							min_dist = shot_dist;
							min_frames_used = frames_used;
							best_angle = cur_angle;
							found_target = true;
						}
					}
				}
			}
			
			//console.log("total_grounds_found = "+total_grounds_found);
		}
		

		
		if(found_target){
			
			//console.log("max_frames = "+max_frames+", frames_used = "+frames_used);
			
			let random_spread = (Math.random()-0.5)*1.5; //1.5 degree spread.
			let shot_angle = best_angle + random_spread;
			
			
			shoot_turret_from(owner, shot_start_x, shot_start_z, shot_angle, turret.type);
			//console.log("shoot turret from "+owner);
		}
	}
}


function shoot_turret_from(owner, x, z, angle, type){
	if(type == TURRET_ANTIAIR){
		play_sound("antiair_gun", x, z);
		shoot_planegun_nosound(owner, x, z, angle, 1);
	}else if(type == TURRET_BOMBER){
		play_sound("explosion_bullet", x, z);

		let dire = new get_kxy_angle(angle);
		let speed = 1*sizemulti+20;
		
		drop_bomb(owner, x, z, dire, speed);
	}
}





function shoot_from_myplayer(){
	let curplayer = players[myPlayer];
	if(curplayer.weapons1[curplayer.current1] == WEAPON_PLANEGUN){
		shoot_planegun(
			curplayer.owner,
			curplayer.mesh.position.x,
			curplayer.mesh.position.z,
			curplayer.shoot_angle,
			curplayer.speed
		);
	}else if(curplayer.weapons1[curplayer.current1] == WEAPON_SHOTGUN){
		play_sound("plane_machinegun", curplayer.mesh.position.x, curplayer.mesh.position.z);
	
		for(let i = 0; i < 10; i++){
			shoot_planegun_nosound(
				curplayer.owner,
				curplayer.mesh.position.x,
				curplayer.mesh.position.z,
				curplayer.shoot_angle+(Math.random()-0.5)*6,
				curplayer.speed+(Math.random()-0.5)*12,
				WEAPON_SHOTGUN
			);
		}
	}else if(curplayer.weapons1[curplayer.current1] == WEAPON_BOMB){
		let x = curplayer.mesh.position.x;
		let z = curplayer.mesh.position.z;
		let object_speed = curplayer.speed;
		let bullet_angle = curplayer.shoot_angle;
		bullet_angle += (Math.random()-0.5)*shooting_imprecision;
		let dire = new get_kxy_angle(bullet_angle);
		let speed = object_speed*sizemulti+20;
		
		drop_bomb(players[myPlayer].owner, x, z, dire, speed);
	}
}



function shoot_planegun(owner, x, z, bullet_angle, object_speed){
	play_sound("plane_machinegun", x, z);
	shoot_planegun_nosound(owner, x, z, bullet_angle, object_speed, WEAPON_PLANEGUN);
}



function shoot_planegun_nosound(owner, x, z, bullet_angle, object_speed, type){
	let w = 64;
	let h = 6;
	
	let geometry = new THREE.PlaneGeometry(w, h);
	let material = new THREE.MeshPhongMaterial({map: shotSpriteTest, color: 0xFFFFFF});  			
	material.color.set(0xFFFFFF);
	material.transparent = true;
	material.opacity = 1;
	material.side = THREE.DoubleSide;
	material.emissive.set(0xFFFF00);
	material.emissiveMap = shotlightsTex;
	material.emissiveIntensity = 0.7;
	//material.blending = THREE.AdditiveBlending;

	let mesh = new THREE.Mesh(geometry, material);
	let mscale = 1;
	mesh.position.x = x;
	mesh.position.y = Z_MAP_SHOTS;
	mesh.position.z = z;

	mesh.rotation.x = Math.PI/2;
	mesh.rotation.z = (180-bullet_angle)*(Math.PI/180.0);
	
	mesh.scale.set(mscale,mscale,mscale);
	
	bullet_angle += (Math.random()-0.5)*shooting_imprecision;
	let dire = new get_kxy_angle(bullet_angle);
	let speed = object_speed*sizemulti+20;

	let shot = {
		'x': x,
		'z': z,
		'kx': dire.x*speed,
		'kz': dire.z*speed,
		'alive': true,
		'mesh': mesh,
		'owner': owner,
		'type': type,
	};
	shots.push(shot);
	scene.add(shots[shots.length-1].mesh);
}











function change_player(playerIndex){
	if(playerIndex >= 0 && playerIndex < players.length){
		myPlayer = playerIndex;
	}else{
		console.log("player "+playerIndex+" does not exist");
	}
}






// keys
document.addEventListener("keyup", onDocumentKeyUp, false);
function onDocumentKeyUp(event) {
	KEYS[event.which] = false;
	
	var keyCode = event.which;
	//console.log("keyup = "+keyCode);
	
	if(keyCode == 32){ // 'space'
		//rotatePlayer = 0;
		bombingStarted = false;
		bombStartTime = 0;
		prevBombTime = 0;
		
	}else if(keyCode == 68){ // 'S'
		//rotatePlayer = 0;
	}
}


// keys
document.addEventListener("keydown", onDocumentKeyDown, false);
function onDocumentKeyDown(event) {
	KEYS[event.which] = true;
	
	var keyCode = event.which;
	console.log("keydown = "+keyCode);
	
	
	let curplayer = players[myPlayer];

	if(keyCode == 66){ // 'B'
		spawn_bombers();
		
	}else if(keyCode == 80){ // 'P'
		// toggle turrets
		turrets_enabled ^= 1;
		//if(turrets_enabled){
			for(let i = 0; i < turrets.length; i++){
				respawn_turret(i);
			}
		//}
		
	}else if(keyCode == 69){ // 'E'
		curplayer.lane++;
		if(curplayer.lane > 1){
			curplayer.lane = 1;
		}
		
	}else if(keyCode == 81){ // 'Q'
		curplayer.lane--;
		if(curplayer.lane < -1){
			curplayer.lane = -1;
		}
		
	}else if(keyCode == 82){
		mapMesh.material.alphaTest += 0.1;
		console.log(mapMesh.material.alphaTest);
	}else if(keyCode == 70){
		mapMesh.material.alphaTest -= 0.1;
		console.log(mapMesh.material.alphaTest);
	}else if(keyCode == 87){ // 'W'
		// jump
		
		
	}else if(keyCode == 83){ // 'S'
		// prone
		
		
	}else if(keyCode == 65){ // 'A'
		// turn left
		
		//rotatePlayer = 2;
		
	}else if(keyCode == 68){ // 'D'
		// turn right
		
		//rotatePlayer = -2;
		
	}else if(keyCode == 89){ // 'Y'
		// youtube element
		//var group = new THREE.Group();
		//group.add(new YoutubeEmbed('bmfudW7rbG0', 0, Z_RAIN, 0, -Math.PI/2));
		//scene2.add(group);
	
	}else if(keyCode == 32){ // 'space	'

		
	}else if(keyCode == 115){ // 'F4'
		if(guivisible){
			$("#gui").hide();
			//$("#sfxr_panel").hide();
		}else{
			$("#gui").show();
			//$("#sfxr_panel").show();
		}
		guivisible ^= 1;
		
	}else if(keyCode == 49){ // '1'
		change_player(keyCode-49);

	}else if(keyCode == 50){ // '2'
		change_player(keyCode-49);
		
	}else if(keyCode == 51){ // '3'
		change_player(keyCode-49);
		
	}else if(keyCode == 52){ // '4'
		change_player(keyCode-49);
		
	}else if(keyCode == 53){ // '5'
		change_player(keyCode-49);
		
	}else if(keyCode == 54){ // '6'
		change_player(keyCode-49);
		
	}else if(keyCode == 55){ // '7'
		change_player(keyCode-49);
		
	}else if(keyCode == 56){ // '8'
		change_player(keyCode-49);
		
	}else if(keyCode == 57){ // '9'
		SHOW_RAIN_BG ^= 1;
		
		if(SHOW_RAIN_BG){
			rainfallMesh.visible = true;
			waterdropsMesh.visible = true;
			fade_dir = 2; // enable
		}else{
			fade_dir = 1; // disable
		}
		
	}else if(keyCode == 78){ // 'N'
		SHOW_NIGHTSKY_BG ^= 1;
		
		// night_enabled night enabled
		if(SHOW_NIGHTSKY_BG){
			night_fade_dir = 2; // enable night
			// todo: add textures/clouds/sunset.png for sunset night mode.
			//scene.background = new THREE.Color(0xFFFF00); // add skybox. this simple!
		}else{
			//scene.background = nightskyImg; // add skybox. this simple!
			skyboxMesh.visible = true;
			night_fade_dir = 1; // disable night
		}
		
	}else if(keyCode == 48){ // '0'
		SHOW_WAVE_BG ^= 1;
		
		terrain.visible = !!SHOW_WAVE_BG;
		
	}else if(keyCode == 13){ // 'enter'

	}
};




$(window).bind('beforeunload', function(){
	return null; // disabled for dev mode...
	return 'Are you sure you want to leave?'; // modern browsers will show their own message instead of this.
});





// onmousemove
document.addEventListener("mousemove", onDocumentMouseMove, false);
function onDocumentMouseMove(event) {
	var renderlayer = renderer.getSize();
	var midX = renderlayer.width/2;
	var midY = renderlayer.height/2;
	var x = event.clientX;
	var y = event.clientY;
	// update mouse pos only if not pressing SHIFT key.
	// NOTE: DONT USE CTRL IN ANY COMBINATIONS SINCE CTRL+W QUITS PAGE.
	// this way you can stop camera following mouse.
	// todo: fix pointing direction being wrong if player not in middle of screen.
	if(!key_down(16)){ // 'SHIFT'
		MOUSE_X = x;
		MOUSE_Y = y;
	}
	
	var angle = get_angle(midX, midY, x, y);
	var dist = get_dist_2d(midX, midY, x, y);
	var maxDistX = midX/1;
	var maxDistY = midY/1;
	var maxDist = maxDistX;
	if(maxDistY < maxDistX){
		maxDist = maxDistY;
	}
	if(dist > maxDist){
		dist = maxDist;
	}
	var distPercent = dist/maxDist;
	var maxSpeed = 80;
	var minSpeed = 0;

	
	if(!players.length){
		console.log("players not initialized yet");
	}else{
		//setAngle(myPlayer, angle);
		//setSpeed(myPlayer, minSpeed+distPercent*maxSpeed);
		setShootAngle(myPlayer, angle);
		
	}
};




document.addEventListener("mousedown", onDocumentMouseDown, false);
function onDocumentMouseDown(event) {
	if(event.button == 0){ // left click leftclick
		if(players.length > 0){
			shoot_from_myplayer();
			prevShootTime = getTimeMillis();
			shooting_started = true;
			prevShootStartTime = getTimeMillis();
		}
	
	}else if(event.button == 1){ // middle click
		// change primary weapon:
		if(players.length > 0){
			players[myPlayer].current1++;
			if(players[myPlayer].current1 >= players[myPlayer].weapons1.length){
				players[myPlayer].current1 = 0;
			}
		}
		
	}else if(event.button == 2){ // right click
		// flip plane:

		if(players.length > 0){
			if(players[myPlayer].type == TYPE_PLANE){
				if(!flip_dir){
					plane_flipped ^= 1;
				
					play_sound("plane_flip", players[myPlayer].mesh.position.x, players[myPlayer].mesh.position.z);
			
					//console.log("plane_flipped: "+(!!plane_flipped));
							
					flip_dir = 1;
					
				}
			}
		}
	}
};




document.addEventListener("mouseup", onDocumentMouseUp, false);
function onDocumentMouseUp(event) {
	if(event.button == 0){ // left click
		shooting_started = false;
		can_shoot = false;
	}else if(event.button == 1){ // middle click
		
	}else if(event.button == 2){ // right click
		
	}
};



</script>


</body>
</html>