<!DOCTYPE html>
<html lang="en">
<head>
	<title>Master Defender</title>
	<meta charset="utf-8" />
	<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
	<meta http-equiv="Pragma" content="no-cache" />
	<meta http-equiv="Expires" content="0" />

	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0" />
	
	<meta name="mobile-web-app-capable" content="yes" />
	<meta name="apple-mobile-web-app-capable" content="yes" />
	<meta name="apple-mobile-web-app-status-bar-style" content="black" />
	
	<meta property="og:title" content="Master Defender" />
	<meta property="og:description" content="Defend your ground by planes and soldiers!" />
	
	<!--
	<script src="three.js"></script>
	-->
	<!-- to get latest three.js use: https://unpkg.com/three@latest/build/three.module.js -->
	<!-- to get latest shims.js use: https://unpkg.com/es-module-shims@latest/dist/es-module-shims.js -->
	<script async src="./es-module-shims_1.3.6.js"></script> <!-- used to make imports work cross-browser, v 1.3.6 originally -->
	<script type="importmap">{"imports":{"three":"./three.module.min_0.145.0.js"}}</script>

	<script src="FileSaver.js"></script>

	<link type="text/css" href="jquery/jquery-ui.css" rel="Stylesheet" />
	<script type="text/javascript" src="jquery/jquery.min.js"></script>
	<script type="text/javascript" src="jquery/jquery-ui.min.js"></script>
	
	<script src="riffwave.js"></script>
	<script src="sfxr.js"></script>

	<!-- Google tag (gtag.js) -->
	<script async src="https://www.googletagmanager.com/gtag/js?id=G-7HEP5RL9MR"></script>
	<script>window.dataLayer = window.dataLayer || [];function gtag(){dataLayer.push(arguments);}gtag('js', new Date());gtag('config', 'G-7HEP5RL9MR');</script>

<!--
8.10.
- turret trajectories visible with L button.
- shotgun bullets optimized a bit.
- added whole planet full of turrets and bomb turrets as well.
- bullets have fusetimer, so they will explode after some time.

7.10.
- added smoother round explosion with more frames and transparency.

3.10.
- added ufo player, uses same controls as helicopter.
- helicopter can now rotate with right click.
- helicopter no longer automatically flips x axis from image when moving.
- added helicopter as 3d sprite.
- fixed complane normalmap (was rendered wrong in blender).
- use shift+rotation key (A/D) to rotate 10 times slower.

1.10.
- added 90 degree rotations for plane.
- added commercial airplane model as default testing plane.

30.9.
- shots center position is at the tip of the shot instead of the center of the shot.

29.9.
- finished sprite sheet genereator.
- added detailed plane texture/normalmap test from 3d model.

24.9.
- converted planet textures to webp format to be able to upload to github, and probably keep using webp in future since it saves a lot of space.

23.9.
- fixed soldier animation code to actually work properly if it runs too fast.
- cleaned up plane flipping/animation code.
- changed zoom notifications to more readable format.
- created 3x scaled version from plane and santa_sleigh sprite.
- resized bomber and plane sprite images to fit image with 1px padding.

22.9.
- added option to not rotate camera with gravity (ENTER).
- changed shot size to normal.
- changed pause key to ESC.
- added galaxy background to planet map.
- repetitive textures are now resized smoothly to power of two sizes (never smaller than original image).
- added notification if webgl context fails.
- added filesaver.js for testing.
- fixed camera peeking not working on circular maps.
- fixed explosions going at wrong offset at other side of planet.
- added information message system (useful when wanting to zoom at specific level for screenshots).

21.9.
- cleaned up load_map function and mousemove function.
- fixed shooting direction on circular maps & removed camera offset (adding later when its fixed).

19.9.
- cleaned up code. added some properties in map. using water_y from map json.

18.9.
- added planet map.
- back/middle/front images can now be their own sizes.
- added possibility to disable clouds.

15.9.
- added ambient light coloring possibilities in map.json.
- added parseColor for parsing colors from config files.
- fixed sunset color not affecting sky. N/M buttons work more logically.

13.9.2022
- map textures, water, etc are now loaded from map.json.


-->

<style>

html, body {
    margin: 0;
    padding: 0;
    height: 100%;
    width: 100%;
}




#loading_container {
    margin: 0;
    padding: 0;
    height: 100%;
    width: 100%;
	

	text-shadow: rgba(0,0,0,0.5) 0px 0px 1.5px, rgba(0,0,0,0.2) 0px 0px 5px, rgba(0,0,0,0.15) 0px 0px 10px;
}

#loading_container {
    display: table;
	position:absolute;
	background: rgb(27,48,110);
	
	background: radial-gradient(circle, rgba(0,0,0,0.5) 0%, rgba(0,198,196,0.5) 13%, rgba(0,255,252,0.5) 15%, rgba(39,255,244,0.5) 17%, rgba(240,18,17,0.5) 65%, rgba(255,0,0,0.5) 100%), linear-gradient(0deg, rgba(27,48,110,1) 10%, rgba(106,125,255,1) 55%, rgba(137,219,122,1) 60%, rgba(3,3,10,1) 83%, rgba(0,0,0,1) 100%);
	
	background-size: 100% 100%;
	background-position: 50% 50%;
	
	animation: gradient 3s ease infinite;
}

@keyframes gradient {
	0% {
		background-size: 100% 100%;
	}
	50% {
		background-size: 200% 200%;
	}
	100% {
		background-size: 100% 100%;
	}
}


#loading_container_inner {
    display: table-cell;
    margin: 0;
    padding: 0;

    text-align: center;
    vertical-align: middle;
}

#loading_text {
	font:40px verdana;
	margin: auto;
	color:#000;
}

#loading_desc {
	font:12px verdana;
	color:#000;
}




/* Pure CSS Loaders: https://loading.io/css/ */

.lds-ellipsis {
  display: inline-block;
  position: relative;
  width: 80px;
  height: 80px;
  top:40px;
}
.lds-ellipsis div {
  position: absolute;
  top: 33px;
  width: 8px;
  height: 8px;
  border-radius: 50%;
  background: #000;
  
  box-shadow: rgba(0,0,0, 0.5) 0px 0px 1px, rgba(0,0,0, 0.5) 0px 0px 8px, rgba(0,0,0, 0.3) 0px 0px 16px;
}
.lds-ellipsis div:nth-child(1) {
  left: 8px;
  animation: lds-ellipsis1 0.6s infinite;
}
.lds-ellipsis div:nth-child(2) {
  left: 8px;
  animation: lds-ellipsis2 0.6s infinite;
}
.lds-ellipsis div:nth-child(3) {
  left: 32px;
  animation: lds-ellipsis2 0.6s infinite;
}
.lds-ellipsis div:nth-child(4) {
  left: 56px;
  animation: lds-ellipsis3 0.6s infinite;
}
@keyframes lds-ellipsis1 {
  0% {
    transform: scale(0);
  }
  100% {
    transform: scale(1);
  }
}
@keyframes lds-ellipsis3 {
  0% {
    transform: scale(1);
  }
  100% {
    transform: scale(0);
  }
}
@keyframes lds-ellipsis2 {
  0% {
    transform: translate(0, 0);
  }
  100% {
    transform: translate(24px, 0);
  }
}





/* Pure CSS Loaders: https://loading.io/css/ */

.lds-ellipsis-left {
  display: inline-block;
  position: relative;
  width: 80px;
  height: 80px;
  top:40px;
}
.lds-ellipsis-left div {
  position: absolute;
  top: 33px;
  width: 8px;
  height: 8px;
  border-radius: 50%;
  background: #000;
  
  box-shadow: rgba(0,0,0, 0.5) 0px 0px 1px, rgba(0,0,0, 0.5) 0px 0px 8px, rgba(0,0,0, 0.3) 0px 0px 16px;
}
.lds-ellipsis-left div:nth-child(1) {
  left: 8px;
  animation: lds-ellipsis-left1 0.6s infinite;
}
.lds-ellipsis-left div:nth-child(2) {
  left: 8px;
  animation: lds-ellipsis-left2 0.6s infinite;
}
.lds-ellipsis-left div:nth-child(3) {
  left: 32px;
  animation: lds-ellipsis-left2 0.6s infinite;
}
.lds-ellipsis-left div:nth-child(4) {
  left: 56px;
  animation: lds-ellipsis-left3 0.6s infinite;
}
@keyframes lds-ellipsis-left1 {
  0% {
    transform: scale(1);
  }
  100% {
    transform: scale(0);
  }
}
@keyframes lds-ellipsis-left3 {
  0% {
    transform: scale(0);
  }
  100% {
    transform: scale(1);
  }
}
@keyframes lds-ellipsis-left2 {
  0% {
    transform: translate(24px, 0);
  }
  100% {
    transform: translate(0, 0);
  }
}


</style>


<script>

/*
{ // doesnt seem to work on three.js ?
	let w = document.documentElement.clientWidth * window.devicePixelRatio;
	viewport = document.querySelector("meta[name=viewport]");
	viewport.setAttribute('content', 'width=' + w);

	document.documentElement.style.transform = 'scale( 1 / window.devicePixelRatio )';
	document.documentElement.style.transformOrigin = 'top left';
}
*/



/*
var YoutubeEmbed = function(id, x, y, z, rx){
	var div = document.createElement('div');
	div.style.width = '480px';
	div.style.height = '360px';
	div.style.backgroundColor = '#000';
	var iframe = document.createElement('iframe');
	iframe.style.width = '480px';
	iframe.style.height = '360px';
	iframe.style.border = '0px';
	iframe.src = ['https://www.youtube.com/embed/', id, '?rel=0&autoplay=1&mute=0'].join('');
	div.appendChild(iframe);
	var object = new CSS3DObject(div);
	object.position.set(x, y, z);
	object.rotation.x = rx;
	return object;
};
*/






// in: {rrr,ggg,bbb,aaa} (0-255)
// out: 0xAARRGGBB
function colorToUint32(color){
	return encodeRGBA(color.a, color.r, color.g, color.b);
}

// possible types (basically same formats as in CSS):
// RGB RGBA RRGGBB RRGGBBAA (hex values with or without #).
// [r,g,b] [r,g,b,a] (alpha here is 0-1 value, r,g,b are 0-255 values).
function parseColor(val){
	if(typeof val === "string"){
		if(val.length > 0){
			val = val.trim();
			if(val[0] == "#"){
				val = val.substr(1);
			}
			return decodeHexRGBA(val);
		}else{
			console.error("Invalid color string: empty string.");
		}
	}else if(val instanceof Array){
		let r,g,b,a = 0;
		if(val.length == 3){
			r = Math.round(parseInt(val[0]));
			g = Math.round(parseInt(val[1]));
			b = Math.round(parseInt(val[2]));
			a = 255;
		}else if(val.length == 4){
			r = Math.round(parseInt(val[0]));
			g = Math.round(parseInt(val[1]));
			b = Math.round(parseInt(val[2]));
			a = Math.round(parseFloat(val[3])*255); // alpha is 0-1 value like in CSS.
		}else{
			console.error("Invalid color format for array: "+val.toString());
		}
		if(a < 0) a = 0; if(a > 255) a = 255;
		if(r < 0) r = 0; if(r > 255) r = 255;
		if(g < 0) g = 0; if(g > 255) g = 255;
		if(b < 0) b = 0; if(b > 255) b = 255;
		return {r,g,b,a};
	}else if(typeof val === "number"){
		let uintval = (parseInt(val) >>> 0);
		let rgba = decodeRGBA(uintval); // convert integer to unsigned integer just in case.
		if(uintval <= 0xFFFFFF){
			rgba.a = 255; // add full opacity if alpha not defined.
		}
		return rgba;
	}else{
		console.error("Invalid color format for:");
		console.error(val);
	}
	return {r:12,g:34,b:56,a:123};
}


// possible formats: RGB RGBA RRGGBB RRGGBBAA
function decodeHexRGBA(str){
	let r,g,b,a = 0;
	if(str.length == 3){
		r = Math.round(parseInt(str.substr(0,1), 16)/15*255);
		g = Math.round(parseInt(str.substr(1,1), 16)/15*255);
		b = Math.round(parseInt(str.substr(2,1), 16)/15*255);
		a = 255;
	}else if(str.length == 4){
		r = Math.round(parseInt(str.substr(0,1), 16)/15*255);
		g = Math.round(parseInt(str.substr(1,1), 16)/15*255);
		b = Math.round(parseInt(str.substr(2,1), 16)/15*255);
		a = Math.round(parseInt(str.substr(3,1), 16)/15*255);
	}else if(str.length == 6){
		r = parseInt(str.substr(0,2), 16);
		g = parseInt(str.substr(2,2), 16);
		b = parseInt(str.substr(4,2), 16);
		a = 255;
	}else if(str.length == 8){
		r = parseInt(str.substr(0,2), 16);
		g = parseInt(str.substr(2,2), 16);
		b = parseInt(str.substr(4,2), 16);
		a = parseInt(str.substr(6,2), 16);
	}else{
		console.error("Invalid color format for string '"+str+"', should be hex format: RGB or RGBA or RRGGBB or RRGGBBAA");
		return {r:12,g:34,b:56,a:123};
	}
	let err = "";
	// check if any of the colors was NaN:
	if(r !== r){ r = 0; err = "red"; }
	if(g !== g){ g = 0; err = "green"; }
	if(b !== b){ b = 0; err = "blue"; }
	if(a !== a){ a = 0; err = "alpha"; }
	if(err.length > 0){
		console.error("Invalid "+err+" channel of color '"+str+"' -> set to zero.");
	}
	return {r,g,b,a};
}





function decodeRGBA(argb){
	return {
		a: (argb >> 24) & 255,
		r: (argb >> 16) & 255,
		g: (argb >> 8) & 255,
		b: argb & 255, 
	};
}

function encodeRGBA(a,r,g,b){
	return ((a << 24) | (r << 16) | (g << 8) | b) >>> 0; // ">>> 0" converts to 32bit unsigned integer
}

function valueBetween(from, to, percent){
	return (to-from)*percent+from;
}

function intBetween(from, to, percent){
	return Math.round(valueBetween(from, to, percent));
}

// gives gradient color value at specific point of the gradient line.
function colorBetweenRGBA(from, to, percent){
	let c1 = decodeRGBA(from);
	let c2 = decodeRGBA(to);
	return encodeRGBA(
		intBetween(c1.a, c2.a, percent),
		intBetween(c1.r, c2.r, percent),
		intBetween(c1.g, c2.g, percent),
		intBetween(c1.b, c2.b, percent)
	);
}

function colorBetweenRGBA_array(arr, percent){
	let len = arr.length;
	let total_gradients = len-1; // 2 colors have 1 gradient, 3 have 2. etc.
	let step = 1.0/total_gradients;
	let c1 = Math.floor(percent/step);
	let c2 = c1+1;
	if(c2 > len-1){
		c2 = len-1;
	}
	let percent_between = (percent/step)-c1;
	return colorBetweenRGBA(arr[c1], arr[c2], percent_between);
}







var PARAMS = new Params();
var SOUND;
var SOUND_VOL = 0.1068; // see sfxr.js (var volume) for volume adjusting for browser. this changes the wav file but doesnt work well because it clips the sounds at too loud or low volumes.
var SAMPLE_RATE = 44100;
var SAMPLE_SIZE = 8;
var CURRENT_TYPE = "";
var LOCKED = {};


</script>




<style>
* {
	box-sizing: border-box;
	cursor:default;
}
body {
	background:#000;
	color:#fff;
	padding:0;
	margin:0;
	overflow:hidden;
	font-family:courier;
	text-align:left;
	font-size:1.5vmax;
}
#gui {
	display:none;
}

#fps {
	position:absolute;
	top:0;
	left:0;
	font:12px verdana;
	padding:4px 4px 4px 10px;
	background-color:rgba(0,0,0, 0.5);
	text-shadow: 0 0 3px #000000, 0 0 2px #000000, 0 0 1px #000000;
	border-bottom-right-radius:10px;
}
#info {
	position: absolute;
	bottom:0;
	left:0;
	width: 100%;
	font:12px verdana;
	padding:4px 4px 4px 10px;
	background-color:rgba(0,0,0, 0.5);
	text-shadow: 0 0 3px #000000, 0 0 2px #000000, 0 0 1px #000000;
}
.elem {
	float:left;
	padding-right:30px;
}

#players {
	text-align:left;
	position:absolute;
	right:0;
	top:0;
	max-width:30vmax;
	padding:0.5vmax;
	background-color:rgba(0,0,0, 0.5);
	border-bottom-left-radius:1vmax;
	font:1vmax courier;
}



#players-ending-scores {
	text-align:left;
	position:absolute;
	left:50%;
	top:15%;
	margin-left:-18vmax;
	margin-top:0;
	width:36vmax;
	padding:10px 10px 10px 10px;
	background-color:rgba(0,0,0, 0.85);
	border-radius:1.5vmax;
	font-size:2vmax;
}


#countdown {
	padding-top:15px;
	width:100%;
	text-align:center;
}

.hidden {
	display:none;
}


#ending-score-table {
	width:100%;
}

#ending-score-table .num {
	width:2vmax;
	padding-left:0.25vmax;
	padding-right:0.25vmax;
	text-align:right;
}
#ending-score-table .nam {
	padding-left:0.5vmax;
	padding-right:10px;
}
#ending-score-table .sco {
	width:3vmax;
	padding-left:0.5vmax;
	padding-right:1vmax;
}
#ending-score-table .ext {
	width:3vmax;
	padding-left:1vmax;
	padding-right:0.25vmax;
	color:rgba(255,255,255, 0.5);
}



</style>
</head>
<body>




<style>
#blocker {
	position: absolute;
	top: 0px;
	left: 0px;
	width: 100%;
	height: 100%;
}
</style>

<div id="container"></div>
<div id="blocker"></div>



	
<script>
/*jshint esversion: 6 */
//credit: https://gist.github.com/banksean/304522#file-perlin-noise-simplex-js
class Perlin {
	constructor() {
		this.grad3 = [[1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0], [1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1], [0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1]]; 
		this.p = []; for (var i=0; i<256; i++) { this.p[i] = Math.floor(Math.random()*256);}
		this.perm = []; for(i=0; i<512; i++) { this.perm[i]=this.p[i & 255];} 
		this.simplex = [[0,1,2,3],[0,1,3,2],[0,0,0,0],[0,2,3,1],[0,0,0,0],[0,0,0,0],[0,0,0,0],[1,2,3,0],[0,2,1,3],[0,0,0,0],[0,3,1,2],[0,3,2,1],[0,0,0,0],[0,0,0,0],[0,0,0,0],[1,3,2,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[1,2,0,3],[0,0,0,0],[1,3,0,2],[0,0,0,0],[0,0,0,0],[0,0,0,0],[2,3,0,1],[2,3,1,0],[1,0,2,3],[1,0,3,2],[0,0,0,0],[0,0,0,0],[0,0,0,0],[2,0,3,1],[0,0,0,0],[2,1,3,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[2,0,1,3],[0,0,0,0],[0,0,0,0],[0,0,0,0],[3,0,1,2],[3,0,2,1],[0,0,0,0],[3,1,2,0],[2,1,0,3],[0,0,0,0],[0,0,0,0],[0,0,0,0],[3,1,0,2],[0,0,0,0],[3,2,0,1],[3,2,1,0]]; 
	}
	dot(g, x, y){ return g[0]*x + g[1]*y;}
	noise(xin, yin) { 
		var n0, n1, n2;var F2 = 0.5*(Math.sqrt(3.0)-1.0); var s = (xin+yin)*F2;var i = Math.floor(xin+s); var j = Math.floor(yin+s); var G2 = (3.0-Math.sqrt(3.0))/6.0; var t = (i+j)*G2; var X0 = i-t;var Y0 = j-t; var x0 = xin-X0;var y0 = yin-Y0; var i1, j1; if(x0>y0) {i1=1; j1=0;} else {i1=0; j1=1;} var x1 = x0 - i1 + G2;var y1 = y0 - j1 + G2; var x2 = x0 - 1.0 + 2.0 * G2;var y2 = y0 - 1.0 + 2.0 * G2; var ii = i & 255; var jj = j & 255; var gi0 = this.perm[ii+this.perm[jj]] % 12; var gi1 = this.perm[ii+i1+this.perm[jj+j1]] % 12; var gi2 = this.perm[ii+1+this.perm[jj+1]] % 12; var t0 = 0.5 - x0*x0-y0*y0; if(t0<0) n0 = 0.0; else { t0 *= t0; n0 = t0 * t0 * this.dot(this.grad3[gi0], x0, y0);} var t1 = 0.5 - x1*x1-y1*y1; if(t1<0) n1 = 0.0; else { t1 *= t1; n1 = t1 * t1 * this.dot(this.grad3[gi1], x1, y1); }var t2 = 0.5 - x2*x2-y2*y2; if(t2<0) n2 = 0.0; else { t2 *= t2; n2 = t2 * t2 * this.dot(this.grad3[gi2], x2, y2); } return 70.0 * (n0 + n1 + n2);
	}
}
</script>



<style>
.checkmark {
	min-width:20px;
	width:20px;
	font:bold 14px verdana;
	margin-right:5px;
}

.but_play, .but_new {
	width:78px;
}






#pause_container {

    margin: 0;
    padding: 0;
    height: 100%;
    width: 100%;
	display:none;

	position:absolute;
	background: rgba(0,0,0, 0.7);
	

	background: radial-gradient(circle, rgba(0,0,0,0.4654236694677871) 0%, rgba(0,0,0,0.8939950980392157) 36%, rgba(0,0,0,1) 59%, rgba(0,0,0,1) 100%);

	
	background-size: 100% 100%;
	background-position: 50% 50%;
	
	--animation: gradient 3s ease infinite;
}

@keyframes gradient {
	0% {
		background-size: 100% 100%;
	}
	50% {
		background-size: 200% 200%;
	}
	100% {
		background-size: 100% 100%;
	}
}


#pause_container_inner {
    display: table-cell;
    margin: 0;
    padding: 0;

    text-align: center;
    vertical-align: middle;
}

#pause_text {
	font:bold 40px verdana;
	margin: auto;
	color: #000;
	text-shadow: 0 -1px 4px #FFF, 0 -2px 10px #ff0, 0 -18px 40px #F00;
}

#pause_desc {
	font:bold 14px verdana;
	color: #000;
	
	text-shadow: 0 -1px 2px rgba(255,255,255,0.6), 0 -2px 5px rgba(255,255,0,0.6);

}
#pause_container .lds-ellipsis-left div {
	--background: #FFF;
}
#pause_container .lds-ellipsis div {
	--background: #FFF;
}

#messages_container {
	display:none;
	font:12px verdana;
	width:100%;
	text-align:center;
	position:absolute;
	top:0;
	left:0;
	overflow:hidden;
	max-height:70px;
}

.message_line {
	width:100%;
	text-align:center;
}

.message {
	display:inline-block;
	padding:4px 10px 4px 10px;
	background-color:rgba(0,0,0, 0.5);
	text-shadow: 0 0 3px #000000, 0 0 2px #000000, 0 0 1px #000000;
	border-radius:10px;
}


.flash {
	animation: flash_anim 3s linear infinite;
	animation-iteration-count: 1;
}
@keyframes flash_anim {
	0% {
		opacity: 1;
		color:#FFFF00;
	}
	2% {
		opacity: 0;
		color:#000000;
	}
	4% {
		opacity: 1;
		color:#FFFF00;
	}
	6% {
		opacity: 0;
		color:#000000;
	}
	8% {
		opacity: 1;
		color:#FFFF00;
	}
	100% {
		opacity: 1;
		color:#FFFFFF;
	}
}

</style>

<div id="loading_container"><div id="loading_container_inner">
	<div id="loading_text">
		<div class="lds-ellipsis-left"><div></div><div></div><div></div><div></div></div>Loading<div class="lds-ellipsis"><div></div><div></div><div></div><div></div></div>
	</div>
	<div id="loading_desc">Working...</div>
</div></div>




<div id="pause_container"><div id="pause_container_inner">
	<div id="pause_text">GAME PAUSED</div>
	<div id="pause_desc"><span id="by_enter">Press ESC</span><span id="by_click">Click</span> to unpause</div>
	<!--
	<div>Settings</div>
	<div>Keys</div>
	-->
</div></div>

<div id="messages_container">

</div>


<div id="gui">

	<div id="fps">
	FPS: 0
	</div>

	<div id="info">
		<div class="elem">
			X: <span id="player-x">0</span>
		</div>
		<div class="elem">
			Y: <span id="player-z">0</span>
		</div>
		<div class="elem">
			Z: <span id="player-y">0</span>
		</div>
		<div class="elem">
			Deg: <span id="player-angle">0</span>
		</div>
		<div class="elem">
			SDeg: <span id="player-shoot-angle">0</span>
		</div>
	</div>

	<div id="players">
		<div id="scores" style="display:none">
		</div>
	</div>

	<div id="players-ending-scores" class="hidden">
		<div id="ending-scores">
		</div>
		<div id="countdown"></div>
	</div>
</div>

<div id="imagecache"></div>


<script type="module">
"use strict";


import * as THREE from 'three';



var colorList = [0xFF9595, 0xFF95BD, 0xFF95E0, 0xFF65FA, 0xCAC1FF, 0x79B8FF, 0x19C1FF, 0x01EAFF, 0x01FFCC, 0x8BD783, 0x5CD050, 0xF8FF3F, 0xFBFF99, 0xFDFFCF, 0xFFE9CF, 0xFFC581, 0xFFA281];

var colorListHtml = ["#FF9595", "#FF95BD", "#FF95E0", "#FF65FA", "#CAC1FF", "#79B8FF", "#19C1FF", "#01EAFF", "#01FFCC", "#8BD783", "#5CD050", "#F8FF3F", "#FBFF99", "#FDFFCF", "#FFE9CF", "#FFC581", "#FFA281"];

var randomWords = ["soldier", "admiral", "general", "lieutenant"];

let alphanumeric = "abcdefghijklmnopqrstuvwxyz0123456789";





let INTERNAL_ZOOM = 1;
let ZOOM_MULTI = 1.08;


var ortho = true;
let camstyle = 1; // 1 = ortho, 0 = 3d
if(!ortho){
	camstyle = 0;
}
var smoothRender = 1;

let game_paused = false;
let game_paused_by_enter = false;

var globalFilter = smoothRender ? THREE.LinearFilter : THREE.NearestFilter;


var contextmenu_enabled = false;

var window_focus = true;

let loading_start_time = 0;


var SHOW_WAVE_BG = false;
var SHOW_RAIN_BG = false; // rain enabled/disabled
var SHOW_MAP_BG = true;
var SHOW_NIGHTSKY_BG = false;
var NIGHTSKY_STYLE = 0; // 0 = night, 1 = sunset (bright yellow).
var turrets_enabled = true;
var turret_trajectories_enabled = 0;
var player_trajectories_enabled = 1;


var fade_dir = 0;
var night_fade_dir = 0; // 0 = night disabled.



var plane_flipping = 0;

var planeFrameIndex = 0;
var plane_current_flip_dir = 0; // 1 = spin_to_up, 0 = spin_to_down

var heliFrameIndex = 0;
var heli_current_flip_dir = 0;

var ufoFrameIndex = 0;



///////////////////////////////////////////////////////
// z-indexes for different layers of objects:
// from furthest to nearest (in the order of rendering; first in this list = smallest number = first to render).
//
var ZINSTEP = 160; // WARNING: max seems to be ~165. or else nearest layers wont be visible. no idea why...
if(!ortho){
	ZINSTEP = 1;
}
let total_layers = 28; // should increase this to match layer count(?)
var ZIN = -ZINSTEP*total_layers;
// create new Z-index value
function NEWZIN(){
	ZIN += ZINSTEP;
	console.log("newzin = "+(ZIN-ZINSTEP));
	return ZIN-ZINSTEP;
}
// randomized zin value is needed to avoid rendering glitches when zin values are exactly same.
// random zindex
function randomized_y(zinvalue){
	// *0.9 to avoid overlapping with next ZIN value.
	return zinvalue+Math.random()*(ZINSTEP*0.9);
}

// do not put any NEWZIN calls above this line!!
var Z_MINZIN = NEWZIN(); // behind everything.

var Z_SKYBOX = NEWZIN(); // night sky (skybox).

var Z_CLOUDS = NEWZIN(); // clouds parallax


var Z_MAP_WATER_BACK = NEWZIN();

var Z_MAP_WATERDROPS = NEWZIN();

var Z_MAP_BG = NEWZIN(); // map texture (back layer / map background parallax).


var Z_MAP_LIGHT = NEWZIN();


var Z_MAP_BEHIND = NEWZIN(); // map sprites layer

var Z_MAP_BEHIND_FRONT = NEWZIN(); // on front of the behind items.

var Z_TURRET_BARREL = NEWZIN();

var Z_TURRET = NEWZIN(); //  turrets behind every other object.




var Z_MAP_BOMBS = NEWZIN();
var Z_MAP_SHOTS = NEWZIN();

var Z_BOMBER = NEWZIN(); // enemy planes basically.
var Z_PLANE = NEWZIN(); // airplanes.
var Z_SOLDIER = NEWZIN(); // soldiers.




var Z_MAP_EXPLOSIONS = NEWZIN();


var Z_MAP_DECALS = NEWZIN(); // decals (bushes to hide behind)

var Z_MAP_FRONT = NEWZIN(); // map sprites layer

var Z_MAP_COLLISION = NEWZIN(); // main map texture.

var Z_MAP_COLLISION_FRONT = NEWZIN(); // when on front "lane"





var Z_MAP_WATER_FRONT = NEWZIN();

var Z_MAP_SPLASHES = NEWZIN();

var Z_MAP_VISUALS = NEWZIN(); // explosion glows etc.

var Z_MAP_PARTICLES = NEWZIN(); // explosion particles etc. non-important details.


var Z_PORTAL = NEWZIN();



var Z_RAIN = NEWZIN(); // rain texture.

var Z_MAXZIN = NEWZIN(); // on front of everything.

//
////////////////////////////////////////////////////



var urlprefix = ""; // possibly used when using (node.js) server to host files at url such as "https://md.com/".

var MAP_NAME = "planet";
var MOD_NAME = "default";
//var MAP_NAME = "highmap";
var MAP_FOLDER = urlprefix+'maps/'+MAP_NAME;
var MOD_FOLDER = urlprefix+'mods/'+MOD_NAME;
var MAP_DATA_URL = MAP_FOLDER+'/map.json'+randomVersion(); // add randomversion to make sure it is always re-downloaded.
var MOD_DATA_URL = MOD_FOLDER+'/mod.json'+randomVersion(); // add randomversion to make sure it is always re-downloaded.


var GRAVITY_PLANAR = 0; // default
var GRAVITY_CIRCULAR = 1; // uses GRAVITY.points as average coordinates.

var GRAVITY_DEFAULT = {
	style: GRAVITY_PLANAR,
	points: [], // array of gravity points. if no points: no gravity.
	value: 0.15,
};
// todo: remove this and use map.json to define pieces...

let PLANETS = [
	{x:0,     z:0, 		 range:10000, minradius:2500, kx:0, kz:0},
	{x:12000, z:8000, 	 range:10000, minradius:2500, kx:0, kz:0},
	{x:12700,  z:-12700, range:10000, minradius:2500, kx:0, kz:0},
	
	{x:-8342,  z:12594,  range:10000, minradius:2500, kx:0, kz:0},
	{x:-14837,  z:41,    range:10000, minradius:2500, kx:0, kz:0},
	{x:-6445,  z:-19452, range:10000, minradius:2500, kx:0, kz:0},
	
	{x:-42800,  z:-4548, range:10000, minradius:2500, kx:0, kz:0},
	{x:-2445,  z:-49452, range:10000, minradius:2500, kx:0, kz:0},
];



let PLANET_GRAVITY = 0;

/*
let PLANETS = [];
for(let i = 0; i < 2; i++){
	PLANETS.push({
		x: (Math.random()-0.5)*10000, 
		y: (Math.random()-0.5)*10000, 
		range: 10000, 
		minradius: 2500,
	});
}
*/


var GRAVITY = GRAVITY_DEFAULT;

let WATER_ENABLED = false;
let WATER_Y = 0; // the water level y coordinate for water surface.

//let mapscale = {x: 7, y: 7, z: 7};
let mapscale = {x: 1, y: 1, z: 1};

function map_path(filename){
	return MAP_FOLDER+"/"+filename;
}

function root_path(filename){
	return filename;
}



function get_constant(str){
	return str.toLowerCase().trim();
}

function get_boolean(val){
	return val ? true : false;
}

function get_float(val){
	if(typeof val === "number"){
		return val;
	}else if(typeof val === "string"){
		let ret = parseFloat(val.replaceAll(",", "."));
		if(ret !== ret){ // true if value is "NaN"
			console.error("Invalid number for value '"+val+"'.");
			return 0;
		}else{
			return ret;
		}
	}else{
		console.error("Invalid type '"+(typeof val)+"' for value '"+val+"'. Should be a number.");
		return 0;
	}
}



function texture_path(name){
	return urlprefix+TEXTURES[name].path;
}


let default_texture_config = {
	// stuff like linear filter, repeat, offset... etc.
};


// default textures, can be overridden by map and mod.
var TEXTURES = {
	'splash_sprite_url': 		{path: 'sprites/splash.png', 
								config: default_texture_config},
								
	'glowsprite_url': 			{path: 'sprites/glow2b.png', 
								config: default_texture_config},
								
	'map_bg_parallax_url':		{path: 'maps/parallax.png', 
								config: default_texture_config},
								
	'santa_sprite_url': 		{path: "sprites/SantaSleigh.png", 
								config: default_texture_config},
								
	'santa_lights_sprite_url': 	{path: "sprites/SantaSleigh-lights3c.png", 
								config: default_texture_config},
								
	'plane_sprite_url': 		{path: "sprites/complane/texture-1024.webp", 
								config: default_texture_config},
								
	'plane_normalmap': 			{path: "sprites/complane/normalmap-1024-blur.png", 
								config: default_texture_config},
								
	'plane_lights_sprite_url': 	{path: "sprites/--airplane_lights.png", 
								config: default_texture_config},
								
	'helicopter_texture': 		{path: "sprites/helicopter/texture-1024.webp", 
								config: default_texture_config},
								
	'helicopter_normalmap':     {path: "sprites/helicopter/normalmap-1024.webp", 
								config: default_texture_config},
								
	'helicopter_lights_sprite_url': {path: "sprites/---helicopter_2x-lights.png", 
								config: default_texture_config},
								
	'ufo_texture': 	        	{path: "sprites/ufo/texture.png", 
								config: default_texture_config},
								
	'ufo_normalmap':            {path: "sprites/ufo/normalmap.png", 
								config: default_texture_config},
								
	'ufo_lights': 			    {path: "sprites/---lights.png", 
								config: default_texture_config},
								
	'bomber_sprite_url': 		{path: 'sprites/bomber_c47_2x.png', 
								config: default_texture_config},
								
	'bomber_lights_sprite_url': {path: 'sprites/bomber_c47_2x-lights2.png', 
								config: default_texture_config},
								
	'fighters_url': 			{path: "sprites/fighter_planes.png", 
								config: default_texture_config},
								
	'map_water_url': 			{path: 'textures/water2.jpg', 
								config: default_texture_config},
								
	'map_waterdrops_url': 		{path: 'textures/raindrop-ripples-oneliner2.png', 
								config: default_texture_config},
								
	'clouds_back_url': 			{path: "textures/clouds/cloud-bg.jpg", 
								config: default_texture_config},
								
	'clouds_front_url': 		{path: 'textures/clouds/cloud-layer.png', 
								config: default_texture_config},
								
	'nightsky_url': 			{path: "textures/stars/stars.png", 
								config: default_texture_config},
								
	'map_rainfall_url': 		{path: 'textures/rainfall.png', 
								config: default_texture_config},

	///////////////////////
	// todo: remove and load from map.json
	
	'collision': 				{path: '', 
								config: default_texture_config},
								
	'map_behind_url': 			{path: '', 
								config: default_texture_config},
								
	'map_behind_lights_url': 	{path: '', 
								config: default_texture_config},
								
	'map_front_url': 			{path: '', 
								config: default_texture_config},
	//////////////////////					


	'explosion_sprites_url': 	{path: 'sprites/explosions-big1.png', 
								config: default_texture_config},
								
	'explosion_round': 			{path: 'sprites/explosion_round.png', 
								config: default_texture_config},
								
	'explosion_round_laser': 	{path: 'sprites/explosion_round_laser.png', 
								config: default_texture_config},
								
	'explosion_round_small':	{path: 'sprites/explosion_round_small.png', 
								config: default_texture_config},
								
	'bombs_sprite_url': 		{path: 'sprites/bomb.png', 
								config: default_texture_config},
								
	'shots_sprite_url': 		{path: 'sprites/shot2.png', 
								config: default_texture_config},
								
	'shots_lights_sprite_url': 	{path: 'sprites/shot2-lights.png', 
								config: default_texture_config},
								
	'stream_sprite_url': 		{path: 'sprites/stream.png', 
								config: default_texture_config},
								
	'turret_sprite_url': 		{path: 'sprites/turrets_3x.png', 
								config: default_texture_config},
								
	'mario_sprite_url': 		{path: 'sprites/mario_3x.png', 
								config: default_texture_config},
								
	'soldier_sprite_url': 		{path: 'sprites/soldier-3x.png', 
								config: default_texture_config},
};



// frames are order from the beginning. must be converted to sprite sheet coordinate.
// NOTE: frames start from 1 ! 
var SPRITES = {
	'soldier': {
		/*
		added at initialize_sprite:
		sprite['w'] = w;
		sprite['h'] = h;
		sprite['sheet_w'] = sheet_w;
		sprite['sheet_h'] = sheet_h;
		sprite['frames_x'] = frames_x; // total frames horizontally in the sheet.
		sprite['anims_coords'] = {}; // calculated texcoords.
		*/
		'anims': {
			'stand_idle':   ranged(1), // 31 identical
			'jump_start':   ranged(2, 4),
			'jump_spin':    ranged(5, 8),
			'jump_land':    ranged(9, 11),
			'running':      ranged(12, 17),
			'stand_prone':  ranged(18, 25),
			'crouch_prone': ranged(20, 25),
			'crouch_idle':  ranged(21),
			'prone_idle':   ranged(25),
			'prone_shoot':  ranged(26, 30),
			'stand_shoot':  ranged(32, 37),
			'crouch_shoot': ranged(38, 43),
			'swim_idle':    ranged(44, 55),
			'swim_slow':    ranged(56, 61),
			'swim_fast':    ranged(62, 69),
			'dead':         ranged(70),
			'standing':     ranged(71),
			'floating':     ranged(72),
			'dive_start':   ranged(73, 77),
			'basic_swim':   ranged(78, 86),
			'sit':          ranged(87),
			'shit':         ranged(88),
		},
	},
	// each key is initialized at the image loader.
	// = each key handles one image texture coords.
	'turret': {
		'anims': {
			// antiair:
			'aa_idle':       ranged(1),
			'aa_dead':       ranged(2),
			'aa_barrel':     ranged(3),
			'bomber_idle':   ranged(5),
			'bomber_dead':   ranged(6),
			'bomber_barrel': ranged(7),
			
			// ground turret:
			// ?
		},
	},
	'mario': {
		'anims': {
			'stand_idle':  ranged(1),
			'walk': ranged_bounce(1, 3),
		},
	},
	// NOTE: frames starts from 1 !
	'santa_sleigh': {
		'anims': {
			'moving': ranged(1, 22),
		},
	},
	'plane_spin': {
		'maxframes': 30,
		'anims': {
			'spin_to_down': ranged(1, 15),
			'spin_to_up':   ranged(15, 30),
			
			'to_90':  ranged(1, 8),
			'to_180': ranged(8, 15),
			'to_270': ranged(15, 23),
			'to_360': ranged(23, 30),
		},
	},
	'heli_spin': {
		'maxframes': 31,
		'anims': {
			'to_90':    ranged(1, 15),
			'to_180':   ranged(15, 31),
			'from_180': ranged(31, 15),
			'from_90':  ranged(15, 1),
		},
	},
	'ufo_spin': {
		'maxframes': 84,
		'anims': {
			'spin': ranged(1, 84),
		},
	},
};


// creates repetitive array from (1,4) = [1,2,3,4,3,2]
function ranged_bounce(from, to){
	if(typeof to === "undefined"){
		return [from]; // for easier code editing; no need to change function if just one frame.
	}
	let a1 = ranged(from, to);
	let a2 = ranged(from, to);
	a2.pop();
	a2.reverse();
	a2.pop();
	return a1.concat(a2);
}

function ranged(from, to, multi){
	if(typeof to === "undefined"){
		return [from]; // for easier code editing; no need to remove function if just one frame.
	}
	let out = [];
	if(typeof multi !== "undefined"){
		if(from < to){
			for(let i = from; i <= to; i++) out.push(i*multi);
		}else{
			for(let i = from; i >= to; i--) out.push(i*multi);
		}
	}else{
		if(from < to){
			for(let i = from; i <= to; i++) out.push(i);
		}else{
			for(let i = from; i >= to; i--) out.push(i);
		}
	}
	return out;
}



// todo: use this for ALL animations.
let ANIMATION_DATA = [];
let ANIMATIONS = {}; // links to ANIMATION_DATA elements


// todo: use this for ALL animations.
function add_animation_sequence(sprite_name, animations, speed, animation_switch_callback){
	ANIMATION_DATA.push({
		'frameIndex': 0,
		'animationIndex': 0,
		'sprite_name': sprite_name,
		'animations': animations,
		'speedAdd': speed,
		'animation_switch_callback': animation_switch_callback,
	});
	return ANIMATION_DATA[ANIMATION_DATA.length-1];
}

// todo: use this for ALL animations.
function get_animation_coords(animation_sequence_name){

	let anim = ANIMATIONS[animation_sequence_name];

	anim.frameIndex += anim.speedAdd;
	
	let animation_name = anim.animations[anim.animationIndex];
	
	let anim_frames = SPRITES[anim.sprite_name]['anims'][animation_name].length;

	if(anim.frameIndex >= anim_frames){
		if(anim.animations.length > 1){
			// if ran out of frames, set ready to continue from next animation:
			anim.frameIndex = 0;
			
			anim.animationIndex++;
			if(anim.animationIndex > anim.animations.length-1){
				anim.animationIndex = 0;
			}
				
			anim.animation_switch_callback();
			
			animation_name = anim.animations[anim.animationIndex];
		}else{
			// cut the frame index to start with offset, if its too large:
			anim.frameIndex = anim.frameIndex - Math.floor(anim.frameIndex/anim_frames)*anim_frames;
		}
	}

	return frame_offset(anim.sprite_name, animation_name, Math.floor(anim.frameIndex));
}


// returns frame coordinate from sprite index: (only works left to right, top to bottom).
function get_xy(pos, w, h, frames_x){
	let xf = pos % frames_x;
	let yf = Math.floor(pos/frames_x);
	this.x = xf*w;
	this.y = yf*h;
}



// returns frame offset as texture coordinates:
// get_frame get_animation_frame
function frame_offset(spriteName, animName, frameIndex){
	if(typeof SPRITES[spriteName] === "undefined"){
		console.log("UNKNOWN sprite['"+spriteName+"']");
		return {x:-1,y:-1};
	}else if(typeof SPRITES[spriteName]['anims_coords'][animName] === "undefined"){
		console.log("UNKNOWN sprite['"+spriteName+"']['"+animName+"']");
		return {x:-1,y:-1};
	}else if(typeof SPRITES[spriteName]['anims_coords'][animName][frameIndex] === "undefined"){
		console.log("UNKNOWN sprite['"+spriteName+"']['"+animName+"']["+frameIndex+"]");
		return {x:-1,y:-1};
	}else{
		return SPRITES[spriteName]['anims_coords'][animName][frameIndex]; // {x,y}
	}
}



function initialize_sprite(spriteName, w, h, sheet_w, sheet_h, frames_x){
	let sprite = SPRITES[spriteName];
	// add new values:
	sprite['w'] = w;
	sprite['h'] = h;
	sprite['sheet_w'] = sheet_w;
	sprite['sheet_h'] = sheet_h;
	sprite['frames_x'] = frames_x; // total frames horizontally in the sheet.
	sprite['anims_coords'] = {};

	let spriteAnims = sprite.anims;
	for(var animName in spriteAnims) {
		if(spriteAnims.hasOwnProperty(animName)){
			let anim = spriteAnims[animName];
			sprite['anims_coords'][animName] = [];
			for(let i = 0; i < anim.length; i++){
				// index starts from 1, so -1:
				let pos = new get_xy(anim[i]-1, w, h, frames_x);
				sprite['anims_coords'][animName].push({
					x: pos.x/sheet_w, // translate to texture coordinates offset values
					y: pos.y/sheet_h,
				});
			}
		}
	}
}




/*
function cache_all_sprite_anims(){
	for(var spriteName in SPRITES){
		if(SPRITES.hasOwnProperty(spriteName)){
			let sprite = SPRITES[spriteName];
			if(!sprite.hasOwnProperty('anims_coords')){
				sprite['anims_coords'] = [];
			}
			let spriteAnims = sprite.anims;
			for(var animName in spriteAnims) {
				if(spriteAnims.hasOwnProperty(animName)){
					let anim = spriteAnims[animName];
					if(!sprite['anims_coords'].hasOwnProperty(animName)){
						sprite['anims_coords'][animName] = [];
					}
					for(let i = 0; i < anim.length; i++){
						let pos = new get_xy(anim[i], sprite.w, sprite.h, sprite.frames_x);
						sprite['anims_coords'][animName].push(pos);
					}
				}
			}
		}
	}
	console.log(SPRITES);
}
*/

function is_underwater(obj){
	if(WATER_ENABLED){
		return (obj.z > WATER_Y);
	}else{
		return false;
	}
}



// checks if xy coord on map is ground or not
// hits_ground
function is_ground(x,z){
	//x = x/mapscale.x;
	//z = z/mapscale.z;
	
	let datalist = COLLISION_DATA['MAP_DATA'];
	
	for(let i = 0; i < datalist.length; i++){
		let collisiondata = datalist[i];
		let data = collisiondata.data;
		let offset_x = collisiondata.x;
		let offset_z = collisiondata.z;
		let w = collisiondata.w;
		let h = collisiondata.h;

		let dx = Math.round(x-offset_x+w/2);
		let dz = Math.round(z-offset_z+h/2);
		
		if(dx >= 0 && dx < w && dz >= 0 && dz < h){
			if(data[dz*w+dx] > 40){ // if over 40 opacity; then ground.
				return true;
			}
		}
	}

	return false;
}






var skyboxColor = 0xFFFFFF;
var skyboxColorRain = 0xDDDDDD;

var cloudsColor = 0xFFFFFF;
var cloudsColorRain = 0x444444;


var rainMaxOpacity = 0.7; // values greater than 1 possible.
var raindropsMaxOpacity = 1; // values greater than 1 possible.

var nightskyMaxOpacity = 1.0;
var min_ambient_light = 0.25;
var max_ambient_light = 1.0;
var light_day = 0xFFFFFF;
var light_rain = 0xDDDDDD; // semi dark
var light_night = 0x6666AA; // dark but blueish
var light_sunset = 0x666622; // dark but yellowish
var light_sunset_sky = 0xFFFF00;

let light_grad_percent = 1; // 0-1 value, 1 = day, 0 = night.


var default_min_cloud_front_opa = 0.2;
var min_cloud_front_opa = default_min_cloud_front_opa;
var clouds_back_enabled = true;
var clouds_front_enabled = true;


var cloudColorFrom = cloudsColor; // will be initialized on rain switch.
var cloudColorTo = cloudsColorRain;

var skyboxColorFrom = skyboxColor; // will be initialized on rain switch.
var skyboxColorTo = skyboxColorRain;

var mapCollisionTex = null;
var mapParallaxTex = null;
var mapBehindTex = null;
var mapBehindEmissiveTex = null;
var mapFrontTex = null;

var mapWaterTex = null;
var mapWaterdropsTex = null;
var mapRainfallTex = null;

var mapCloudsFrontTex = null;
var mapCloudsBackTex = null;
var mapNightskyTex = null;






var planeTex = null;
var planeEmissiveTex = null;
var planeNormalTex = null;
var helicopterTex = null;
var helicopterEmissiveTex = null;
var helicopterNormalTex = null;
var ufoTex = null;
var ufoEmissiveTex = null;
var ufoNormalTex = null;
var santaSpriteTest = null;
var santaEmissiveTex = null;
var bomberEmissiveTex = null;
var soldierSpriteTest = null;
var explosionSpriteTest = null;
var explosionRoundTex = null;
var explosionRoundLaserTex = null;
var explosionRoundSmallTex = null;
var splashSpriteTest = null;
var glowspriteTex = null;
var bombSpriteTest = null;
var shotSpriteTest = null;
var shotlightsTex = null;
var bomberSpriteTest = null;
var turretSpriteTest = null;
var streamSpriteTest = null;




var KEYS = {};

// key_pressed
function key_down(keyCode){
	if(KEYS.hasOwnProperty(keyCode)){
		return KEYS[keyCode];
	}
	return false;
}

var CANVAS_W = 1; // debug values. initialized at init()
var CANVAS_H = 1;

var MOUSE_X = -1; // -1 = not set.
var MOUSE_Y = -1;

var MOUSE_OFFSET_X = 0;
var MOUSE_OFFSET_Y = 0;

var MOUSE_ANGLE = 0;
var MOUSE_ANGLE_DETAIL = 0;
var MOUSE_DIST = 0;

var SKYBOX_SCALE = 1.3;
var SKYBOX_REPEAT = true; // if false, then the skybox wont move at all.
var SKYBOX_DISTANCE = 10; // smaller = moves faster with camera.


let rotate_camera_to_gravity = 1;

var prevBombTime = 0;
var bombStartTime = 0;
var bombingStarted = false;

let continuous_shoot_delay = 300; // continuous shooting starts after this time.
let planegun_delay = 80;
let bombgun_delay = 30;

let rainSpeed = 2.24;
let waterSpeed = 0.1;

let rain_fade_speed = 0.01;
var night_fade_speed = 0.01;
var clouds_opacity = 1;

var rain_opacity = 0;
var raindrops_opacity = 0;

let ambient_light = 1;




//let GRAVITY_CONSTANT = 0.15; // was 0.06
let BUOYANCY_CONSTANT = 0.01; // force to player making him rise up from water.
// todo: shot prediction does not work with air resistance yet.

// disabled due to calculations not working.
// if enabled later, make sure to search for this variable.
let AIR_RESISTANCE = 1;//0.995; // kx multiplied by this on air.
let WATER_RESISTANCE = 0.97; // kx multiplied by this in water.


let MAX_TEX_SIZE = 0; // will be initialized at pre_init

let antialiasing = true;


var SCREEN_MID_X = 0;
var SCREEN_MID_Y = 0;


let MAP_PIECES = []; // contains textures of all pieces of map back/middle/front with file paths.

// all collideable sprites images are stored as 8bit per pixel data here for collision detection.
var COLLISION_DATA = {
	'MAP_DATA': [], // array of map pieces here. {x,z,w,h,data}
	'OBJECTS': {}, // {'sprite_name': collision_data}
};


let map_defaults = {}; // default map settings which will be combined with map.json.
let mapinfo = {};
let mod_defaults = {}; // default mod settings which will be combined with mod.json.
let modinfo = {};

var OWNER_AI = -1; // ai owner id.


// player types:
var TYPE_PLANE = 0; // wind/air affected. not flipped.
var TYPE_SOLDIER = 1; // gravity/air affected. flipped in x axis when moving to other direction.
var TYPE_BOAT = 2; // water/air affected. flipped in x axis when moving to other direction.
var TYPE_SANTA = 3; // nothing affected? flipped in x axis when moving to other direction.
var TYPE_HELI = 4; // helicopter. flipped in x axis.

// player weapons:
var WEAPON_PLANEGUN = 0;
var WEAPON_SHOTGUN = 1;
var WEAPON_BOMB = 2;
var WEAPON_BOMB_LASER = 3;


let FPS = 60;

let PROJECTILE_MAX_FRAMES = 120*FPS;

// how long (player) projectiles will be alive in frames:
let SHOT_FUSETIME = 20*FPS;
let BOMB_FUSETIME = 120*FPS;
let BOMB_LASER_FUSETIME = 8*120*FPS;

// turrets fusetimes:
let TURRET_ANTIAIR_FUSETIME = 4*FPS;
let TURRET_BOMBER_FUSETIME = 3*FPS;

let TURRET_ANTIAIR_RANGE = 1200; // how far turrets can shoot by default.
let TURRET_BOMBER_RANGE = 1500;


// index = current weapon index.
var WEAPON_INFO = {};
{
	WEAPON_INFO[WEAPON_PLANEGUN] = {
		// colors from furthest to the center.
		// trajectory_mesh = middle, trajectory_mesh2-3 = edge, trajectory_mesh4-5 = edge2.
		'colors': {edge2: 0xFF0000, edge: 0xFF8800, middle: 0xFFFF00}, // for trajectory (and maybe some other stuff too).
		'visible_name': "Machinegun",
		'fusetime': SHOT_FUSETIME, // these not used here atm.
	};

	WEAPON_INFO[WEAPON_SHOTGUN] = {
		'colors': {edge2: 0xFF0000, edge: 0x006600, middle: 0xFFFFFF},
		'visible_name': "Shotgun",
		'fusetime': SHOT_FUSETIME, // these not used here atm.
	};

	WEAPON_INFO[WEAPON_BOMB] = {
		'colors': {edge2: 0xFF0000, edge: 0xFF0000, middle: 0xFFFF00},
		'visible_name': "Bomb",
		'fusetime': BOMB_FUSETIME, // these not used here atm.
	};

	WEAPON_INFO[WEAPON_BOMB_LASER] = {
		'colors': {edge2: 0xFF0000, edge: 0xFF00FF, middle: 0xFFFFFF},
		//'colors': {edge2: 0xFF0000, edge: 0xFF8800, middle: 0xFFFF00}, // bomb_laser
		'visible_name': "Wonky Laser Bomb (WLB)",
		'fusetime': BOMB_LASER_FUSETIME, // these not used here atm.
	};
}


// explosion types:
var EXPLOSION_ROUND = 0; // generic explosion anywhere since its circular shape.
var EXPLOSION_FLAT = 1; // explosion for buildings etc that are on flat surface.
var EXPLOSION_ROUND_SMALL = 2;
var EXPLOSION_ROUND_LASER = 3;

// explosion sizes:
var EXPLOSION_TINY = 0;
var EXPLOSION_SMALL = 1;
var EXPLOSION_MEDIUM = 2;
var EXPLOSION_LARGE = 3; // explosion_big
var EXPLOSION_HUGE = 4;
var EXPLOSION_HUGE2 = 5;
var EXPLOSION_HUGE3 = 6;
var EXPLOSION_SHOTGUN = 7;

// splash sizes:
var SPLASH_TINY = 0;
var SPLASH_SMALL = 1;
var SPLASH_MEDIUM = 2;
var SPLASH_LARGE = 3;
var SPLASH_HUGE = 4;
var SPLASH_HUGE2 = 5;


// bomber plane types:
var PLANE_BOMBER = 0;
var PLANE_HORNET = 1;
var PLANE_UFO = 2;


// turret types:
var TURRET_ANTIAIR = 0; // turret shooting airplanes.
var TURRET_BOMBER = 1; // shooting bombs.
var TURRET_GROUND = 2; // turret shooting ground units.






var gameLoadedVar = false;

// list of things loaded or not. game wont start until all are loaded.
var loaded = {
	mod_settings: false,
	map_settings: false,
	glowsprite: false,
	nightsky: false,
	/*
	map: false,
	map_bg: false,
	map_behind: false,
	map_behind_lights: false,
	map_front: false,
	*/
	santa: false,
	santa_lights: false,
	plane: false,
	plane_lights: false,
	plane_normalmap: false,
	clouds_back: false,
	clouds_front: false,
	rain: false,
	water: false,
	waterdrops: false,
	explosions: false,
	explosion_round: false,
	explosion_round_laser: false,
	explosion_round_small: false,
	bombs: false,
	splashes: false,
	shots: false,
	shots_lights: false,
	bomber: false,
	stream: false,
	turret: false,
	soldier: false,
	helicopter: false,
	helicopter_lights: false,
	helicopter_normalmap: false,
	ufo: false,
	ufo_lights: false,
	ufo_normalmap: false,
};










	
function rescale_skybox(){
	if(!loaded.nightsky){
		return; // dont do anything if texture is not loaded.
	}
	
	let aspect = CANVAS_W/CANVAS_H;
	if(SKYBOX_REPEAT){
		mapNightskyTex.repeat.x = SKYBOX_SCALE*aspect;
		mapNightskyTex.repeat.y = SKYBOX_SCALE;
	}else{
		let ww = CANVAS_W;
		let hh = CANVAS_H;
		
		let w = mapNightskyTex.image.width;
		let h = mapNightskyTex.image.height;

		let aa = ww/hh;
		let a =  w/h;
		
		/*
		    __________
		    |   a    |
		____|________|____
		|   | ______ |   |
		| a | | aa | | a |
		|   | |____| |   |
		|___|________|___|
		    |   a    |
			|________|
		*/
		
		let sx = 1;
		let sy = 1;
		
		mapNightskyTex.repeat.x = sx;
		mapNightskyTex.repeat.y = sy;
	}
}




var rainfallMesh = null;
var behindMeshes = [];
var collisionMeshes = [];

var behindMeshesData = [];
var collisionMeshesData = [];

var cloudsFrontMesh = null;
var cloudsBackMesh = null;
var nightskyMesh = null;

var waterDownBack = null;
var waterDownFront = null;
var waterdropsMesh = null;


var mapMeshFlipped = null;

let sprites = {};
let spriteData = {};
let animations = {};




var controls, camera, scene, renderer;

var guivisible = 0;

// constants:
var fadetime = 2.0; // fadetime in secs to red color when time is up.
var gameMaxTimeSecs = fadetime; // in secs. should be same as fadetime.
var countdownTimeMax = 8; // in secs time to show the endscores.



var crystalCount = 80;


var defaultBoostTime = 1000000; // for players.


var framesPerFps = 20; // interval of frames how often fps is updated.

var mapsize = 10000;
var terrainVerts = 128;

// map playable area size; min/max = -w/2 to w/2 etc. will be initialized later.
// todo: make x1,y1,x2,y2 coordinates here instead.
var MAP_W = 8192;
var MAP_H = 8192;

let MAP_X1 = -MAP_W/2;
let MAP_X2 = MAP_W/2;
let MAP_Y1 = -MAP_H/2;
let MAP_Y2 = MAP_H/2;


let teleport_from_edges_x = true;
let teleport_from_edges_y = false;

let DEV_MODE = 0;
let MAX_DEV_MODE = 3;


let edgePadX = 0; // padding areas after which player would teleport
let edgePadY = 0;




// state vars:
var countdownTimeStart = -1;

var myPlayer = 0;
let santaPlayer = 0;
let soldierPlayer = 0;

var gameStartTime = -1;

var gameEnding = false;
var gameEnded = false; // someone won now.
var prevEndingState = -1;




var players = [];

var lights = [];
var bombs = [];
var shots = [];
var explosions = [];
var splashes = [];
var bombers = [];
var turrets = []; // can be antiair or regular turret.
var visuals = []; // glow sprites etc... works same way as explosions basically.




var prevFpsTime = 0;

var ambient;
var light1;
var terrain;


var cameraCube, sceneCube;
var textureCube;
var texturePlayerCube;
var textureSpaceCube;
var textureCrystalCube;

let reflectionMap;
let reflectionCube;






function getTimeMillis(){
	var d = new Date();
	return d.getTime();
}







function get_dist_2d(p1x, p1y, p2x, p2y){
	return Math.sqrt((p2x-p1x)*(p2x-p1x)+(p2y-p1y)*(p2y-p1y));
}


function point_inside_circle(px, py, cx, cy, radius){
	return (get_dist_2d(px, py, cx, cy) < radius);
}


function point_inside_rect(x, y,  x1, y1, x2, y2){
	if(x < x1) return false;
	if(x > x2) return false;
	if(y < y1) return false;
	if(y > y2) return false;
	return true;
}


// transfer of masses between balls:
// https://stackoverflow.com/questions/60727534/balls-bouncing-off-of-each-other
// 

// other algorith:
//https://stackoverflow.com/questions/57891494/how-to-calculate-intersection-point-of-a-line-on-a-circle-using-p5-js

//
// https://cscheng.info/2016/06/09/calculate-circle-line-intersection-with-javascript-and-p5js.html
function findCircleLineIntersections(r, h, k, m, n) {
	// circle: (x - h)^2 + (y - k)^2 = r^2
	// line: y = m * x + n
	// r: circle radius
	// h: x value of circle centre
	// k: y value of circle centre
	// m: slope
	// n: y-intercept

	// get a, b, c values
	var a = 1 + m*m;
	var b = -h*2 + (m*(n-k))*2;
	var c = h*h + (n-k)*(n-k) - r*r;

	// get discriminant
	var d = b*b - 4*a*c;
	if(d >= 0){
		// insert into quadratic formula
		var intersections = [
			(-b + Math.sqrt(b*b - 4*a*c)) / (2*a),
			(-b - Math.sqrt(b*b - 4*a*c)) / (2*a)
		];
		if(d == 0){
			// only 1 intersection
			return [intersections[0]];
		}
		return intersections;
	}
	// no intersection
	return [];
}


// radtodeg get_degs
function rad2deg(rad){
	return 180-rad*(180.0/Math.PI);
}

// degtorad() get_rads
function deg2rad(deg){
	return deg*(Math.PI/180);
}



function get_kxy_angle(angle){
	this.x = Math.sin((angle-90.0)*(Math.PI/180.0));
	this.z = Math.cos((angle-90.0)*(Math.PI/180.0));
}
function get_kxy_angle_rads(rads){
	this.x = Math.sin(rads);
	this.z = Math.cos(rads);
}



function get_kxy(from_x, from_y, to_x, to_y){
	let angle = (Math.atan2(to_y-from_y, from_x-to_x)/Math.PI)*180.0;
	this.x = Math.sin((angle-90.0)*(Math.PI/180.0));
	this.z = Math.cos((angle-90.0)*(Math.PI/180.0));
}
function get_kxy_rads(from_x, from_y, to_x, to_y){
	let rads = Math.atan2(to_y-from_y, from_x-to_x);
	this.x = Math.sin(rads);
	this.z = Math.cos(rads);
}


function get_angle(from_x, from_y, to_x, to_y){
	return (Math.atan2(to_y-from_y, from_x-to_x)/Math.PI)*180.0;
}
function get_angle_rads(from_x, from_y, to_x, to_y){
	return Math.atan2(to_y-from_y, from_x-to_x);
}





function randomColor(){
	var ran = Math.floor(Math.random()*colorList.length);
	this.color = colorList[ran];
	this.colorHtml = colorListHtml[ran];
}



function randomNick(){
	return randomWords[Math.floor(Math.random()*randomWords.length)];
}



function random_str(len){
	let out = "";
	for(let i = 0; i < len; i++){
		out += alphanumeric[Math.floor(Math.random()*alphanumeric.length)];
	}
	return out;
}

function randomVersion(){
	return "?v="+random_str(20);
}


function show_messages(){
	$("#messages_container").show();
}





function push_message(message, flash_message, time_visible){
	if(typeof flash_message === "undefined"){
		flash_message = false;
	}
	if(typeof time_visible === "undefined"){
		time_visible = 5000;
	}
	let flashClass = flash_message ? " flash" : "";

	let elem = "#messages_container";
	// stop fadeout animation and set to full opacity:
	if($(elem).is(':animated')) {
		//$(elem).stop().animate({opacity:'100'});
	}else{
		//$(elem).show();
	}
	//$(elem).show();
	//$("#messages_container").show();
	let msg_id = "msg_"+random_str(10);
	  
	$(elem).append($('<div class="message_line" id="'+msg_id+'"></div>').html($('<span class="message'+flashClass+'"></span>').text(message)));
	$(elem).animate({ scrollTop: $(elem).prop("scrollHeight")}, 0);
	//$(elem).fadeOut(3000);
	
	// if -1 as time, then never remove it.
	if(time_visible >= 0){
		setTimeout(function(){$("#"+msg_id).remove();}, time_visible);
	}
	
	
	//$(elem).scrollTop($(elem).prop("scrollHeight"));
	
}




function set_loading_desc(text){
	$("#loading_desc").text(text);
	console.log("LOADER: "+text);
	
	push_message("LOADER: "+text);
}

pre_init();
animate();




function sort_by_score(a, b){
	if (a.score < b.score) return 1;
	if (a.score > b.score) return -1;
	return 0;
}




function updateInfo(){
	let curplayer = players[myPlayer];
	$('#player-x').html(curplayer.x.toFixed(1));
	// y position is changed depending on lane.
	$('#player-y').html(curplayer.mesh.position.y.toFixed(1));
	$('#player-z').html(curplayer.z.toFixed(1));
	$('#player-angle').html(curplayer.angle.toFixed(1));
	$('#player-shoot-angle').html(curplayer.shoot_angle.toFixed(8));
}



// set_speed
function setSpeed(i, speed){
	if(speed < 0) speed = 0;
	if(speed > 150) speed = 150;
	
	players[i].internal_speed = speed;
	let real_speed = Math.sqrt(speed*speed*5)/10;
	players[i].speed = real_speed;
}

// set_angle
function setAngle(i, angle){
	players[i].angle = angle;
}

// setshootingangle
function setShootAngle(i){
	let angle = (MOUSE_ANGLE+MOUSE_ANGLE_DETAIL) + 180-rad2deg(camera.rotation.z);
	players[i].shoot_angle = angle;
}











function resetVars(){
	countdownTimeStart = -1;

	gameStartTime = -1;
	
	gameEnding = false;
	gameEnded = false; // someone won now.
	prevEndingState = -1;


}




function add_player(mesh, type){
	if(typeof type === "undefined"){
		type = TYPE_PLANE;
	}
	let owner = players.length;
	var weapons1 = [
		WEAPON_PLANEGUN,
		WEAPON_SHOTGUN,
		WEAPON_BOMB,
		WEAPON_BOMB_LASER,
	];
	var weapons2 = [
		WEAPON_BOMB,
		WEAPON_PLANEGUN,
	];
	let current1 = 3;
	let current2 = 0;
	
	let weaponinfo = WEAPON_INFO[weapons1[current1]];
	let weapon_colors = weaponinfo.colors;
	
	// "leftest"
	let trajectory_mesh4 = create_trajectory_mesh(weapon_colors.edge2);
	trajectory_mesh4.visible = false; // hide before using it.
	trajectory_mesh4.frustumCulled = false;
	
	// "left"
	let trajectory_mesh2 = create_trajectory_mesh(weapon_colors.edge);
	trajectory_mesh2.visible = false; // hide before using it.
	trajectory_mesh2.frustumCulled = false;

	// middle
	let trajectory_mesh = create_trajectory_mesh(weapon_colors.middle);
	trajectory_mesh.visible = false; // hide before using it.
	trajectory_mesh.frustumCulled = false;
	
	// "right"
	let trajectory_mesh3 = create_trajectory_mesh(weapon_colors.edge);
	trajectory_mesh3.visible = false; // hide before using it.
	trajectory_mesh3.frustumCulled = false;
	
	// "rightest"
	let trajectory_mesh5 = create_trajectory_mesh(weapon_colors.edge2);
	trajectory_mesh5.visible = false; // hide before using it.
	trajectory_mesh5.frustumCulled = false;
	
	// the order of these will matter rendering.
	scene.add(trajectory_mesh4);
	scene.add(trajectory_mesh2);
	
	scene.add(trajectory_mesh3);
	scene.add(trajectory_mesh5);
	scene.add(trajectory_mesh);
	
	players.push({
		'nick': randomNick(),
		'color': "#FFFFFF",
		'mesh': mesh, // includes our position also.
		'angle': 0,
		'shoot_angle': 0,
		'speed': 0,
		'speed_x': 0, // used for helicopters etc.
		'speed_z': 0,
		'internal_speed': 0,
		'shot_speed_multi': 1,
		'score': 0,
		'boostTime': defaultBoostTime, // each frame takes 10 amount of boost. 1 is gained each frame.
		'boost': false, // if true, then boost is enabled.
		
		'kx': 0, // unused
		'kz': 0, // unused
		
		'x': mesh.position.x,
		'y': mesh.position.y,
		'z': mesh.position.z,
		
		'y_offset': randomized_y(0),
		'trajectory_mesh': trajectory_mesh,
		'trajectory_mesh2': trajectory_mesh2,
		'trajectory_mesh3': trajectory_mesh3,
		'trajectory_mesh4': trajectory_mesh4,
		'trajectory_mesh5': trajectory_mesh5,
		
		'lane': 0, // -1, 0, 1 possible.
		'ammo': 1000000,
		'bombs': 1000000,
		'fuel': 1000000,
		'type': type, // 0 = TYPE_PLANE, 1 = TYPE_SOLDIER, 2 = TYPE_BOAT, 2 = TYPE_SANTA
		'underwater': false,
		'hit_time': -1,
		'health': 1000,
		'alive': true,
		'owner': owner,
		// primary weapons:
		'weapons1': weapons1, // list of weapons used by click (machinegun etc).
		'current1': current1, // current selected weapon from that list.
		// secondary weapons:
		'weapons2': weapons2, // list of weapons used by space (bombs etc).
		'current2': current2,
	});
	
	console.log("mesh.position.y: "+mesh.position.y);
	return players.length-1;
}









var SOUNDS = {
	// sounds last element is sound volume.

	//plane_flip:       [1,1,0,0.234,0.343,0.504,0.296,0,-0.241009,0,0.267,0.07778,0,0,0.365,0,0.718354,0,0,1,0,0,0,0,0.332],
	plane_flip: [1,3,0.164,0.243,0,0.383,0.358,0,0.249,-0.035681,0.049863,0.004714,-0.081,-0.007549,1,-0.05378,1,-0.377,-0.07,1.040697,-0.011889,0.015896,0.116385,0.030281,0.176],
	explosion_plane:  [1,3,0,0.354736,0.590014,0.775,0.074,0,0,0,0,0,0.295512,0.676919,0,0,0,0.176156,-0.054911,1,0,0,0,0,0.1068],
	explosion_bomb:   [1,3,0,0.287594,0.51717,0.855,0.117312,0,0,0,0.652,0.66,0,0,0,0,0,-0.146964,-0.004699,    1,0,0,0,0,0.25],
	//exp_2:          [1,3,0,0.287594,0.51717,0.855,0.117312,0,0,0,0.652,0.66,0,0,0,0,0,-0.146964,-0.004699,0.214,0,0,0,0,0.25],
					  
	explosion_bullet: [1,3,0,0.209,0.389,0.58,0.117312,0,0,0,0.652,0.66,0,0,0,0,0,-0.146964,-0.004699,0.717,-0.057,0,0,0,0.15],
	shotgun_bullet:   [1,3,0,0.017927,0,0.445,0.482781,0,-0.312528,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0.033],
	plane_machinegun: [1,3,0,0.373,0.413,0.521,0.078499,0,0.069127,0,0,0,0,0,0,0,0,-0.202749,-0.23743,0.883,-0.237,0,0,0,0.18],
	antiair_gun:      [1,3,0,0.294,0.355,0.494,0.053,0,0.192,0,0,0,0,0,0,0,0,-0.202749,-0.23743,0.883,-0.237,0,0,0,0.13],
	//superspeed:       [1,3,0,0.37668,0.751589,0.93,0.078499,0,0.069127,0,0,0,0,0,0,0,0,-0.202749,-0.23743,1,0,0,0,0,0.1068],
	bomb_drop:        [1,1,0,0.291667,0,1,0.898,0,-0.094,-0.066,0,0,0,0,0.26295,0,0,0,0,1,0,0,0,0,0.031068],
	bomb_splash:      [1,3,0,0.210467,0,0.554,0.279,0,0.167627,0,0,0,0,0,0.187778,0,0,0,0,1,0,0,0,0,0.107],
	plane_splash:     [1,3,0,0.538,0.365,0.68,0.194,0,0.167627,0,0,0,0,0,0.187778,0,0,0,0,1,0,0,0,0,0.113],
	bullet_splash:    [1,3,0,0.12,0,0.437,0.279,0,0.167627,0,0,0,0,0,0.187778,0,0,0,0,1,0,0,0,0,0.107],
	shotgun_splash:   [1,3,0,0.12,0,0.437,0.279,0,0.167627,0,0,0,0,0,0.187778,0,0,0,0,1,0,0,0,0,0.025],
	/*
	epic_shot: [1,3,0,0.287594,0.242,0.971,0.87,0,-0.567,-0.519,0.652,0.66,-0.46,0,0,0,0.545,0.509,-0.236,1,-0.46,0.653,0,0.214,0.25],
	weird: [1,0,0.010329,0.368026,0.267228,0.399649,0.167153,0,0.14828,0.107487,0.352807,-0.240237,-0.039997,-0.01731,0.78035,0.001718,-0.427861,-0.085225,0.305644,0.838106,-0.080457,0.031704,-0.174818,-0.016129,0.414],
	*/
	
	//////////
	// one-dimensional sounds only: no distance adjustments at all:
	// must start with underscore.
	_blip: [1,1,0,0.005078,0.532665,0.439482,0.614439,0,0,0,0,0,0.554557,0.53357,0,0,0,0,0,1,0,0,0,0,0.1068],
	_blip2: [1,1,0,0.084824,0.429053,0.351,0.391,0,0,0,0,0,-0.355,0.455,0,0,0,0,0,1,0,0,0,0,0.1081],
	//_morse_beep_long: [1,1,0,0.431,0,0.177,0.529172,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0.1,0,0.1068],
	//_morse_beep_long_failure: [1,1,-0.058058,0.431,-0.030879,0.196496,0.529172,0,-0.056779,-0.035681,0.049863,0.004714,0.005416,-0.007549,1,-0.05378,0.012392,-0.0199,-0.028047,1.040697,-0.011889,0.015896,0.116385,0.030281,0.1068],
	//_morse_beep_short: [1,1,0,0.286,0,0.177,0.529172,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0.1,0,0.1068],
};






function uint32_to_array(val){
	let uint32val = (val >>> 0); // just in case convert to uint32
	return [
		uint32val & 255, 
		(uint32val >> 8) & 255, 
		(uint32val >> 16) & 255, 
		(uint32val >> 24) & 255, 
	];
}

function array_to_uint32(arr){
	return (arr[0] | (arr[1] << 8) | (arr[2] << 16) | (arr[3] << 24)) >>> 0;
}





function download_canvas(canvas, filename){
	if(typeof filename === "undefined"){
		filename = random_str(20)+".png";
	}
	canvas.toBlob(function(blob){
		saveAs(blob, filename);
	});
}



function download_all_sounds(){

	function download(data, filename, type){
		// binary: "application/octet-stream"
		// text: "text/plain"
		// png: "image/png"
		var file = new Blob([data], {type: type});
		if(window.navigator.msSaveOrOpenBlob){ // IE10+
			window.navigator.msSaveOrOpenBlob(file, filename);
		}else{ // Others
			var a = document.createElement("a"), url = URL.createObjectURL(file);
			a.href = url;
			a.download = filename;
			document.body.appendChild(a);
			a.click();
			setTimeout(function(){
				document.body.removeChild(a);
				window.URL.revokeObjectURL(url);
			}, 0);
		}
	}
	
	let plaindata = [];
	
	for(let soundName in CACHED_SOUND_EFFECTS){
		let sound = CACHED_SOUND_EFFECTS[soundName].sound;
		// store soundname length and soundname string:
		let soundname_arr = uint32_to_array(soundName.length);
		for(let i = 0; i < soundName.length; i++){
			soundname_arr.push(soundName.charCodeAt(i));
		}
		plaindata = plaindata.concat(soundname_arr);

		for(let i = 0; i < sound.length; i++){
			let sound_data = sound[i].wav;
			plaindata = plaindata.concat(uint32_to_array(sound_data.length).concat(sound_data));
		}
	}
	
	download(Uint8Array.from(plaindata), "cached_sounds.dat", "application/octet-stream");
}






var CACHED_SOUND_EFFECTS = {};
// max_sounds max sounds

let sounds_detail = 1;
var MAX_SOUND_ALTS; // good for without downloading sound caches.
let param_step;
let param_min_val;

if(sounds_detail == 1){
	MAX_SOUND_ALTS = 4; // good for dev mode.
	param_step = 2.8;
	param_min_val = 0.08;
}else if(sounds_detail == 2){
	MAX_SOUND_ALTS = 13; // good for without downloading sound caches.
	param_step = 1.3;
	param_min_val = 0.08;
}else if(sounds_detail == 3){
	MAX_SOUND_ALTS = 64;
	param_step = 1.05;
	param_min_val = 0.06;
}




// load_sounds loading sounds generating_sounds generating sounds
function generate_sounds(){
	let i = 1;
	for(var soundName in SOUNDS) {
		if(SOUNDS.hasOwnProperty(soundName)){
			set_loading_desc("Generating sound "+i);
			i++;
			generate_sound_caches(soundName);
		}
	}
	
	console.log("CACHED_SOUND_EFFECTS");
	console.log(CACHED_SOUND_EFFECTS);
}


function generate_sound_caches(soundName){
	let newPARAMS = SOUNDS[soundName];
	
	if(newPARAMS[0] != 1){
		console.log("unknown sound version '"+newPARAMS[0]+"'");
		console.log(newPARAMS);
		return;
	}
	
	let order = ['jsfxr_version', 'wave_type', 'p_env_attack','p_env_sustain','p_env_punch','p_env_decay','p_base_freq','p_freq_limit','p_freq_ramp','p_freq_dramp','p_vib_strength','p_vib_speed','p_arp_mod','p_arp_speed','p_duty','p_duty_ramp','p_repeat_speed','p_pha_offset','p_pha_ramp','p_lpf_freq','p_lpf_ramp','p_lpf_resonance','p_hpf_freq','p_hpf_ramp','sound_vol'];
	
	let output = {};
	output['oldParams'] = true;
	output['sample_rate'] = 44100;
	output['sample_size'] = 8;

	for(let i = 1; i < order.length; i++){
		output[order[i]] = newPARAMS[i];
	}
	
	PARAMS.fromJSON(output);

	if(typeof CACHED_SOUND_EFFECTS[soundName] === "undefined"){
		CACHED_SOUND_EFFECTS[soundName] = {};
	}
	
	let max_sounds_gen = MAX_SOUND_ALTS;
	
	let distant_sounds = (soundName[0] !== '_') ? true : false; // non-distant sounds have underscore at start of name.
	if(!distant_sounds){
		max_sounds_gen = 1;
	}
	
	//let step = (PARAMS['p_lpf_freq']-param_min_val)/MAX_SOUND_ALTS;
	
	for(let i = 0; i < max_sounds_gen; i++){
		SOUND = new SoundEffect(PARAMS).generate();
		if(typeof CACHED_SOUND_EFFECTS[soundName]['sound'] === "undefined"){
			CACHED_SOUND_EFFECTS[soundName]['sound'] = [];
		}
		CACHED_SOUND_EFFECTS[soundName]['sound'].push(SOUND);
		CACHED_SOUND_EFFECTS[soundName]['params'] = PARAMS;
	
		PARAMS['p_lpf_freq'] /= param_step; // aka "cutoff frequency"
		//PARAMS['p_lpf_freq'] -= step;
		if(PARAMS['p_lpf_freq'] <= param_min_val) PARAMS['p_lpf_freq'] = param_min_val;
	}
}


function play_sound(soundName, sound_x, sound_z){
	if(typeof CACHED_SOUND_EFFECTS[soundName] === "undefined"){
		return;
	}
	
	let play_sound = true;
	let dist_sound = 0;
	let is_distant_sound = (soundName[0] !== '_') ? true : false; // starting with underscore = single sound.
	
	if(is_distant_sound){
		let px = players[myPlayer].x;
		let pz = players[myPlayer].z;
		let dist = get_dist_2d(px, pz, sound_x, sound_z);
		
		let max_audible_dist = 3000;

		if(dist > 3000){
			play_sound = false;
		}else{
			if(dist > max_audible_dist){
				dist = max_audible_dist;
			}
			dist_sound = Math.round((dist/max_audible_dist)*(MAX_SOUND_ALTS-1));
			let total_sounds = CACHED_SOUND_EFFECTS[soundName]['sound'].length;
			if(dist_sound < 0) dist_sound = 0;
			if(dist_sound > total_sounds-1) dist_sound = total_sounds-1;
		}
	}
	if(play_sound){
		//console.log("dist_sound = "+dist_sound);
		SOUND = CACHED_SOUND_EFFECTS[soundName]['sound'][dist_sound];
		SOUND.getAudio().play();
	}
}



// generate_collision_data generate collision data
function generate_hit_data(tex){
	let data_w = tex.image.width;
	let data_h = tex.image.height;
	
	let outData = new Uint8Array(data_w*data_h);
	
	const tempCanvas = document.createElement('canvas');
	tempCanvas.width = data_w;
	tempCanvas.height = data_h;

	const tempCtx = tempCanvas.getContext('2d');
	tempCtx.drawImage(tex.image, 0, 0);

	const imageData = tempCtx.getImageData(0, 0, data_w, data_h);
	
	for(let y = 0; y < data_h; y++){
		for(let x = 0; x < data_w; x++){
			outData[y*data_w+x] = imageData.data[y*data_w*4+x*4+3]; // +3 = alpha channel.
		}
	}
	
	return outData;
}

function generate_spritemap(images){


}





function pow_size(size){
	let power = 0;
	while(size > Math.pow(2, power)){
		power++;
	}
	return Math.pow(2, power);
}



function correct_texture_size(image){
	let pow_width = pow_size(image.width);
	let pow_height = pow_size(image.height);
	// dont resize image if not necessary:
	if(pow_width == image.width && pow_height == image.height){
		return image;
	}
	
	console.warn("resizing image to power of two size: "+image.src);
	
	const canvas = document.createElement('canvas');
	const context = canvas.getContext('2d');

	canvas.width = pow_width;
	canvas.height = pow_height;
	
	context.drawImage(image, 0, 0);

	return canvas;
}



function correct_texture_size_stretch(img){
	let new_w = pow_size(img.width);
	let new_h = pow_size(img.height);

	let canvas = document.createElement('canvas');
	let ctx = canvas.getContext("2d");

    canvas.width = new_w;
	canvas.height = new_h;

    // step 1 - resize to 50%
    let oc = document.createElement('canvas');
	let octx = oc.getContext('2d');

	let multi = 1; //0.5;
	
    oc.width = img.width * multi;
    oc.height = img.height * multi;
    octx.drawImage(img, 0, 0, oc.width, oc.height);

    // step 2
    octx.drawImage(oc, 0, 0, oc.width * multi, oc.height * multi);

    // step 3, resize to final size
    ctx.drawImage(oc, 0, 0, oc.width * multi, oc.height * multi, 0, 0, canvas.width, canvas.height);
	
	return canvas;
}


// if rect outside data area, then rect size and position changed accordingly.
// zero width means it is outside of data area.
function get_clamped_rect(data_w, data_h, x, y, w, h){
	if(x < 0){
		w = w+x;
		x = 0;
	}else if(x > data_w-1){
		w = 0;
		h = 0;
	}else if(x > data_w-w){
		w = data_w-x;
	}
	if(y < 0){
		h = h+y;
		y = 0;
	}else if(y > data_h-1){
		w = 0;
		h = 0;
	}else if(y > data_h-h){
		h = data_h-y;
		
	}
	return {'x':x, 'y':y, 'w':w, 'h':h};
}



function is_imagedata_empty(data, data_w, data_h){
	for(let y = 0; y < data_h; y++){
		for(let x = 0; x < data_w; x++){
			if(data[y*data_w*4+x*4+3] > 0){ // if not fully transparent; then visible.
				return false;
			}
		}
	}
	return true;
}



function is_area_empty(data, data_w, data_h, xp, yp, w, h){
	let rect = get_clamped_rect(data_w, data_h, xp, yp, w, h);
	if(!rect.w){
		return true; // was outside data area = empty.
	}
	let x1 = rect.x;
	let y1 = rect.y;
	let x2 = x1+rect.w;
	let y2 = y1+rect.h;
	for(let y = y1; y < y2; y++){
		for(let x = x1; x < x2; x++){
			if(data[y*data_w*4+x*4+3] > 0){ // if not fully transparent; then visible.
				return false;
			}
		}
	}
	return true;
}





// should generate it from bottom to top or the pieces are weirdly cut at bottom since the piece size is
function generate_compressed_map(tex){
	let image_w = tex.image.width;
	let image_h = tex.image.height;
	
	 // used to avoid texture bleeding when using mipmaps.
	 // edge pixels are repeated this many times.
	let padding = 0;
	
	// image split into blocksize-padding size squares.
	// this should be a power of 2 since mipmaps work that way too.
	let blockSize = 64;
	

	//let outData = new Uint8Array(data_w*data_h);
	
	const tempCanvas = document.createElement('canvas');
	tempCanvas.width = image_w;
	tempCanvas.height = image_h;
	const tempCtx = tempCanvas.getContext('2d');
	tempCtx.drawImage(tex.image, 0, 0);
	
	let out = "";
	
	let totalBlocks = 0;
	
	let blocks_x = Math.ceil(image_w/blockSize);
	let blocks_y = Math.ceil(image_h/blockSize);
	let maxBlocks = blocks_x*blocks_y;
	

	for(let y = 0; y < image_h; y+=blockSize){
		for(let x = 0; x < image_w; x+=blockSize){
			let imageData = tempCtx.getImageData(x, y, blockSize, blockSize);
			let empty = is_imagedata_empty(imageData.data, blockSize, blockSize);
			if(!empty){
				totalBlocks++;
			}
			out += empty ? '-' : 'O';
		}
		out += "\n";
	}
	
	let sq = Math.sqrt(totalBlocks);
	let sqblocks = Math.ceil(sq);
	let out_w = sqblocks*blockSize;
	let out_h = sqblocks*blockSize;
	let output_blocks = sqblocks*sqblocks;
	let compression_ratio = output_blocks/maxBlocks;
	
	//console.log(out);
	console.log("blocks required = "+totalBlocks);
	console.log("output texture blocks = "+output_blocks);
	console.log("maxBlocks = "+maxBlocks);
	console.log("out size = "+out_w+"x"+out_h);
	console.log("compression_ratio = "+(1/compression_ratio));
	


	/*
--------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------OOOOOOOOOOOOO----------------------------------------------------
---------------------------------------------------------------OOOOOOOOOOOOO----------------------------------------------------
-----------------------------------------------------------------OOOOOOOOOO-----------------------------------------------------
------------------------------------------------------------------OOOOOOO-------------------------------------------------------
------OOO----------------------------------------------------------OOOOO----------------------------------------------OOOO------
-----OOOO----------------------------------------------------------OOOO-----------------------------------------------OOOOO-----
-----OOOO----------------------------------------------------------OOOO-----------------------------------------------OOOOO-----
-----OOOO----------------------------------------------------------OOOO------------------------------------------------OOOO-----
-----OOOO----------------------------------------------------------OOOO-----------------------------------------------OOOOO-----
-----OOOO----------------------------------------------------------OOOO-----------------------------------------------OOOOO-----
----OOOOOO----------------------------OO--------------------------------------------------------OO--------------------OOOOOO----
----OOOOOOO--------------------------OOOOO-------------------------OOOO-----------------------OOOOOOO---------------OOOOOOOOOO--
--OOOOOOOOOOO----OOO-------------OOOOOOOOOOOO-------------------OOOOOOOOOO------------------OOOOOOOOOOO-----------OOOOOOOOOOOOOO
OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO
	*/
	/*
	const outputCanvas = document.createElement('canvas');
	outputCanvas.width = data_w;
	outputCanvas.height = data_h;
	const outputCtx = outputCanvas.getContext('2d');

	
	/*
	for(let y = 0; y < data_h; y++){
		for(let x = 0; x < data_w; x++){
			outData[y*data_w+x] = imageData.data[y*data_w*4+x*4];
		}
	}
	
	return outData;
	*/
}



// todo: find automatic places for random turrets.
function generate_placement_array(){
	let step = 64; // probably should be half the size of the object we want to place.
	let arr_w = Math.ceil(MAP_W/step);
	let arr_h = Math.ceil(MAP_H/step);
	for(let y = 0; y < MAP_H; y+=step){
		for(let x = 0; x < MAP_W; x+=step){
			// if opacity of pixel is large enough to be treated as ground:
			//if(MAP_DATA[y*MAP_W+x] > 40){
				// ground found
			//}else{
				// air found
			//}
		}
	}
}





function load_units(units){
	let howmany = 2;
	for(let i = 0; i < 36*howmany; i++){
		let type = ((i % 3) == 0) ? "bomber" : "antiair";
		units.push({"owner":-1, "type":type, "link":0, "d":1970, "a":i*(10/howmany)-2.5});
	}
	for(let i = 0; i < units.length; i++){
		spawn_turret(units[i]);
	}
}





function show_texture_loading_warning(err){
	console.warn("Could not load texture: \""+err.path[0].currentSrc+"\", ignoring it.");
}



// f_(top) etc: if null, no fading (top), otherwise fading length.
function create_fading_plane_mesh(plane_w, plane_h, material, f_top, f_bottom, f_left, f_right){
	if(typeof f_top === "undefined") f_top = null;
	if(typeof f_bottom === "undefined") f_bottom = null;
	if(typeof f_left === "undefined") f_left = null;
	if(typeof f_right === "undefined") f_right = null;
	
	

	var geometry = new THREE.PlaneBufferGeometry(plane_w, plane_h, 3, 3);
	var count = geometry.attributes.position.count;
	let BPP = 4;
	geometry.setAttribute('color', new THREE.BufferAttribute(new Float32Array(count*BPP), BPP));
	
	let mesh = new THREE.Mesh(geometry, material);
	mesh.visible = SHOW_WAVE_BG;
	mesh.rotation.x = -Math.PI / 2;
	

	var peak = 8;
	var smoothing = 600;
	var vertices = mesh.geometry.attributes.position.array;
	var colors = mesh.geometry.attributes.color.array;
	
	console.log(colors.length);
	console.log(colors);

	//mesh.geometry.attributes.position.needsUpdate = true;
	//mesh.geometry.computeVertexNormals();
	
	
	//for(let y = 0; y < Y_VERT; y++){}
	
	//for(var i = 0, c = 0; i <= vertices.length; i += 3, c+=BPP){
		//vertices[i+2] = Z_SKYBOX+5;
	
		// default color to white:
		//colors[c+0] = 1;
		//colors[c+1] = 1;
		//colors[c+2] = 1;
		//colors[c+3] = 1;

	//}
	
	mesh.geometry.attributes.position.needsUpdate = true;
	
	//console.log("mesh.geometry.attributes");
	//console.log(mesh.geometry.attributes);
	mesh.geometry.attributes.color.needsUpdate = true;
	return mesh;
}





function load_map_behind(path){
	return new THREE.TextureLoader().load(path, function(tex){
		tex.image = correct_texture_size(tex.image);
		set_loading_desc("Map behind loaded");
		
		tex.minFilter = globalFilter;
		tex.magFilter = globalFilter;

		{
			let geometry = new THREE.PlaneGeometry(tex.image.width, tex.image.height);
			let material = new THREE.MeshPhongMaterial({map: tex, color: 0xFFFFFF});  
			material.transparent = true;
			material.opacity = 1;
			//material.alphaTest = 0.5;
			material.side = THREE.DoubleSide;
			material.emissive.set(0xFFFFFF);
			material.emissiveMap = mapBehindEmissiveTex;
			material.emissiveIntensity = 0;
			
			for(let i = 0; i < PLANETS.length; i++){
				let behindMesh = new THREE.Mesh(geometry, material);
				behindMesh.visible = SHOW_MAP_BG;
				let mscale = 1;
				behindMesh.position.x = PLANETS[i].x;
				behindMesh.position.y = randomized_y(Z_MAP_BEHIND);
				behindMesh.position.z = PLANETS[i].z;
				
				behindMesh.rotation.x = -Math.PI/2;
				//behindMesh.scale.set(mscale,mscale,mscale);
				behindMesh.scale.set(mapscale.x,mapscale.y,mapscale.z);
				scene.add(behindMesh);
				
				behindMeshes.push(behindMesh);
				behindMeshesData.push({
					kx: 0,
					kz: 0,
				});
			}
		}
		
		loaded.map_behind = true;
	}, null, function(err){
		loaded.map_behind = true;
		show_texture_loading_warning(err);
	});
}

function load_map_behind_lights(path){
	return new THREE.TextureLoader().load(path, function(tex){
		tex.image = correct_texture_size(tex.image);
		set_loading_desc("Map behind lights loaded");
		
		tex.minFilter = globalFilter;
		tex.magFilter = globalFilter;
		
		loaded.map_behind_lights = true;
	}, null, function(err){
		loaded.map_behind_lights = true;
		show_texture_loading_warning(err);
	});
}

function load_map_front(path){
	return new THREE.TextureLoader().load(path, function(tex){
		tex.image = correct_texture_size(tex.image);
		set_loading_desc("Map front loaded");
		
		tex.minFilter = globalFilter;
		tex.magFilter = globalFilter;

		{
			let geometry = new THREE.PlaneGeometry(tex.image.width, tex.image.height);
			let material = new THREE.MeshPhongMaterial({map: tex, color: 0xFFFFFF});  
			material.transparent = true;
			material.opacity = 1;
			//material.alphaTest = 0.5;
			material.side = THREE.DoubleSide;
			
			
			for(let i = 0; i < PLANETS.length; i++){
				let mesh = new THREE.Mesh(geometry, material);
				mesh.visible = SHOW_MAP_BG;
				let mscale = 1;
				mesh.position.x = PLANETS[i].x;
				mesh.position.y = Z_MAP_FRONT;
				mesh.position.z = PLANETS[i].z;
				
				mesh.rotation.x = -Math.PI/2;
				mesh.scale.set(mscale,mscale,mscale);
				scene.add(mesh);
			}
		}
		loaded.map_front = true;
	}, null, function(err){
		loaded.map_front = true;
		show_texture_loading_warning(err);
	});
}


function load_map_clouds_front(path){
	return new THREE.TextureLoader().load(path, function(tex){
		//tex.image = correct_texture_size(tex.image);
		set_loading_desc("Clouds loaded");
		
		// make texture pixelized (min and mag needed both!):
		tex.minFilter = THREE.LinearFilter;
		tex.magFilter = THREE.LinearFilter;
		tex.repeat.x = 20*0.26*2;
		tex.repeat.y = 5*0.26*6.666;
		
		tex.wrapS = THREE.RepeatWrapping;
		tex.wrapT = THREE.RepeatWrapping;

		{
			let material = new THREE.MeshBasicMaterial({map: tex, color: cloudsColor});
			material.transparent = true;
			material.opacity = 0.9;
			material.side = THREE.DoubleSide;

			let geometry = new THREE.PlaneGeometry(MAP_W, MAP_H);
			cloudsFrontMesh = new THREE.Mesh(geometry, material);
			// TODO: needs buildAlphaMaterial() to work.
			//cloudsFrontMesh = create_fading_plane_mesh(MAP_W, MAP_H, material, 1024);

			cloudsFrontMesh.position.x = 0;
			cloudsFrontMesh.position.y = Z_CLOUDS;
			cloudsFrontMesh.position.z = 0;
			
			cloudsFrontMesh.rotation.x = -Math.PI/2;

			scene.add(cloudsFrontMesh);
		}
		loaded.clouds_front = true;
	});
}





function load_map_clouds_back(path){
	return new THREE.TextureLoader().load(path, function(tex){
		//tex.image = correct_texture_size(tex.image);
		set_loading_desc("Sky loaded");
		
		tex.minFilter = THREE.LinearFilter;
		tex.magFilter = THREE.LinearFilter;
		
		tex.repeat.x = 20.8;
		tex.repeat.y = 17.3316;
		
		tex.wrapS = THREE.RepeatWrapping;
		tex.wrapT = THREE.RepeatWrapping;

		{
		
			let geometry = new THREE.PlaneGeometry(MAP_W, MAP_H);
			let material = new THREE.MeshBasicMaterial({map: tex, color: skyboxColor});
			material.transparent = true;
			material.opacity = SHOW_NIGHTSKY_BG ? 0 : 1;
			material.side = THREE.DoubleSide;
				
			cloudsBackMesh = new THREE.Mesh(geometry, material);
			let mscale = 1;
			cloudsBackMesh.visible = !SHOW_NIGHTSKY_BG;
			cloudsBackMesh.position.x = 0;
			cloudsBackMesh.position.y = Z_SKYBOX;
			cloudsBackMesh.position.z = 0;

			cloudsBackMesh.rotation.x = -Math.PI/2;
			cloudsBackMesh.scale.set(mscale,mscale,mscale);
			scene.add(cloudsBackMesh);
		}
		loaded.clouds_back = true;
	});
}






function load_map_nightsky(path){
	return new THREE.TextureLoader().load(path, function(tex){
		tex.image = correct_texture_size_stretch(tex.image);
		//download_canvas(tex.image);

		
		set_loading_desc("Nightsky loaded");
		
		tex.minFilter = THREE.LinearFilter;
		tex.magFilter = THREE.LinearFilter;
		
		rescale_skybox();
		
		tex.wrapS = THREE.RepeatWrapping;
		tex.wrapT = THREE.RepeatWrapping;
		/*

		{
			let geometry = new THREE.PlaneGeometry(maptex_w*4, maptex_h*20);
			let material = new THREE.MeshBasicMaterial({map: tex, color: skyboxColor});
			material.transparent = true;
			material.opacity = SHOW_NIGHTSKY_BG ? nightskyMaxOpacity : 0;
			material.side = THREE.DoubleSide;
				
			nightskyMesh = new THREE.Mesh(geometry, material);
			let mscale = 1;
			nightskyMesh.visible = SHOW_NIGHTSKY_BG;
			nightskyMesh.position.x = 0;
			nightskyMesh.position.y = Z_SKYBOX;
			nightskyMesh.position.z = 0;
		
			nightskyMesh.rotation.x = -Math.PI/2;
			nightskyMesh.scale.set(mscale,mscale,mscale);
			scene.add(nightskyMesh);
			
		}
		*/
		
		loaded.nightsky = true;
	});
}



function load_map_parallax(path){
	return new THREE.TextureLoader().load(path, function(tex){
		tex.image = correct_texture_size(tex.image);
		
		set_loading_desc("Map background loaded");
		
		tex.minFilter = THREE.LinearFilter; // makes rain more crispy looking (=better).
		tex.magFilter = THREE.LinearFilter;
		
		{
			let geometry = new THREE.PlaneGeometry(MAP_W, MAP_H);
			let material = new THREE.MeshPhongMaterial({map: tex, color: 0x666666});  
			material.transparent = true;
			material.opacity = 1;
			material.side = THREE.DoubleSide;
				
			let mapobj2 = new THREE.Mesh(geometry, material);
			mapobj2.visible = SHOW_MAP_BG;
			let mscale = 1;
			mapobj2.position.x = 0;
			mapobj2.position.y = Z_MAP_BG;
			mapobj2.position.z = 0;
		
			mapobj2.rotation.x = -Math.PI/2;
			mapobj2.scale.set(mscale,mscale,mscale);
			scene.add(mapobj2);
		}
		loaded.map_bg = true;
	}, null, function(err){
		loaded.map_bg = true;
		show_texture_loading_warning(err);
	});
}





function load_map_rainfall(path){
	return new THREE.TextureLoader().load(path, function(tex){
		tex.image = correct_texture_size(tex.image);
		
		set_loading_desc("Rain loaded");
		
		// make texture pixelized (min and mag needed both!):
		tex.minFilter = THREE.NearestFilter; // makes rain more crispy looking (=better).
		tex.magFilter = THREE.NearestFilter;
		tex.repeat.x = 20*2*(5/10)*2;
		tex.repeat.y = 20*2*(3/10)*6.666;
		
		tex.wrapS = THREE.RepeatWrapping;
		tex.wrapT = THREE.RepeatWrapping;
		
		{
		
			let geometry = new THREE.PlaneGeometry(MAP_W, MAP_H);
			let material = new THREE.MeshPhongMaterial({map: tex, color: 0xFFFFFF});  
			material.transparent = true;
			material.opacity = SHOW_RAIN_BG ? rainMaxOpacity : 0;
			//material.blending = THREE.AdditiveBlending;
			material.side = THREE.DoubleSide;
				
			rainfallMesh = new THREE.Mesh(geometry, material);
			rainfallMesh.visible = SHOW_RAIN_BG; 
			let mscale = 1;
			rainfallMesh.position.x = 0;
			rainfallMesh.position.y = Z_RAIN;
			rainfallMesh.position.z = 0;
			
			rainfallMesh.rotation.x = -Math.PI/2;
			rainfallMesh.scale.set(mscale,mscale,mscale);
			scene.add(rainfallMesh);
		}
		loaded.rain = true;
	});
}




function load_map_waterdrops(path){
	return new THREE.TextureLoader().load(path, function(tex){
		tex.image = correct_texture_size(tex.image);
		
		set_loading_desc("Waterdrops loaded");
		
		tex.minFilter = THREE.LinearFilter;
		tex.magFilter = THREE.LinearFilter;
		tex.repeat.x = 4*2*0.66;
		tex.repeat.y = (4096/128)*5*0.66;

		tex.wrapS = THREE.RepeatWrapping;
		tex.wrapT = THREE.RepeatWrapping;
		
		let geometry = new THREE.PlaneGeometry(MAP_W, MAP_H);

		{
			let material = new THREE.MeshPhongMaterial({map: tex, color: 0xDDDDDD});  
			material.transparent = true;
			material.opacity = SHOW_RAIN_BG ? raindropsMaxOpacity : 0;
			material.side = THREE.DoubleSide;
			//material.blending = THREE.AdditiveBlending;
		
			waterdropsMesh = new THREE.Mesh(geometry, material);
			waterdropsMesh.visible = SHOW_RAIN_BG;
			let mscale = 1;
			waterdropsMesh.position.x = 0;
			waterdropsMesh.position.y = Z_MAP_WATERDROPS;
			waterdropsMesh.position.z = WATER_Y+MAP_H/2;
			
			waterdropsMesh.rotation.x = -Math.PI/2;
			waterdropsMesh.scale.set(mscale,mscale,mscale);
			scene.add(waterdropsMesh);
		}
		loaded.waterdrops = true;
	});
}



function load_map_water(path){
	return new THREE.TextureLoader().load(path, function(tex){
		tex.image = correct_texture_size(tex.image);
		
		set_loading_desc("Water loaded");
		
		tex.minFilter = THREE.LinearFilter;
		tex.magFilter = THREE.LinearFilter;
		tex.repeat.x = 1;
		tex.repeat.y = 6.666;

		tex.wrapS = THREE.RepeatWrapping;
		tex.wrapT = THREE.RepeatWrapping;
		
		let geometry = new THREE.PlaneGeometry(MAP_W, MAP_H);

		{
			let material = new THREE.MeshPhongMaterial({map: tex, color: 0xDDDDDD});  
			material.transparent = true;
			material.opacity = 0.4;
			material.side = THREE.DoubleSide;

			waterDownBack = new THREE.Mesh(geometry, material);
			waterDownBack.visible = true;
			let mscale = 1;
			waterDownBack.position.x = 0;
			waterDownBack.position.y = Z_MAP_WATER_BACK;
			waterDownBack.position.z = WATER_Y+MAP_H/2;
			
			waterDownBack.rotation.x = -Math.PI/2;
			waterDownBack.scale.set(mscale,mscale,mscale); // outwards
			scene.add(waterDownBack);
		}
		{
			let material = new THREE.MeshPhongMaterial({map: tex, color: 0xDDDDDD});  
			material.transparent = true;
			material.opacity = 0.6;
			material.side = THREE.DoubleSide;
			
			waterDownFront = new THREE.Mesh(geometry, material);
			waterDownFront.visible = true;
			let mscale = 1;
			waterDownFront.position.x = 0;
			waterDownFront.position.y = Z_MAP_WATER_FRONT;
			waterDownFront.position.z = WATER_Y+MAP_H/2;
			
			waterDownFront.rotation.x = -Math.PI/2;
			waterDownFront.scale.set(mscale,-mscale,mscale); // inwards
			scene.add(waterDownFront);
		}
		
		loaded.water = true;
	});
}





function load_map_collision(path){
	return new THREE.TextureLoader().load(path, function(tex){
		tex.image = correct_texture_size(tex.image);
		console.warn("GRAVITY.points", stringify(GRAVITY.points));
		console.warn("loaded", stringify(loaded));
		set_loading_desc("Map loaded");
		

		// make texture pixelized (min and mag needed both!):
		//let filter = THREE.NearestFilter;
		let filter = globalFilter;
		tex.minFilter = filter;
		tex.magFilter = filter;
		
		set_loading_desc("Creating map data");
		
		let piece_x = 0;
		let piece_z = 0;
		
		let hitdata = new generate_hit_data(tex);


		
		//console.log("COLLISION_DATA");
		//console.log(COLLISION_DATA);
		//generate_placement_array();
		
		//generate_compressed_map(tex);
		
		{
			let material = new THREE.MeshPhongMaterial({map: tex, color: 0xFFFFFF});
			//material.map.needsUpdate = true; // use this when updating texture pixels.
			material.transparent = true;
			material.side = THREE.DoubleSide;
			material.alphaTest = 0.5;
			
			let geometry = new THREE.PlaneGeometry(tex.image.width, tex.image.height);
			


			for(let i = 0; i < PLANETS.length; i++){
				let planet = PLANETS[i];
				let collisiondata = {
					'x': planet.x,
					'z': planet.z,
					'w': tex.image.width,
					'h': tex.image.height,
					'kx': 0,
					'kz': 0,
					'data': hitdata,
				};
				COLLISION_DATA['MAP_DATA'].push(collisiondata);
				GRAVITY.points.push({
					'x': planet.x,
					'z': planet.z,
					'kx': 0,
					'kz': 0,
					'range': planet.range,
					'minradius': planet.minradius,
				});
				console.warn("gravity.points.push", {
					'x': planet.x,
					'z': planet.z,
					'range': planet.range,
					'minradius': planet.minradius,
				});
				
				let mesh = new THREE.Mesh(geometry, material);

				mesh.rotation.x = -Math.PI/2;
				
				mesh.position.x = collisiondata.x;
				mesh.position.y = randomized_y(Z_MAP_COLLISION);
				mesh.position.z = collisiondata.z;
				
				mesh.scale.set(mapscale.x,mapscale.y,mapscale.z);
				
				collisionMeshes.push(mesh);
				collisionMeshesData.push({
					kx: 0,
					kz: 0,
				});
				scene.add(mesh);
			}
		}
		
		if(WATER_ENABLED){
			let material = new THREE.MeshPhongMaterial({map: tex, color: 0xBBBBBB});  
			material.transparent = true;
			material.opacity = 0.2;
			material.side = THREE.DoubleSide;
			
			let geometry = new THREE.PlaneGeometry(tex.image.width, tex.image.height);
			mapMeshFlipped = new THREE.Mesh(geometry, material);
			
			mapMeshFlipped.rotation.x = -Math.PI/2;
			
			mapMeshFlipped.position.x = 0;
			mapMeshFlipped.position.y = Z_MAP_COLLISION;
			mapMeshFlipped.position.z = WATER_Y+MAP_H/2;
			
			mapMeshFlipped.scale.set(1,-1,1);
			
			scene.add(mapMeshFlipped);
		}
		
		loaded.map = true;
		console.warn("GRAVITY.points", stringify(GRAVITY.points));
		console.warn("loaded", stringify(loaded));
		
	});
}








function load_map(){

	MAP_PIECES = [];
	GRAVITY = deepClone(GRAVITY_DEFAULT);
	console.warn(GRAVITY);
	
	if(mapinfo.hasOwnProperty("map")){
		console.log("mapinfo found");
		
		let pieces = mapinfo["map"];
		console.warn(pieces);
		
		// todo: load all map pieces:
		for(let i = 0; i < pieces.length; i++){
			let piece = pieces[i];
			let piece_group = [];
			
			if(piece.hasOwnProperty("smoothrender")){
				piece['FILTER'] = piece.smoothrender ? THREE.LinearFilter : THREE.NearestFilter;
			}else{
				piece['FILTER'] = THREE.LinearFilter;
			}
			

			/////////////////
			// add extra internal properties to piece data for each type: (back,middle,front)
			// texture and mesh will be created later.
			//
			if(piece.hasOwnProperty("back")){				
				// clone piece and then combine new properties into that clone:
				let newpiece = Object.assign(deepClone(piece), {
					'TYPE': "back", 
					'PATH': map_path(piece.back), 
					'TEXTURE': null,
					'MESH': null,
					'LOADED': false,
					'LOADFUNC': null,
				});
				piece_group.push(newpiece);
				TEXTURES['map_behind_url'].path = map_path(piece.back);
			}
			if(piece.hasOwnProperty("middle")){
				// clone piece and then combine new properties into that clone:
				let newpiece = Object.assign(deepClone(piece), {
					'TYPE': "middle", 
					'PATH': map_path(piece.middle), 
					'TEXTURE': null,
					'MESH': null,
					'LOADED': false,
					'LOADFUNC': null,
				});
				piece_group.push(newpiece);
				TEXTURES['collision'].path = map_path(piece.middle);
			}
			if(piece.hasOwnProperty("front")){
				// clone piece and then combine new properties into that clone:
				let newpiece = Object.assign(deepClone(piece), {
					'TYPE': "front", 
					'PATH': map_path(piece.front), 
					'TEXTURE': null,
					'MESH': null,
					'LOADED': false,
					'LOADFUNC': null,
				});
				piece_group.push(newpiece);
				TEXTURES['map_front_url'].path = map_path(piece.front);
			}

			if(piece_group.length > 0){
				// add stuff only if there were any visible pieces. (maybe later allow empty pieces too).
				/*
				let has_gravity = true;
				if(has_gravity){
					// todo: set style to GRAVITY_CIRCULAR
					GRAVITY.points.push({
						'x': piece.position_x,
						'z': piece.position_y
					});
				}
				*/

				MAP_PIECES.push(piece_group);
			}
		}
		
		if(mapinfo.hasOwnProperty("teleport_from_edges_x")){
			teleport_from_edges_x = get_boolean(mapinfo.teleport_from_edges_x);
		}
		if(mapinfo.hasOwnProperty("teleport_from_edges_y")){
			teleport_from_edges_y = get_boolean(mapinfo.teleport_from_edges_y);
		}
		
		if(mapinfo.hasOwnProperty("min_x") && mapinfo.hasOwnProperty("max_x")){
			MAP_X1 = mapinfo.min_x;
			MAP_X2 = mapinfo.max_x;
			MAP_W = Math.abs(mapinfo.min_x-mapinfo.max_x);
		}
		if(mapinfo.hasOwnProperty("min_y") && mapinfo.hasOwnProperty("max_y")){
			MAP_Y1 = mapinfo.min_y;
			MAP_Y2 = mapinfo.max_y;
			MAP_H = Math.abs(mapinfo.min_y-mapinfo.max_y);
		}
		
		// handle weather:
		if(mapinfo.hasOwnProperty("weather")){
			let weather = mapinfo["weather"];
			
			if(weather.hasOwnProperty("gravity")){
				if(weather.gravity.hasOwnProperty("style")){
					let str = get_constant(weather.gravity.style);
					//console.error(str);

					if(str == "planar"){
						GRAVITY.style = GRAVITY_PLANAR;
					}else if(str == "circular"){
						GRAVITY.style = GRAVITY_CIRCULAR;
					}else{
						console.error("unknown gravity style '"+str+"'. defaulting to planar. allowed: planar, circular.");
						GRAVITY.style = GRAVITY_PLANAR;
					}
				}
				if(weather.gravity.hasOwnProperty("force")){
					GRAVITY.value = get_float(weather.gravity.force);
				}
			}
			
			if(weather.hasOwnProperty("lighting")){
				if(weather.lighting.hasOwnProperty("day")){
					light_day = colorToUint32(parseColor(weather.lighting.day));
				}
				if(weather.lighting.hasOwnProperty("sunset")){
					light_sunset = colorToUint32(parseColor(weather.lighting.sunset));
				}
				if(weather.lighting.hasOwnProperty("sunset_sky")){
					light_sunset_sky = colorToUint32(parseColor(weather.lighting.sunset_sky));
				}
				if(weather.lighting.hasOwnProperty("night")){
					light_night = colorToUint32(parseColor(weather.lighting.night));
				}
				if(weather.lighting.hasOwnProperty("rain")){
					light_rain = colorToUint32(parseColor(weather.lighting.rain));
				}
			}
			
			if(weather.hasOwnProperty("sky")){
				if(weather.sky.hasOwnProperty("space")){
					if(weather.sky.space.hasOwnProperty("path")){
						TEXTURES['nightsky_url'].path = map_path(weather.sky.space.path);
					}
					if(weather.sky.space.hasOwnProperty("root_path")){
						TEXTURES['nightsky_url'].path = root_path(weather.sky.space.root_path);
					}
					if(weather.sky.space.hasOwnProperty("repeat")){
						SKYBOX_REPEAT = get_boolean(weather.sky.space.repeat);
					}
					if(weather.sky.space.hasOwnProperty("scale")){
						SKYBOX_SCALE = get_float(weather.sky.space.scale);
					}
					if(weather.sky.space.hasOwnProperty("distance")){
						SKYBOX_DISTANCE = get_float(weather.sky.space.distance);
					}
				}
				if(weather.sky.hasOwnProperty("clouds_back")){
					if(weather.sky.clouds_back.hasOwnProperty("path")){
						TEXTURES['clouds_back_url'].path = map_path(weather.sky.clouds_back.path);
					}
					if(weather.sky.clouds_back.hasOwnProperty("enabled")){
						if(!weather.sky.clouds_back.enabled){
							clouds_back_enabled = false;
						}
					}
				}
				if(weather.sky.hasOwnProperty("clouds_front")){
					if(weather.sky.clouds_front.hasOwnProperty("path")){
						TEXTURES['clouds_front_url'].path = map_path(weather.sky.clouds_front.path);
					}
					if(weather.sky.clouds_front.hasOwnProperty("enabled")){
						if(!weather.sky.clouds_front.enabled){
							clouds_front_enabled = false;
						}
					}
					if(weather.sky.clouds_front.hasOwnProperty("enabled_at_night")){
						if(weather.sky.clouds_front.enabled_at_night){
							min_cloud_front_opa = default_min_cloud_front_opa;
						}else{
							min_cloud_front_opa = 0; // essentially disables clouds at night mode.
						}
					}
				}
			}
			
			if(weather.hasOwnProperty("water")){
				if(weather.water.hasOwnProperty("front")){
					TEXTURES['map_water_url'].path = map_path(weather.water.front);
				}
				if(weather.water.hasOwnProperty("enabled")){
					WATER_ENABLED = weather.water.enabled ? true : false;
				}
				if(weather.water.hasOwnProperty("y")){
					WATER_Y = weather.water.y;
				}
			}
			
			if(weather.hasOwnProperty("rain")){
				if(weather.rain.hasOwnProperty("front")){
					TEXTURES['map_rainfall_url'].path = map_path(weather.rain.front);
				}
				if(weather.rain.hasOwnProperty("waterdroplets")){
					TEXTURES['map_waterdrops_url'].path = map_path(weather.rain.waterdroplets);
				}
			}
		}
		
		console.log("TEXTURES");
		console.log(TEXTURES);

		console.log("MAP_PIECES");
		console.log(MAP_PIECES);
	}



	
	
	console.log("MAP_PIECES");
	console.log(MAP_PIECES);
	
	COLLISION_DATA['MAP_DATA'] = [];
	
	for(let i = 0; i < MAP_PIECES.length; i++){
		let piece_group = MAP_PIECES[i];
		
		for(let p = 0; p < piece_group.length; p++){
			let piece = piece_group[p];

			piece.LOADFUNC = function(tex){
				console.log("Loaded texture: "+piece.PATH);
				console.log(piece.TEXTURE);
				
				tex.image = correct_texture_size(tex.image);
				tex.minFilter = piece.FILTER;
				tex.magFilter = piece.FILTER;
				
				if(piece.TYPE == "back"){
					
				}else if(piece.TYPE == "middle"){
					
				}else if(piece.TYPE == "front"){
					
				}
				
				piece.LOADED = true;
			};
			piece.LOADED = true; // remove if below enabled:
			//piece.TEXTURE = new THREE.TextureLoader().load(piece.PATH, piece.LOADFUNC);
		}
	}
	
	
	mapCollisionTex = load_map_collision(texture_path('collision'));
	mapBehindEmissiveTex = load_map_behind_lights(texture_path('map_behind_lights_url'));
	mapBehindTex = load_map_behind(texture_path('map_behind_url'));
	mapFrontTex = load_map_front(texture_path('map_front_url'));

	if(WATER_ENABLED){
		mapWaterTex = load_map_water(texture_path('map_water_url'));
		mapWaterdropsTex = load_map_waterdrops(texture_path('map_waterdrops_url'));
		mapRainfallTex = load_map_rainfall(texture_path('map_rainfall_url'));
	}else{
		loaded.water = true; // mark as loaded so the game will start.
		loaded.waterdrops = true;
		loaded.rain = true;
	}

	//mapParallaxTex = load_map_parallax(texture_path('map_bg_parallax_url')); // probably will be removed from game.
	
	scene.background = mapNightskyTex = load_map_nightsky(texture_path('nightsky_url')); // "skybox"
	
	if(clouds_back_enabled){
		mapCloudsBackTex = load_map_clouds_back(texture_path('clouds_back_url'));
	}else{
		loaded.clouds_back = true; // mark as loaded so the game will start.
	}
	
	if(clouds_front_enabled){
		mapCloudsFrontTex = load_map_clouds_front(texture_path('clouds_front_url'));
	}else{
		loaded.clouds_front = true; // mark as loaded so the game will start.
	}

} // load_map()





function load_mod(){
	
}



function get_cubemap_urls(path, s){
	let p = urlprefix + path; // add prefix
	return [p+"px"+s, p+"nx"+s, p+"py"+s, p+"ny"+s, p+"pz"+s, p+"nz"+s];
}




function pre_init(){

	loading_start_time = getTimeMillis();

	console.log("GAME LOADING STARTED");


	CANVAS_W = window.innerWidth;
	CANVAS_H = window.innerHeight;

	
	console.log("CANVAS SIZE = "+CANVAS_W+"x"+CANVAS_H);	
	
	// DATA FILES:
	
	// load mod settings:
	$.getJSON(MOD_DATA_URL, function(json){
		loaded.mod_settings = true;
		
		console.log("MOD SETTINGS:");
		console.log(json);
		
		// combine map_defaults with map settings.json:
		modinfo = Object.assign(mod_defaults, json);
		
		load_mod();
		
	}).fail(function(){
		console.error("ERROR: Could not read file: '"+MOD_DATA_URL+"'! File may be missing or incorrectly formatted (JSON is strict format, commas cannot be in end of lines unless another item comes after. All keys must be surrounded by double quotes, and all strings must be surrounded by double quotes).");
	});
	
	
	// load map settings:
	$.getJSON(MAP_DATA_URL, function(json){
		loaded.map_settings = true;
		
		console.log("MAP SETTINGS:");
		console.log(json);
		
		// combine map_defaults with map settings.json:
		mapinfo = Object.assign(map_defaults, json);
		
		// todo: should load all map textures etc after map settings are loaded!
		load_map();
		
	}).fail(function(){
		console.error("ERROR: Could not read file: '"+MAP_DATA_URL+"'! File may be missing or incorrectly formatted (JSON is strict format, commas cannot be in end of lines unless another item comes after. All keys must be surrounded by double quotes, and all strings must be surrounded by double quotes).");
	});
	
	
	////////////////////////////
	// CAMERAS

	if(ortho){
		let nearplane = 0; // default 0.1, not sure why. but 0 is allowed for ortho according to docs.
		let farplane = (Z_MAXZIN-Z_MINZIN) + ZINSTEP*10; // how far camera can see. dont set too large or depth testing breaks.
	
		camera = new THREE.OrthographicCamera( -CANVAS_W/2, CANVAS_W/2, CANVAS_H/2, -CANVAS_H/2, nearplane, farplane);
		camera.zoom = INTERNAL_ZOOM;
	}else{
		camera = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 1, 100000);
	}
	
	camera.position.set(0, Z_MAXZIN+ZINSTEP, 0);
	cameraCube = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 1, 100000);

	//////////////////////
	// CONTROLS FOR CAMERA
	//controls = new THREE.OrbitControls(camera);
	//controls.minDistance = 500;
	//controls.maxDistance = 25000;

	/////////////////////////////
	// SCENE
	scene = new THREE.Scene();
	sceneCube = new THREE.Scene();

	/////////////////////////////
	// Lights
	ambient = new THREE.AmbientLight(0xffffff);
	scene.add(ambient);
	
	let light = new THREE.PointLight(0xffffff, 1);
	light.position.set(0, Z_MAP_LIGHT, 0);
	scene.add(light);
		
	//let targetObject = new THREE.Object3D(0,10000,0);
	//scene.add(targetObject);
	//let light = new THREE.DirectionalLight( 0xffffff, 0.5 );
	//light.target = targetObject;
	//scene.add(light);
	



	
	// Textures
	//var r = urlprefix+"textures/landscape.png";
	var r = urlprefix+"textures/clouds/cloud-bg.jpg";
	var urls = [r, r, r, r, r, r];
	
	// reflective bumpy cloud mapping:
	textureCube = new THREE.CubeTextureLoader().load(urls);
	textureCube.format = THREE.RGBAFormat;
	textureCube.mapping = THREE.CubeReflectionMapping;


	{
		//let r = urlprefix+"textures/stars/galaxy_stars_squared.png";
		//let urls = [r, r, r, r, r, r];
		
		
		// for objects reflections (cloudy stars):
		reflectionCube = new THREE.CubeTextureLoader().load(get_cubemap_urls("textures/cubemaps/reflection1/", ".png"));
		//reflectionCube = new THREE.CubeTextureLoader().load(urls);
		reflectionCube.format = THREE.RGBAFormat;
		reflectionCube.mapping = THREE.CubeReflectionMapping;
	}


/*
	new RGBELoader().setPath('textures/envmaps/').load('royal_esplanade_1k.hdr', function(tex){
		tex.mapping = THREE.EquirectangularReflectionMapping;

		//scene.background = tex;
		scene.environment = tex;

		//render();

		// model


	});
*/

	// load main map texture: (map_path map_plane) load_map
	set_loading_desc("Loading map pieces");
	
	

	
	
	
	
	/*
	
	marioSpriteTest = new THREE.TextureLoader().load(texture_path('mario_sprite_url'), function(tex){
		tex.image = correct_texture_size(tex.image);
		loaded.antiair = true;
		set_loading_desc("Antiair loaded");
		
		let frameW = 28;
		let frameH = 19;
		let frames_x = 2;
	
		initialize_sprite('antiair', frameW, frameH, tex.image.width, tex.image.height, frames_x);
		//console.log(SPRITES);

		tex.minFilter = THREE.NearestFilter;//globalFilter;
		tex.magFilter = THREE.NearestFilter;//globalFilter;
		tex.repeat.x = frameW/tex.image.width;
		tex.repeat.y = frameH/tex.image.height;
		tex.offset.x = 0;
		tex.offset.y = 0;
		tex.flipY = false;
		
		{
			let geometry = new THREE.PlaneGeometry(frameW,frameH);
			let material = new THREE.MeshPhongMaterial({map: tex, color: 0xFFFFFF});  			
			material.color.set(0xFFFFFF);
			material.transparent = true;
			material.side = THREE.DoubleSide;

			let mesh = new THREE.Mesh(geometry, material);
			let mscale = 1;
			mesh.position.x = 300;
			mesh.position.y = Z_SOLDIER;
			mesh.position.z = 330;

			mesh.rotation.x = -Math.PI/2;
			mesh.scale.set(mscale,mscale,mscale);
			
			var i = add_player(mesh, TYPE_SOLDIER);
			scene.add(mesh);
		}
		
	});
	*/
	
	// antiair_sprite antiairSprite
	turretSpriteTest = new THREE.TextureLoader().load(texture_path('turret_sprite_url'), function(tex){
		tex.image = correct_texture_size(tex.image);
		loaded.turret = true;
		set_loading_desc("Turret loaded");
		
		let frameW = 32*3;
		let frameH = 19*3;
		let frames_x = 2;
	
		initialize_sprite('turret', frameW, frameH, tex.image.width, tex.image.height, frames_x);
		//console.log(SPRITES);

		tex.minFilter = globalFilter;
		tex.magFilter = globalFilter;
		tex.repeat.x = frameW/tex.image.width;
		tex.repeat.y = frameH/tex.image.height;
		tex.offset.x = 0;
		tex.offset.y = 0;
		tex.flipY = false;

	});

	
	
	
	soldierSpriteTest = new THREE.TextureLoader().load(texture_path('soldier_sprite_url'), function(tex){
		tex.image = correct_texture_size(tex.image);
		loaded.soldier = true;
		set_loading_desc("Soldier loaded");
		
		let scale = 3;
		let frameW = 52*scale;
		let frameH = 43*scale;
		let frames_x = 6;
	
		initialize_sprite('soldier', frameW, frameH, tex.image.width, tex.image.height, frames_x);

		tex.minFilter = globalFilter;
		tex.magFilter = globalFilter;
		tex.repeat.x = frameW/tex.image.width;
		tex.repeat.y = frameH/tex.image.height;
		tex.offset.x = 0;
		tex.offset.y = 0;
		tex.flipY = false;
		
		{
			let geometry = new THREE.PlaneGeometry(frameW/scale,frameH/scale);
			let material = new THREE.MeshPhongMaterial({map: tex, color: 0xFFFFFF});  			
			material.color.set(0xFFFFFF);
			material.transparent = true;
			material.alphaTest = 0.5;
			material.side = THREE.DoubleSide;

			let mesh = new THREE.Mesh(geometry, material);
			let mscale = 1;
			mesh.position.x = 2973;
			mesh.position.z = -1183;
			mesh.position.y = Z_SOLDIER;

			mesh.rotation.x = -Math.PI/2;
			mesh.scale.set(mscale,mscale,mscale);
			
			var i = add_player(mesh, TYPE_SOLDIER);
			soldierPlayer = i;
			
			scene.add(mesh);
		}
		
	});
	
	

	bomberEmissiveTex = new THREE.TextureLoader().load(texture_path('bomber_lights_sprite_url'), function(tex){
		tex.image = correct_texture_size(tex.image);
		loaded.bomber_lights = true;
		set_loading_desc("Bomber lights loaded");
		
		let w = 1024;
		let h = 256;

		tex.minFilter = THREE.LinearFilter;//globalFilter;
		tex.magFilter = THREE.LinearFilter;//globalFilter;
		tex.repeat.x = w/tex.image.width;
		tex.repeat.y = h/tex.image.height;
		tex.offset.x = 0;
		tex.offset.y = 0;
		tex.flipY = false;
	});
	
	
	
	
	bomberSpriteTest = new THREE.TextureLoader().load(texture_path('bomber_sprite_url'), function(tex){
		tex.image = correct_texture_size(tex.image);
		loaded.bomber = true;
		set_loading_desc("Bomber loaded");
		
		let w = 1024;
		let h = 256;

		tex.minFilter = THREE.LinearFilter;//globalFilter;
		tex.magFilter = THREE.LinearFilter;//globalFilter;
		tex.repeat.x = w/tex.image.width;
		tex.repeat.y = h/tex.image.height;
		tex.offset.x = 0;
		tex.offset.y = 0;
		tex.flipY = false;
		
		set_loading_desc("Creating hit data");
		
		let collisiondata = {
			'x': 0,
			'z': 0,
			'w': tex.image.width,
			'h': tex.image.height,
			'data': new generate_hit_data(tex),
		};
		COLLISION_DATA['OBJECTS']['bomber_sprite_url'] = collisiondata;
		
		// todo: generate hash from each piece data, so we can store only unique pieces to save memory.
		//COLLISION_DATA['bomber'] = {w:tex.image.width, h:tex.image.height, data: new generate_hit_data(tex)};
		
	});
	
	
	
	
	loaded.stream = true;
/*
	streamSpriteTest = new THREE.TextureLoader().load(texture_path('stream_sprite_url'), function(tex){
		tex.image = correct_texture_size(tex.image);
		loaded.stream = true;
		set_loading_desc("Stream loaded");
		
		let w = 256;
		let h = 32;

		streamSpriteTest.minFilter = THREE.LinearFilter;//globalFilter;
		streamSpriteTest.magFilter = THREE.LinearFilter;//globalFilter;
		streamSpriteTest.repeat.x = w/tex.image.width;
		streamSpriteTest.repeat.y = h/tex.image.height;
		streamSpriteTest.offset.x = 0;
		streamSpriteTest.offset.y = 0;
		streamSpriteTest.flipY = false;
	});
	*/
	

	shotSpriteTest = new THREE.TextureLoader().load(texture_path('shots_sprite_url'), function(tex){
		tex.image = correct_texture_size(tex.image);
		loaded.shots = true;
		set_loading_desc("Shots loaded");
		
		let w = 64;
		let h = 16;

		tex.minFilter = THREE.LinearFilter;
		tex.magFilter = THREE.LinearFilter;
		tex.repeat.x = w/tex.image.width;
		tex.repeat.y = h/tex.image.height;
		tex.offset.x = 0;
		tex.offset.y = 0;
		tex.flipY = false;
		
		shotlightsTex = new THREE.TextureLoader().load(texture_path('shots_lights_sprite_url'), function(tex){
			tex.image = correct_texture_size(tex.image);
			loaded.shots_lights = true;
			set_loading_desc("Shots lights loaded");

			tex.minFilter = THREE.LinearFilter;
			tex.magFilter = THREE.LinearFilter;
			tex.repeat.x = w/tex.image.width;
			tex.repeat.y = h/tex.image.height;
			tex.offset.x = 0;
			tex.offset.y = 0;
			tex.flipY = false;
		});
	});
	
	
	
	
	bombSpriteTest = new THREE.TextureLoader().load(texture_path('bombs_sprite_url'), function(tex){
		tex.image = correct_texture_size(tex.image);
		loaded.bombs = true;
		set_loading_desc("Bombs loaded");
		
		let w = 25;
		let h = 17;

		tex.minFilter = globalFilter;
		tex.magFilter = globalFilter;
		tex.repeat.x = w/tex.image.width;
		tex.repeat.y = h/tex.image.height;
		tex.offset.x = 0;
		tex.offset.y = 0;
		tex.flipY = false;
	});
	
	
	
	
	splashSpriteTest = new THREE.TextureLoader().load(texture_path('splash_sprite_url'), function(tex){
		tex.image = correct_texture_size(tex.image);
		loaded.splashes = true;
		set_loading_desc("Splash loaded");
		
		let w = 128;
		let h = 128;

		tex.minFilter = globalFilter;
		tex.magFilter = globalFilter;
		tex.repeat.x = w/tex.image.width;
		tex.repeat.y = h/tex.image.height;
		tex.offset.x = 0;
		tex.offset.y = 0;
		tex.flipY = false;
	});
	




	glowspriteTex = new THREE.TextureLoader().load(texture_path('glowsprite_url'), function(tex){
		tex.image = correct_texture_size(tex.image);
		loaded.glowsprite = true;
		set_loading_desc("Glowsprite loaded");
		
		let w = 128;
		let h = 128;

		tex.minFilter = globalFilter;
		tex.magFilter = globalFilter;
		tex.repeat.x = w/tex.image.width;
		tex.repeat.y = h/tex.image.height;
		tex.offset.x = 0;
		tex.offset.y = 0;
		tex.flipY = false;
	});
	
	
	explosionRoundTex = new THREE.TextureLoader().load(texture_path('explosion_round'), function(tex){
		tex.image = correct_texture_size(tex.image);
		loaded.explosion_round = true;
		set_loading_desc("Explosion round loaded");
		
		let w = 240;
		let h = 240;

		tex.minFilter = globalFilter;
		tex.magFilter = globalFilter;
		tex.repeat.x = w/tex.image.width;
		tex.repeat.y = h/tex.image.height;
		tex.offset.x = 0;
		tex.offset.y = 0;
		tex.flipY = false;
	});
	
	explosionRoundLaserTex = new THREE.TextureLoader().load(texture_path('explosion_round_laser'), function(tex){
		tex.image = correct_texture_size(tex.image);
		loaded.explosion_round_laser = true;
		set_loading_desc("Explosion round laser loaded");
		
		let w = 240;
		let h = 240;

		tex.minFilter = globalFilter;
		tex.magFilter = globalFilter;
		tex.repeat.x = w/tex.image.width;
		tex.repeat.y = h/tex.image.height;
		tex.offset.x = 0;
		tex.offset.y = 0;
		tex.flipY = false;
	});
	
	explosionRoundSmallTex = new THREE.TextureLoader().load(texture_path('explosion_round_small'), function(tex){
		tex.image = correct_texture_size(tex.image);
		loaded.explosion_round_small = true;
		set_loading_desc("Explosion round small loaded");
		
		let w = 240/4; // 60x60
		let h = 240/4;

		tex.minFilter = globalFilter;
		tex.magFilter = globalFilter;
		tex.repeat.x = w/tex.image.width;
		tex.repeat.y = h/tex.image.height;
		tex.offset.x = 0;
		tex.offset.y = 0;
		tex.flipY = false;
	});
	
	
	explosionSpriteTest = new THREE.TextureLoader().load(texture_path('explosion_sprites_url'), function(tex){
		tex.image = correct_texture_size(tex.image);
		loaded.explosions = true;
		set_loading_desc("Explosions loaded");
		
		let w = 128;
		let h = 128;

		tex.minFilter = globalFilter;
		tex.magFilter = globalFilter;
		tex.repeat.x = w/tex.image.width;
		tex.repeat.y = h/tex.image.height;
		tex.offset.x = 0;
		tex.offset.y = 0;
		tex.flipY = false;
	});
	
	
	
	
	santaSpriteTest = new THREE.TextureLoader().load(texture_path('santa_sprite_url'), function(tex){
		tex.image = correct_texture_size(tex.image);
		loaded.santa = true;
		set_loading_desc("Santa loaded");

		let scale = 3;
		let frameW = 167*scale;
		let frameH = 58*scale;
		let frames_x = 3;
	
		initialize_sprite('santa_sleigh', frameW, frameH, tex.image.width, tex.image.height, frames_x);

		tex.minFilter = globalFilter;
		tex.magFilter = globalFilter;
		tex.repeat.x = frameW/tex.image.width;
		tex.repeat.y = frameH/tex.image.height;
		tex.offset.x = 0;
		tex.offset.y = 0;
		tex.flipY = false;
		
		
		santaEmissiveTex = new THREE.TextureLoader().load(texture_path('santa_lights_sprite_url'), function(tex){
			tex.image = correct_texture_size(tex.image);
			loaded.santa_lights = true;
			set_loading_desc("Santa lights loaded");
			
			tex.minFilter = globalFilter;
			tex.magFilter = globalFilter;
			tex.repeat.x = frameW/tex.image.width;
			tex.repeat.y = frameH/tex.image.height;
			tex.offset.x = 0;
			tex.offset.y = 0;
			tex.flipY = false;
		});
		
		
		let geometry = new THREE.PlaneGeometry(frameW/scale, frameH/scale);
		let material = new THREE.MeshPhongMaterial({map: santaSpriteTest, color: 0xFFFFFF});  			
		material.color.set(0xFFFFFF);
		material.transparent = true;
		material.alphaTest = 0.5;
		material.side = THREE.DoubleSide;
		material.emissive.set(0xFFFF88);
		material.emissiveMap = santaEmissiveTex;
		material.emissiveIntensity = 0.9;

		let mesh = new THREE.Mesh(geometry, material);
		let mscale = 1;

		mesh.position.x = 385;
		mesh.position.z = -3710;
		mesh.position.y = Z_PLANE;

		mesh.rotation.x = -Math.PI/2;
		mesh.scale.set(mscale,-mscale,mscale);
		
		var i = add_player(mesh, TYPE_SANTA);
		santaPlayer = i;
		scene.add(mesh);
	});
	
	




	ufoTex = new THREE.TextureLoader().load(texture_path('ufo_texture'), function(tex){
		tex.image = correct_texture_size(tex.image);
		loaded.ufo = true;
		set_loading_desc("Ufo loaded");
		
		

		let scale = 2;
		let mesh_w = (466+2)/scale;
		let mesh_h = (186+2)/scale;
		let frames_x = 4;
		let tex_frame_w = mesh_w*scale;
		let tex_frame_h = mesh_h*scale;
		
/*
ufo player:
24 , 6
489 , 191
 

466 x 186
*/

		let sprite_name = 'ufo_spin';
		initialize_sprite(sprite_name, tex_frame_w, tex_frame_h, tex.image.width, tex.image.height, frames_x);


		tex.minFilter = globalFilter;
		tex.magFilter = globalFilter;
		tex.repeat.x = tex_frame_w/tex.image.width;
		tex.repeat.y = tex_frame_h/tex.image.height;
		tex.offset.x = 0;
		tex.offset.y = 0;
		tex.flipY = false;
		
		ufoEmissiveTex = new THREE.TextureLoader().load(texture_path('ufo_lights'), function(tex){
			tex.image = correct_texture_size(tex.image);
			loaded.ufo_lights = true;
			set_loading_desc("Ufo lights loaded");

			tex.minFilter = globalFilter;
			tex.magFilter = globalFilter;
			tex.repeat.x = tex_frame_w/tex.image.width;
			tex.repeat.y = tex_frame_h/tex.image.height;
			tex.offset.x = 0;
			tex.offset.y = 0;
			tex.flipY = false;
		}, null, function(err){
			loaded.ufo_lights = true;
			show_texture_loading_warning(err);
		});
		
		ufoNormalTex = new THREE.TextureLoader().load(texture_path('ufo_normalmap'), function(tex){
			tex.image = correct_texture_size(tex.image);
			loaded.ufo_normalmap = true;
			set_loading_desc("Ufo normalmap loaded");

			tex.minFilter = globalFilter;
			tex.magFilter = globalFilter;
			tex.repeat.x = tex_frame_w/tex.image.width;
			tex.repeat.y = tex_frame_h/tex.image.height;
			tex.offset.x = 0;
			tex.offset.y = 0;
			tex.flipY = false;
		}, null, function(err){
			loaded.ufo_normalmap = true;
			show_texture_loading_warning(err);
		});
		

		let geometry = new THREE.PlaneGeometry(mesh_w, mesh_h);
		let material = new THREE.MeshPhongMaterial({map: ufoTex, color: 0xFFFFFF});  			
		material.color.set(0xFFFFFF);
		material.transparent = true;
		material.alphaTest = 0.5;
		material.side = THREE.DoubleSide;
		
		material.emissive.set(0xFFFFFF);
		material.emissiveMap = ufoEmissiveTex;
		material.emissiveIntensity = 0.6;
		
		material.normalMap = ufoNormalTex;
		material.normalScale = new THREE.Vector2(1, 1);
		material.reflectivity = 0.8; // shininess / metalness
		material.specular = new THREE.Color(0x050505);
		material.envMap = reflectionCube;
		//material.envMap = textureCube;

		let mesh = new THREE.Mesh(geometry, material);
		let mscale = 1;
		mesh.position.x = 316;
		mesh.position.y = Z_PLANE;
		mesh.position.z = -3850;
		
		mesh.rotation.x = -Math.PI/2;
		mesh.scale.set(mscale,-mscale,mscale);
		
		var i = add_player(mesh, TYPE_HELI);
		
		scene.add(mesh);
	});
	
	


	helicopterTex = new THREE.TextureLoader().load(texture_path('helicopter_texture'), function(tex){
		tex.image = correct_texture_size(tex.image);
		loaded.helicopter = true;
		set_loading_desc("Helicopter loaded");
		
		

		let scale = 2;
		let mesh_w = (991+2)/scale;
		let mesh_h = (208+2)/scale;
		let frames_x = 2;
		let tex_frame_w = mesh_w*scale;
		let tex_frame_h = mesh_h*scale;
		


		let sprite_name = 'heli_spin';
		initialize_sprite(sprite_name, tex_frame_w, tex_frame_h, tex.image.width, tex.image.height, frames_x);
		
		/*
		
9 , 39
999 , 246

991 x 208

		*/
		
		
				
		tex.minFilter = globalFilter;
		tex.magFilter = globalFilter;
		tex.repeat.x = tex_frame_w/tex.image.width;
		tex.repeat.y = tex_frame_h/tex.image.height;
		tex.offset.x = 0;
		tex.offset.y = 0;
		tex.flipY = false;
		
		helicopterEmissiveTex = new THREE.TextureLoader().load(texture_path('helicopter_lights_sprite_url'), function(tex){
			tex.image = correct_texture_size(tex.image);
			loaded.helicopter_lights = true;
			set_loading_desc("Helicopter lights loaded");

			tex.minFilter = globalFilter;
			tex.magFilter = globalFilter;
			tex.repeat.x = tex_frame_w/tex.image.width;
			tex.repeat.y = tex_frame_h/tex.image.height;
			tex.offset.x = 0;
			tex.offset.y = 0;
			tex.flipY = false;
		}, null, function(err){
			loaded.helicopter_lights = true;
			show_texture_loading_warning(err);
		});
		
		helicopterNormalTex = new THREE.TextureLoader().load(texture_path('helicopter_normalmap'), function(tex){
			tex.image = correct_texture_size(tex.image);
			loaded.helicopter_normalmap = true;
			set_loading_desc("Helicopter normalmap loaded");

			tex.minFilter = globalFilter;
			tex.magFilter = globalFilter;
			tex.repeat.x = tex_frame_w/tex.image.width;
			tex.repeat.y = tex_frame_h/tex.image.height;
			tex.offset.x = 0;
			tex.offset.y = 0;
			tex.flipY = false;
		}, null, function(err){
			loaded.helicopter_normalmap = true;
			show_texture_loading_warning(err);
		});
		

		let geometry = new THREE.PlaneGeometry(mesh_w, mesh_h);
		let material = new THREE.MeshPhongMaterial({map: helicopterTex, color: 0xFFFFFF});  			
		material.color.set(0xFFFFFF);
		material.transparent = true;
		material.alphaTest = 0.5;
		material.side = THREE.DoubleSide;
		
		material.emissive.set(0xFFFFFF);
		material.emissiveMap = helicopterEmissiveTex;
		material.emissiveIntensity = 0.6;
		
		material.normalMap = helicopterNormalTex;
		material.normalScale = new THREE.Vector2(1, 1);
		material.reflectivity = 0.075; // shininess / metalness
		material.specular = new THREE.Color(0x050505);
		material.envMap = reflectionCube;
		//material.envMap = textureCube;

		let mesh = new THREE.Mesh(geometry, material);
		let mscale = 1;
		mesh.position.x = 300;
		mesh.position.y = Z_PLANE;
		mesh.position.z = -4000;
		
		
		mesh.rotation.x = -Math.PI/2;
		mesh.scale.set(mscale,-mscale,mscale);
		
	
		var i = add_player(mesh, TYPE_HELI);
		scene.add(mesh);
	});
	
	

	
	
	planeTex = new THREE.TextureLoader().load(texture_path('plane_sprite_url'), function(tex){
		tex.image = correct_texture_size(tex.image);
		loaded.plane = true;
		set_loading_desc("Plane loaded");
		
		// "airplane"
		//let scale = 6;
		//let mesh_w = (798+2)/scale;//399;
		//let mesh_h = (608+2)/scale;//304;
		//let frames_x = 5;
		
		// "complane"
		let scale = 1;
		let mesh_w = (932+2)/scale;//399;
		let mesh_h = (1022+2)/scale;//304;
		let frames_x = 4;
/*
72 , 1
1003 , 1022

932 x 1022
*/
	
		let tex_frame_w = mesh_w*scale;
		let tex_frame_h = mesh_h*scale;
		


		let sprite_name = 'plane_spin';
		initialize_sprite(sprite_name, tex_frame_w, tex_frame_h, tex.image.width, tex.image.height, frames_x);
		//ANIMATIONS['plane_flipping'] = add_animation_sequence(sprite_name, ['spin_to_down', 'spin_to_up'], 0.5, function(){plane_flipping = 0;});

		tex.minFilter = globalFilter;
		tex.magFilter = globalFilter;
		tex.repeat.x = tex_frame_w/tex.image.width;
		tex.repeat.y = tex_frame_h/tex.image.height;
		tex.offset.x = 0;
		tex.offset.y = 0;
		tex.flipY = false;
		//tex.encoding = THREE.LinearEncoding;
		//tex.minFilter = THREE.NearestFilter;
		//tex.magFilter = THREE.NearestFilter;
		
		planeEmissiveTex = new THREE.TextureLoader().load(texture_path('plane_lights_sprite_url'), function(tex){
			tex.image = correct_texture_size(tex.image);
			set_loading_desc("Plane lights loaded");
		
			tex.minFilter = globalFilter;
			tex.magFilter = globalFilter;
			tex.repeat.x = tex_frame_w/tex.image.width;
			tex.repeat.y = tex_frame_h/tex.image.height;
			tex.offset.x = 0;
			tex.offset.y = 0;
			tex.flipY = false;
			//tex.encoding = THREE.LinearEncoding;
			//tex.minFilter = THREE.NearestFilter;
			//tex.magFilter = THREE.NearestFilter;
			
			loaded.plane_lights = true;
		}, null, function(err){
			loaded.plane_lights = true;
			show_texture_loading_warning(err);
		});
		
		planeNormalTex = new THREE.TextureLoader().load(texture_path('plane_normalmap'), function(tex){
			tex.image = correct_texture_size(tex.image);
			set_loading_desc("Plane normalmap loaded");
		
			tex.minFilter = globalFilter;
			tex.magFilter = globalFilter;
			tex.repeat.x = tex_frame_w/tex.image.width;
			tex.repeat.y = tex_frame_h/tex.image.height;
			tex.offset.x = 0;
			tex.offset.y = 0;
			tex.flipY = false;
			//tex.encoding = THREE.LinearEncoding;
			//tex.minFilter = THREE.NearestFilter;
			//tex.magFilter = THREE.NearestFilter;
		
			loaded.plane_normalmap = true;
		}, null, function(err){
			loaded.plane_normalmap = true;
			show_texture_loading_warning(err);
		});
	

		let geometry = new THREE.PlaneGeometry(mesh_w, mesh_h);
		let material = new THREE.MeshPhongMaterial({map: planeTex, color: 0xFFFFFF});  			
		material.color.set(0xFFFFFF);
		material.transparent = true;
		material.alphaTest = 0.5;
		material.side = THREE.DoubleSide;
		
		material.emissive.set(0xFFFF55);
		material.emissiveMap = planeEmissiveTex;
		material.emissiveIntensity = 1;

		material.normalMap = planeNormalTex;
		material.normalScale = new THREE.Vector2(1, 1);
		
		material.reflectivity = 0.2; // shininess / metalness
		//material.specular = new THREE.Color(0x333333);
		material.envMap = reflectionCube;
		//material.envMap = textureCube;
	
		
		let mesh = new THREE.Mesh(geometry, material);
		let mscale = 1;
		mesh.position.x = 100;
		mesh.position.z = -4150;
		mesh.position.y = Z_PLANE;

		mesh.rotation.x = -Math.PI/2;
		mesh.scale.set(-mscale,mscale,mscale);
	
		var i = add_player(mesh, TYPE_PLANE);
		change_player(i);
		scene.add(mesh);

	});

	// todo: add rgba possibility here...
	function buildAlphaMaterial(params){
		const material = new THREE.MeshLambertMaterial(params);
		
		material.onBeforeCompile = function ( shader ) {
			shader.uniforms.time = { value: 0 };
			shader.vertexShader = 'uniform float time;\n' + shader.vertexShader;
			shader.vertexShader = shader.vertexShader.replace(
				'#include <begin_vertex>',
				[
					`float theta = sin( time + position.y ) / 2;`,
					'float c = cos( theta );',
					'float s = sin( theta );',
					'mat3 m = mat3( c, 0, s, 0, 1, 0, -s, 0, c );',
					'vec3 transformed = vec3( position ) * m;',
					'vNormal = vNormal * m;'
				].join( '\n' )
			);
			material.userData.shader = shader;
		};

		// Make sure WebGLRenderer doesnt reuse a single program
		//material.customProgramCacheKey = function () {
		//	return amount;
		//};

		return material;
	}

	// create map plane:
	{
	
		set_loading_desc("Generating reflection layer");
		
		var mapMaterial = new THREE.MeshLambertMaterial( { envMap: textureCube } );
		mapMaterial.color.set(0xffffff);
		mapMaterial.vertexColors = THREE.VertexColors;
		
		var geometry = new THREE.PlaneBufferGeometry( mapsize, mapsize, terrainVerts, terrainVerts );
		var count = geometry.attributes.position.count;
	
		let BPP = 3; // need buildAlphaMaterial() finished to alpha channel to work.
		geometry.setAttribute('color', new THREE.BufferAttribute(new Float32Array(count*BPP), BPP));
		
		terrain = new THREE.Mesh(geometry, mapMaterial);
		terrain.visible = SHOW_WAVE_BG;
		terrain.rotation.x = -Math.PI / 2;
		
		var peak = 8;
		var smoothing = 600;
		var vertices = terrain.geometry.attributes.position.array;
		var perlin = new Perlin();
		for(var i = 0; i <= vertices.length; i += 3){
			vertices[i+2] = peak * perlin.noise(
				(terrain.position.x + vertices[i+0])/smoothing, 
				(terrain.position.z + vertices[i+1])/smoothing
			);
		}
		terrain.geometry.attributes.position.needsUpdate = true;
		terrain.geometry.computeVertexNormals();
		
		// flatten the terrain:
		vertices = terrain.geometry.attributes.position.array;
		//var colors = terrain.geometry.attributes.color.array;
		for(var i = 0, c = 0; i <= vertices.length; i += 3, c+=BPP){
			vertices[i+2] = Z_SKYBOX+5;
		
		
			// default color to white:
			//colors[c+0] = 1.16;//1.2+(Math.random())*0.5;//Math.random()*3;
			//colors[c+1] = 1.16;//1.2+(Math.random())*0.5;//Math.random()*3;
			//colors[c+2] = 1.10;//1.2+(Math.random())*0.5;
			
			// stretch edge + fade to black:
			if(vertices[i+0] <= -mapsize/2){
				vertices[i+0] = -mapsize;
				//colors[c+0] = 0;
				//colors[c+1] = 0;
				//colors[c+2] = 0;
			}
			if(vertices[i+0] >= mapsize/2){
				vertices[i+0] = mapsize;
				//colors[c+0] = 0;
				//colors[c+1] = 0;
				//colors[c+2] = 0;
			}
			if(vertices[i+1] <= -mapsize/2){
				vertices[i+1] = -mapsize;
				//colors[c+0] = 0;
				//colors[c+1] = 0;
				//colors[c+2] = 0;
			}
			if(vertices[i+1] >= mapsize/2){
				vertices[i+1] = mapsize;
				//colors[c+0] = 0;
				//colors[c+1] = 0;
				//colors[c+2] = 0;
			}
		}
		terrain.geometry.attributes.position.needsUpdate = true;
		//console.log("terrain.geometry.attributes");
		//console.log(terrain.geometry.attributes);
		//terrain.geometry.attributes.color.needsUpdate = true;
		
		
		scene.add(terrain);
		
		set_loading_desc("Reflection layer loaded");
		
		
	}
	

	
	renderer = new THREE.WebGLRenderer( { antialias: antialiasing });
	renderer.autoClear = false;
	renderer.setPixelRatio(window.devicePixelRatio);
	renderer.setSize(window.innerWidth, window.innerHeight);
	document.body.appendChild(renderer.domElement);
	
	MAX_TEX_SIZE = renderer.capabilities.maxTextureSize;
	console.warn("renderer.capabilities:");
	console.warn(renderer.capabilities);
	
	renderer.domElement.addEventListener('webglcontextlost', (e) => {
		push_message("ERROR: GL CONTEXT LOST. BROWSER RESTART MAY BE REQUIRED TO CONTINUE.", true, 20000);
	}, false);
	
	renderer.domElement.addEventListener('webglcontextrestored', (e) => {
		push_message("GL CONTEXT RESTORED", true);
	}, false);
	


	console.log("maxTextureSize = "+MAX_TEX_SIZE);
		
		/*
		
	{
		var container = document.getElementById( 'container' );

		camera2 = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 5000 );
		camera2.position.set( 500, 350, 750 );

		scene2 = new THREE.Scene();

		renderer2 = new CSS3DRenderer();
		renderer2.setSize( window.innerWidth, window.innerHeight );
		container.appendChild( renderer2.domElement );
		
		// Block iframe events when dragging camera

		var blocker = document.getElementById('blocker');
		blocker.style.display = 'none';

		document.addEventListener('mousedown', function (){
			blocker.style.display = '';
		});
		document.addEventListener('mouseup', function (){
			blocker.style.display = 'none';
		});
	}
*/
	//var container = document.getElementById( 'container' );
	
	//renderer2 = new CSS3DRenderer();
	//renderer2.setSize( window.innerWidth, window.innerHeight );
	//container.appendChild( renderer2.domElement );

/*
	var group = new THREE.Group();
	group.add( new YoutubeEmbed( 'TlLijkYQjlw', 0, 0, 240, 0 ) );
	group.add( new YoutubeEmbed( 'RbtgTFGDkxA', 240, 0, 0, Math.PI / 2 ) );
	group.add( new YoutubeEmbed( 'fuyZFMRtXGs', 0, 0, - 240, Math.PI ) );
	group.add( new YoutubeEmbed( 'uqj9j-qz4AE', - 240, 0, 0, - Math.PI / 2 ) );
	scene.add( group );
*/
	//controls = new TrackballControls( camera, renderer.domElement );
	//controls.rotateSpeed = 4;


	

	window.addEventListener('resize', onWindowResize, false);


	set_loading_desc("Initialization done");

}





function onWindowResize() {
	CANVAS_W = window.innerWidth;
	CANVAS_H = window.innerHeight;
	
	SCREEN_MID_X = CANVAS_W/2;
	SCREEN_MID_Y = CANVAS_H/2;
	
	rescale_skybox();

	camera.aspect = window.innerWidth / window.innerHeight;

	camera.left = window.innerWidth * camera.aspect / -2;
    camera.right = window.innerWidth * camera.aspect / 2;
	
	camera.top = window.innerHeight * camera.aspect / 2;
    camera.bottom = window.innerHeight * camera.aspect / -2;
	
	camera.updateProjectionMatrix();
	
	renderer.setSize(window.innerWidth, window.innerHeight);
	
	console.log("window new size: "+window.innerWidth+"x"+window.innerHeight);

}




$(window).focus(function() {
    window_focus = true;
	play_sound("_blip2");
	if(!game_paused_by_enter){
		game_paused = false;
		game_paused_by_enter = false;
		update_pause_screen();
	}
}).blur(function() {
    window_focus = false;
	play_sound("_blip2");
	if(!game_paused_by_enter){
		game_paused = true;
		game_paused_by_enter = false;
		update_pause_screen();
	}
});




function animate() {
	let f = requestAnimationFrame(animate); // pauses when window not visible.
	render(f);
}








function updateFPS(){
	if(prevFpsTime == 0){
		prevFpsTime = getTimeMillis();
		return;
	}
	let ms = getTimeMillis()-prevFpsTime;
	let fps = 1000/(ms/framesPerFps);
	$('#fps').html("FPS: "+fps.toFixed(1));
	prevFpsTime = getTimeMillis();
}






// returns null if no intersection.
// returns [x,y] if intersects.
function line_intersect_line(x1, y1, x2, y2, x3, y3, x4, y4) {
	if ((x1 === x2 && y1 === y2) || (x3 === x4 && y3 === y4)){ // Check if none of the lines are of length 0
		return null;
	}
	let denominator = ((y4-y3)*(x2-x1)-(x4-x3)*(y2-y1));	
	if(denominator === 0){ // Lines are parallel
		return null;
	}
	let ua = ((x4-x3)*(y1-y3)-(y4-y3)*(x1-x3)) / denominator;
	let ub = ((x2-x1)*(y1-y3)-(y2-y1)*(x1-x3)) / denominator;
	if(ua < 0 || ua > 1 || ub < 0 || ub > 1){ // is the intersection along the segments
		return null;
	}
	// Return a object with the x and y coordinates of the intersection
	return [x1+ua*(x2-x1), y1+ua*(y2-y1)];
}




let portals = [];


/*
	spawn_portal({
		'size': 200.0,
		'shape': 1, // 0 = circle, 1 = line. todo: use ellipse
		'unidirectional': true, // can the object go in from both ends.
		'preserve_position': true, // does object come out of other end at same relative position to portal it came in it?
		'preserve_angle': true, // is the incoming object rotated to the outgoing portal angle?
		'points' = [
			{ // startpoint
				'x': 327,
				'y': -770,
				'angle': 126.0,
			},
			{ // endpoint
				'x': 211,
				'y': -51,
				'angle': 256.0,
			},
		],
*/

// todo: process portals.
function spawn_portal(portal){

	for(let i = 0; i < 2; i++){
		let x = portal.points[i].x;
		let z = portal.points[i].y;
		let angle = portal.points[i].angle;
		let color = portal.points[i].color;

		let foundIndex = -1; // todo: add find_free_portal() later
		
		let mesh;
		
		if(foundIndex == -1){
			// create size of 1 and then scale it to correct size, so translate works easier.
			let geometry = new THREE.PlaneGeometry(1, 1);
			let material = new THREE.MeshPhongMaterial();
			material.color.set(color);
			material.transparent = false;
			material.opacity = 0.7;
			material.side = THREE.DoubleSide;
			
			//geometry.translate(0, 0, 0);
			mesh = new THREE.Mesh(geometry, material);
			
			mesh.scale.set(5, portal.size, 1);
			
		}else{
			mesh = portal.points[i].mesh;
			mesh.visible = true;
		}

		mesh.rotation.x = Math.PI/2;
		 // todo: LOL remove 90 deg shit and fix the checking function.
		mesh.rotation.z = (180-angle)*(Math.PI/180.0)+90;

		mesh.position.x = x;
		mesh.position.y = Z_PORTAL;
		mesh.position.z = z;

		
		// if was new portal, update mesh/texture too, and add to array/scene:
		if(foundIndex == -1){
			portal.points[i]['mesh'] = mesh;
			
			scene.add(mesh);
		}
	}
	
	portals.push(portal);
	
	console.warn("portals:");
	console.warn(portals);
}


// portals
function spawn_portals(){
	return;
	spawn_portal({
		'size': 200.0,
		'alive': true,
		'shape': 1, // 0 = circle, 1 = line. todo: use ellipse
		'unidirectional': true, // can the object go in from both ends.
		'preserve_position': true, // does object come out of other end at same relative position to portal it came in it?
		'preserve_angle': true, // is the incoming object rotated to the outgoing portal angle?
		'points': [
			{ // startpoint
				'x': 327,
				'y': -770,
				'angle': 126.0,
				'color': 0xFF0000,
			},
			{ // endpoint
				'x': 211,
				'y': -51,
				'angle': 256.0,
				'color': 0xFFFF00,
			},
		],
	});
}






function post_init(){
	generate_sounds();
	
	spawn_bombers();
	


	console.log("GRAVITY");
	console.log(GRAVITY);
	
	
	if(mapinfo.hasOwnProperty("units")){
		load_units(mapinfo.units);
	}
	
	spawn_portals();
	
	
	
	let use_db = 0;
	
	if(use_db){
		let db_version = 1;
		let db;
		const DBOpenRequest = window.indexedDB.open('test', db_version);

		DBOpenRequest.onerror = (event) => {
			console.warn("error loading db");
			console.warn(event);
		};

		DBOpenRequest.onsuccess = (event) => {
			console.log("loading db");
			console.log(event);

			// Store the result of opening the database in the db variable. This is used a lot below
			db = DBOpenRequest.result;

			console.log("db");
			console.log(db);
		};
	}
	
	
	gameLoadedVar = true;
	
	
	
	onWindowResize();

}




function reset_globals(){
	gameLoadedVar = false;
	// todo, add all other globals, or better, make it into a class...
	
	for(let key in loaded){
		if(loaded.hasOwnProperty(key)){
			loaded[key] = false;
		}
	}
	
}

function stringify(obj){
	return JSON.stringify(obj);
}



// map_loaded
function game_loaded(){

	if(gameLoadedVar) return true;
	
	for(let key in loaded){
		if(loaded.hasOwnProperty(key)){
			if(!loaded[key]){
				return false;
			}
		}
	}
	
	for(let i = 0; i < MAP_PIECES.length; i++){
		for(let p = 0; p < MAP_PIECES[i].length; p++){
			if(!MAP_PIECES[i][p].LOADED){
				return false;
			}
		}
	}
	
	
	console.log("MAP_PIECES");
	console.log(MAP_PIECES);
	


	//let renderlayer = renderer.getSize();
	//SCREEN_MID_X = CANVAS_W/2;//renderlayer.width/2;
	//SCREEN_MID_Y = CANVAS_H/2;//renderlayer.height/2;
	

	console.warn("game loaded.");
	console.warn(stringify(GRAVITY));
	
	set_loading_desc("Post-initialization");
		
	console.log("game loaded... post initializating...");
	
	post_init();

	let game_loading_time = (getTimeMillis()-loading_start_time)/1000;
	console.log("GAME LOADED IN "+game_loading_time.toFixed(3)+" seconds");
	
	show_messages();
	push_message("Game loaded in "+game_loading_time.toFixed(3)+" seconds");
	
	
	
	return true;
}






function hits_turret(owner, x, z){
	let offset_x = 0;
	let offset_z = 0;
	let object_w = 50; // hitbox size
	let object_h = 50;
	let hw = object_w/2;
	let hh = object_h/2;
	
	for(var i = 0; i < turrets.length; i++){
		let turret = turrets[i];
		if(turret.alive && turret.owner != owner){
			if(point_inside_rect(x, z, 
				turret.mesh.position.x-hw+offset_x, 
				turret.mesh.position.z-hh+offset_z, 
				turret.mesh.position.x+hw+offset_x, 
				turret.mesh.position.z+hh+offset_z
			)){
				return i;
			}
		}
	}
	return -1;
}


function hits_player(owner, x, z){
	let offset_x = 0;
	let offset_z = 0;
	let object_w = 40; // hitbox size
	let object_h = 40;
	let hw = object_w/2;
	let hh = object_h/2;
	
	for(var i = 0; i < players.length; i++){
		let player = players[i];
		if(player.alive && player.owner != owner){
			if(point_inside_rect(x, z, 
				player.x-hw+offset_x, 
				player.z-hh+offset_z, 
				player.x+hw+offset_x, 
				player.z+hh+offset_z
			)){
				return i;
			}
		}
	}
	return -1;
}


function hits_bomber(owner, x, z){
	let offset_x = 20;
	let offset_z = 30;
	let bomber_w = 740; // hitbox size
	let bomber_h = 80;
	let hw = bomber_w/2;
	let hh = bomber_h/2;
	
	for(var i = 0; i < bombers.length; i++){
		let bomber = bombers[i];
		if(bomber.alive && bomber.owner != owner){
			if(point_inside_rect(x, z, 
				bomber.x-hw+offset_x, 
				bomber.z-hh+offset_z, 
				bomber.x+hw+offset_x, 
				bomber.z+hh+offset_z
			)){
				return i;
			}
		}
	}
	return -1;
}

function explode_bomber(bomberHit, explosion_type){
	if(typeof explosion_type === "undefined"){
		explosion_type = EXPLOSION_ROUND;
	}
	let bomber = bombers[bomberHit];
	if(bomber.explode_time == -1){
		bomber.health = 0;
		bomber.explode_time = getTimeMillis();
		
		bomber.alive = false;
		bomber.mesh.visible = false;
		
		play_sound("explosion_bomb", bomber.x, bomber.z);
		explode_at(bomber.x, bomber.z, explosion_type, EXPLOSION_HUGE3);
		
		if(total_bombers_alive() == 0){
			spawn_bombers();
		}
	}
}


function explode_turret(turretHit, explosion_type){
	if(typeof explosion_type === "undefined"){
		explosion_type = EXPLOSION_ROUND;
	}
	let turret = turrets[turretHit];
	//if(turret.explode_time == -1){
		turret.health = 0;
		//turret.explode_time = getTimeMillis();
		
		turret.alive = false;
		turret.barrel_mesh.visible = false; // hide barrel once blown up.
		
		play_sound("explosion_bomb", turret.x, turret.z);
		explode_at(turret.x, turret.z, explosion_type, EXPLOSION_HUGE);
	//}
}

function respawn_turret(turretIndex){
	let turret = turrets[turretIndex];
	turret.health = 400;
	turret.alive = true;
	turret.barrel_mesh.visible = true;
	
	let framename = turret_type_to_idleframe(turret.type);
	let pos = frame_offset('turret', framename, 0);
	turret.texture.offset.x = pos.x;
	turret.texture.offset.y = pos.y;
}


function hit_bomber(bomberHit, damage){
	let bomber = bombers[bomberHit];				
	bomber.hit_time = getTimeMillis();
	bomber.health -= damage;
	if(bomber.health <= 0){
		explode_bomber(bomberHit);
	}else if(bomber.health <= bomber.health_falling){
		bomber.falling = true;
	}else if(bomber.health <= bomber.health_smokestart){
		bomber.smokestart = true;
	}
}
	
function hit_player(i, damage){
	let player = players[i];
	player.hit_time = getTimeMillis();
	player.health -= damage;
	/*
	if(player.health <= 0){
		explode_bomber(i);
	}else if(player.health <= player.health_smokestart){
		player.smokestart = true;
	}
	*/
}


function hit_turret(turretHit, damage){
	let turret = turrets[turretHit];				
	turret.hit_time = getTimeMillis();
	turret.health -= damage;
	if(turret.health <= 0){
		// update frame to dead:
		let framename = turret_type_to_deadframe(turret.type);
		let pos = frame_offset('turret', framename, 0);
		turret.texture.offset.x = pos.x;
		turret.texture.offset.y = pos.y;
		
		explode_turret(turretHit);
		
	}else if(turret.health <= turret.health_smokestart){
		turret.smokestart = true;
	}
}


var loadingTextVisible = true;


var santaFrameIndex = 0;
var explosionFrameNumber = 0;
var soldierFrameIndex = 0;

var prevShootTime = 0;
var shooting_started = false;
var can_shoot = false;

var shooting_imprecision = 0.5; // in degrees.
var frameTime_val = getTimeMillis();
var frameNumber_val = 0;

let ANGLE_MULTI = 1;
let SPEED_MULTI = 1;

var rotatePlayer = 0;

var prevShootStartTime = 0;

function frameTime(){
	return frameTime_val;
}
function frameNumber(){
	return frameNumber_val;
}


function get_gravity_angle(x,z){
	if(GRAVITY.style == GRAVITY_CIRCULAR){
		let kx = 0;
		let kz = 0;
		for(let i = 0; i < GRAVITY.points.length; i++){
			//a = get_angle(cpx, cpz, GRAVITY.point.x, GRAVITY.point.z);
			let dire = new get_kxy(x, z, GRAVITY.points[i].x, GRAVITY.points[i].z);
			let force = get_force(x, z, GRAVITY.points[i]);
			kx += dire.x*force;
			kz += dire.z*force;
		}
		//let a = get_angle(x, z, GRAVITY.point.x, GRAVITY.point.z);
		// must be set after lookAt(), and as fixed value rather than addition/substraction.
		// no idea why needs 90 degree change..
		return 90-get_angle(0,0,kx,kz);
	}else{
		return 0;
	}
}


function get_gravity_angle_debug(x,z){
/*
	console.warn("----------------------------------------------");
	console.warn("Gravity for unit position: "+x.toFixed(3)+","+z.toFixed(3)+":");
	console.warn("total "+GRAVITY.points.length+" gravity points:");
	console.warn(stringify(GRAVITY.points));
	*/
	
	if(GRAVITY.style == GRAVITY_CIRCULAR){
		let kx = 0;
		let kz = 0;
		for(let i = 0; i < GRAVITY.points.length; i++){
			//a = get_angle(cpx, cpz, GRAVITY.point.x, GRAVITY.point.z);
			let dire = new get_kxy(x, z, GRAVITY.points[i].x, GRAVITY.points[i].z);

			let dist = get_dist_2d(x, z, GRAVITY.points[i].x, GRAVITY.points[i].z);
			if(dist < GRAVITY.points[i].minradius){
				dist = GRAVITY.points[i].minradius;
			}
			
			let force = GRAVITY.value * (6000000/(dist*dist));
			kx += dire.x*force;
			kz += dire.z*force;
			
			/*
			console.warn("--------------------");
			console.warn("GRAVITY x = "+GRAVITY.points[i].x.toFixed(3));
			console.warn("GRAVITY z = "+GRAVITY.points[i].z.toFixed(3));
			console.warn("dist = "+dist.toFixed(3));
			console.warn("dist^2 = "+(dist*dist).toFixed(3));
			console.warn("force = "+force.toFixed(3));
			console.warn("dire.x = "+dire.x.toFixed(3));
			console.warn("dire.z = "+dire.z.toFixed(3));
			console.warn("dire.x*force = "+(dire.x*force).toFixed(3));
			console.warn("dire.z*force = "+(dire.z*force).toFixed(3));
			console.warn("kx = "+kx.toFixed(3));
			console.warn("kz = "+kz.toFixed(3));
			
			*/
		}
		//let a = get_angle(x, z, GRAVITY.point.x, GRAVITY.point.z);
		// must be set after lookAt(), and as fixed value rather than addition/substraction.
		// no idea why needs 90 degree change..
		let out = 90-get_angle(0,0,kx,kz);
		//console.warn("angle = "+out);
		return out;
	}else{
		console.error("WTF");
		return 0;
	}
}



function get_force(x, z, point){
	let dist = get_dist_2d(x, z, point.x, point.z);
	if(dist > point.range){
		//dist = point.range;
	}
	let dist_percent = dist/point.minradius;
	if(dist_percent > 1) dist_percent = 1;
	
	if(dist < point.minradius){
		dist = point.minradius;
	}
	
	return GRAVITY.value * ((6000000*dist_percent)/(dist*dist));
}


function apply_gravity(obj){
	if(GRAVITY.style == GRAVITY_CIRCULAR){
		for(let i = 0; i < GRAVITY.points.length; i++){
			let point = GRAVITY.points[i];
			let gdir = new get_kxy(obj.x, obj.z, point.x, point.z);
			let force = get_force(obj.x, obj.z, point);
			obj.kx += gdir.x*force;
			obj.kz += gdir.z*force;
		}
	}else{
		// default to linear gravity.
		obj.kz += GRAVITY.value;
	}
}


function get_force_for_planet(target, curplanet){
	let dist = get_dist_2d(target.x, target.z, curplanet.x, curplanet.z);
	
	let dist_percent = dist/curplanet.minradius;
	if(dist_percent > 1) dist_percent = 1;
	
	if(dist < curplanet.minradius){
		dist = curplanet.minradius;
	}
	
	return GRAVITY.value * ((6000000*dist_percent)/(dist*dist));
}

function apply_gravity_to_planet(this_planet_index){
	let target = PLANETS[this_planet_index];
	for(let i = 0; i < PLANETS.length; i++){
		if(i != this_planet_index){
			let curplanet = PLANETS[i];

			let gdir = new get_kxy(target.x, target.z, curplanet.x, curplanet.z);
			let force = get_force_for_planet(target, curplanet);

			target.kx += gdir.x*force;
			target.kz += gdir.z*force;
		}
	}
}




// todo: add "deadly" rules: if you will lose hp at edges.
function apply_edge_rules(obj){
	if(teleport_from_edges_x){
		if(obj.x < MAP_X1-edgePadX){
			obj.x = MAP_X2+edgePadX;
		}
		if(obj.x > MAP_X2+edgePadX){
			obj.x = MAP_X1-edgePadX;
		}
	}
	if(teleport_from_edges_y){
		if(obj.z < MAP_Y1-edgePadY){
			obj.z = MAP_Y2+edgePadY;
		}
		if(obj.z > MAP_Y2+edgePadY){
			obj.z = MAP_Y1-edgePadY;
		}
	}
}


function get_trajectory_points(){

	let player = players[myPlayer];

	let dire_bullet = new get_kxy_angle(player.shoot_angle);
	
	let bullet_speed = 20*player.shot_speed_multi;

	let shot = {
		'x': player.x,
		'z': player.z,
		'kx': dire_bullet.x*bullet_speed,
		'kz': dire_bullet.z*bullet_speed,
	};
	
	let curweapon = player.weapons1[player.current1];
	let maxframes = SHOT_FUSETIME;
	if(curweapon == WEAPON_PLANEGUN){
		maxframes = SHOT_FUSETIME;
	}else if(curweapon == WEAPON_BOMB){
		maxframes = BOMB_FUSETIME;
	}else if(curweapon == WEAPON_BOMB_LASER){
		maxframes = BOMB_LASER_FUSETIME;
	}

	let trajectory_points = [];

	for(let i = 0; i < maxframes; i++){
		if((i % 8) == 0){
			trajectory_points.push({
				'x': shot.x, 
				'y': Z_RAIN, 
				'z': shot.z,
			});
		}
		
		shot.x += shot.kx;
		shot.z += shot.kz;
		
		apply_gravity(shot);
		
		if(is_ground(shot.x, shot.z)){
			trajectory_points.push({
				'x': shot.x, 
				'y': Z_RAIN, 
				'z': shot.z,
			});
			break;
		}
	}
	
	return trajectory_points;
}



function create_edge_points(trajectory_points, radius){
	if(typeof radius === "undefined"){
		radius = 0.8;
	}
	let trajectory_points2 = [];
	let trajectory_points3 = [];
	for(let i = 0; i < trajectory_points.length; i++){
		let cur_point = trajectory_points[i];
		let next_index = i+1;
		if(next_index > trajectory_points.length-1){
			next_index = trajectory_points.length-1;
		}
		let next_point = trajectory_points[next_index];
		let angle = get_angle(cur_point.x, cur_point.z, next_point.x, next_point.z);
		let left_dire = new get_kxy_angle(angle-90);
		let right_dire = new get_kxy_angle(angle+90);
		let r = (1/camera.zoom)*radius; // radius<=0.8 is best, doesnt leave holes in middle of line.
		trajectory_points2.push({
			'x': cur_point.x+left_dire.x*r,
			'y': cur_point.y,
			'z': cur_point.z+left_dire.z*r,
		});
		trajectory_points3.push({
			'x': cur_point.x+right_dire.x*r,
			'y': cur_point.y,
			'z': cur_point.z+right_dire.z*r,
		});
	}
	return {
		'left': trajectory_points2,
		'right': trajectory_points3,
	};
}


function render(renderFrame){
	if(game_paused){
		return;
	}
	frameNumber_val++;
	frameTime_val = getTimeMillis();
	

	if(!game_loaded()){
		return;
	}else{
		if(loadingTextVisible){
			$("#loading_container").hide();
			loadingTextVisible = false;
		}
	}
	
	if((frameNumber_val % framesPerFps) == 0){
		updateFPS();
	}
	
	if(guivisible){
		if((frameNumber_val % 5) == 0){
			updateInfo();
		}
	}
	
	

	
	let curplayer = players[myPlayer];
	
	if(key_down(16)){
		if(key_down(90)){
			MOUSE_ANGLE_DETAIL = (Math.random()-0.5)/10000;
		}else if(key_down(226)){
			MOUSE_ANGLE_DETAIL = (Math.random()-0.5)/1000;
		}else{
			MOUSE_ANGLE_DETAIL = (Math.random()-0.5)/100;
		}
	}else{
		MOUSE_ANGLE_DETAIL = 0;
	}

	setShootAngle(myPlayer);

	

	// todo: make it shoot from the position where the mesh is at the end of this frame.
	// currently shoots from previous frame position.
	if(shooting_started){
		
		if(getTimeMillis()-prevShootStartTime > continuous_shoot_delay){
			can_shoot = true;
		}
		
		if(can_shoot){
			if(getTimeMillis()-prevShootTime > planegun_delay){
				shoot_from_myplayer();
				prevShootTime = getTimeMillis();
			}
		}
	}
	


	
	ANGLE_MULTI = key_down(16) ? 0.1 : 1;
	SPEED_MULTI = key_down(16) ? 0.1 : 1;
	
	
	if(curplayer.type == TYPE_HELI){
		let helispeed_x = 0.2;
		let helispeed_z = 0.1;
		let helimaxspeed_x = 13;
		let helimaxspeed_z = 15;
		if(key_down(65)){ // 'A'
			curplayer.speed_x -= helispeed_x;
		}
		if(key_down(68)){ // 'D'
			curplayer.speed_x += helispeed_x;
		}
		if(key_down(87)){ // 'W'
			curplayer.speed_z -= helispeed_z;
		}
		if(key_down(83)){ // 'S'
			curplayer.speed_z += helispeed_z;
		}
		
		if(curplayer.speed_x > helimaxspeed_x){
			curplayer.speed_x = helimaxspeed_x;
		}else if(curplayer.speed_x < -helimaxspeed_x){
			curplayer.speed_x = -helimaxspeed_x;
		}
		if(curplayer.speed_z > helimaxspeed_z){
			curplayer.speed_z = helimaxspeed_z;
		}else if(curplayer.speed_z < -helimaxspeed_z){
			curplayer.speed_z = -helimaxspeed_z;
		}
		curplayer.angle = get_angle(0, 0, curplayer.speed_x, curplayer.speed_z);
		curplayer.speed = get_dist_2d(0,0, curplayer.speed_x, curplayer.speed_z);
	}else{
		if(curplayer.type == TYPE_SOLDIER){
		
			
			if(key_down(65)){ // 'A'
				curplayer.angle += 4*ANGLE_MULTI;
				setAngle(myPlayer, curplayer.angle);
			}
			if(key_down(68)){ // 'D'
				curplayer.angle -= 4*ANGLE_MULTI;
				setAngle(myPlayer, curplayer.angle);
			}
			if(key_down(87)){ // 'W'
				curplayer.internal_speed += 0.5;
				if(curplayer.type == TYPE_SOLDIER){
					if(curplayer.internal_speed > 20){
						curplayer.internal_speed = 20;
					}
				}
				setSpeed(myPlayer, curplayer.internal_speed);
				

			}
			if(key_down(83)){ // 'S'
				curplayer.internal_speed -= 1.5;
				setSpeed(myPlayer, curplayer.internal_speed);

			}
		}else{
			if(key_down(65)){ // 'A'
				curplayer.angle += 2*ANGLE_MULTI;
				setAngle(myPlayer, curplayer.angle);
			}
			if(key_down(68)){ // 'D'
				curplayer.angle -= 2*ANGLE_MULTI;
				setAngle(myPlayer, curplayer.angle);
			}
			if(key_down(87)){ // 'W'
				curplayer.internal_speed += 0.5*SPEED_MULTI;
				setSpeed(myPlayer, curplayer.internal_speed);
			}
			if(key_down(83)){ // 'S'
				curplayer.internal_speed -= 1.5*SPEED_MULTI;
				setSpeed(myPlayer, curplayer.internal_speed);
			}
		}
	}
	if(key_down(32)){ // 'space'
		
		
		let allow_bombing = false;
		if(!bombingStarted){
			bombingStarted = true;
			bombStartTime = getTimeMillis();
			allow_bombing = true;
		}
		if(getTimeMillis()-bombStartTime > continuous_shoot_delay){
			if(getTimeMillis()-prevBombTime > bombgun_delay){
				allow_bombing = true;
			}
		}
		if(allow_bombing){
			let x = players[myPlayer].x;
			let z = players[myPlayer].z;
			let dire = new get_kxy_angle(players[myPlayer].angle);
			let speed = players[myPlayer].speed;

			drop_bomb(players[myPlayer].owner, x, z, dire, speed);
			prevBombTime = getTimeMillis();
		}
	}


	for(var i = 0; i < shots.length; i++){
		let shot = shots[i];
		
		if(shot.alive){
			shot.x += shot.kx;
			shot.z += shot.kz;
			
			//shot.kx *= AIR_RESISTANCE;
			apply_gravity(shot);
			apply_edge_rules(shot);
			
			let hit_sound = "explosion_bullet";
			let splash_sound = "bullet_splash";
			let explode = true;
			let explosion_size = EXPLOSION_TINY;
			let glow = true;
			let explosion_type = EXPLOSION_ROUND;
			if(shot.type == WEAPON_SHOTGUN){
				hit_sound = "shotgun_bullet";
				splash_sound = "shotgun_splash";
				explode = true;
				explosion_size = EXPLOSION_SHOTGUN;
				explosion_type = EXPLOSION_ROUND_SMALL;
				glow = false;
			}
			
			let bomberHit = hits_bomber(shot.owner, shot.x, shot.z);
			let playerHit = hits_player(shot.owner, shot.x, shot.z);
			let turretHit = hits_turret(shot.owner, shot.x, shot.z);
			
			if(bomberHit != -1){
				
				play_sound(hit_sound, shot.x, shot.z);
				if(explode){
					explode_at(shot.mesh.position.x, shot.mesh.position.z, explosion_type, explosion_size, glow);
				}

				hit_bomber(bomberHit, 20);
				
				shot.alive = false;
				scene.remove(shots[i].mesh);
			}else if(playerHit != -1){
				play_sound(hit_sound, shot.x, shot.z);
				if(explode){
					explode_at(shot.mesh.position.x, shot.mesh.position.z, explosion_type, explosion_size, glow);
				}

				hit_player(playerHit, 20);
				
				shot.alive = false;
				scene.remove(shots[i].mesh);
			}else if(turretHit != -1){
				play_sound(hit_sound, shot.x, shot.z);
				if(explode){
					explode_at(shot.mesh.position.x, shot.mesh.position.z, explosion_type, explosion_size, glow);
				}

				hit_turret(turretHit, 20);
				
				shot.alive = false;
				scene.remove(shots[i].mesh);
			}else{
			
				let ground_found = is_ground(shot.x, shot.z);
				let underwater = is_underwater(shot);		
				if(ground_found || underwater){	
					shot.alive = false;
					scene.remove(shots[i].mesh);
					
					if(ground_found){
						play_sound(hit_sound, shot.x, shot.z);
						if(explode){
							explode_at(shot.mesh.position.x, shot.mesh.position.z, explosion_type, explosion_size, glow);
						}
					}else if(underwater){
						play_sound(splash_sound, shot.x, shot.z);
						splash_at(shot.mesh.position.x, shot.mesh.position.z, SPLASH_SMALL);
					}
				}

			}
			
			if(shot.alive){
				shot.mesh.position.x = shot.x;
				shot.mesh.position.z = shot.z;
				let angle = get_angle(0, 0, shot.kx, -shot.kz);
				
				shot.mesh.rotation.z = (angle+180)*(Math.PI/180.0);
			}
			
			
			if(frameNumber()-shot.frame_created > shot.fusetime){
				shot.alive = false;
				scene.remove(shots[i].mesh);
				
				play_sound(hit_sound, shot.x, shot.z);
				if(explode){
					explode_at(shot.mesh.position.x, shot.mesh.position.z, explosion_type, explosion_size, glow);
				}
			}
		}
	} // shots
	
	
	
	
	
	for(var i = 0; i < bombs.length; i++){
		let bomb = bombs[i];
		
		if(bomb.alive){
			bomb.x += bomb.kx;
			bomb.z += bomb.kz;
			
			//bomb.kx *= AIR_RESISTANCE;
			apply_gravity(bomb);
			apply_edge_rules(bomb);
			
			let bomb_speed = get_dist_2d(0, 0, bomb.kx, bomb.kz);
			
			if(!bomb.whistling){
				if(bomb_speed > 7){
					//play_sound("bomb_drop", bomb.x, bomb.z);
					bomb.whistling = true;
				}
			}
			
			let explosion_type_round = EXPLOSION_ROUND;
			let explosion_type_flat = EXPLOSION_FLAT;
			let explosion_size = EXPLOSION_LARGE;
			let explosion_color = 0x555555;
			
			if(bomb.type == WEAPON_BOMB_LASER){
				explosion_type_round = EXPLOSION_ROUND_LASER;
				explosion_type_flat = EXPLOSION_ROUND_LASER;
				explosion_size = EXPLOSION_HUGE2;
				explosion_color = 0xAA22AA;
			}
			
			
			let bomberHit = -1;
			if(bomb.owner >= 0){ // only players can hit AI bombers. 
				bomberHit = hits_bomber(bomb.owner, bomb.x, bomb.z);
			}
			let playerHit = hits_player(bomb.owner, bomb.x, bomb.z);
			let turretHit = hits_turret(bomb.owner, bomb.x, bomb.z);
			
			if(bomberHit != -1){
				
				play_sound("explosion_bomb", bomb.x, bomb.z);
				explode_at(bomb.mesh.position.x, bomb.mesh.position.z, explosion_type_round, explosion_size, true, explosion_color);
				
				hit_bomber(bomberHit, 200);
				
				bomb.alive = false;
				scene.remove(bombs[i].mesh);
			}else if(playerHit != -1){
				play_sound("explosion_bomb", bomb.x, bomb.z);
				explode_at(bomb.mesh.position.x, bomb.mesh.position.z, explosion_type_round, explosion_size, true, explosion_color);

				hit_player(playerHit, 200);
				
				bomb.alive = false;
				scene.remove(bombs[i].mesh);
			}else if(turretHit != -1){
				play_sound("explosion_bomb", bomb.x, bomb.z);
				explode_at(bomb.mesh.position.x, bomb.mesh.position.z, explosion_type_round, explosion_size, true, explosion_color);

				hit_turret(turretHit, 200);
				
				bomb.alive = false;
				scene.remove(bombs[i].mesh);
			}else{
			
				let ground_found = is_ground(bomb.x, bomb.z);
				let underwater = is_underwater(bomb);		
				if(ground_found || underwater){					
					bomb.alive = false;
					//bomb.mesh.visible = false;
					scene.remove(bombs[i].mesh);
					
					if(ground_found){
						play_sound("explosion_bomb", bomb.x, bomb.z);
						explode_at(bomb.mesh.position.x, bomb.mesh.position.z, explosion_type_flat, explosion_size, true, explosion_color);
					}else if(underwater){
						play_sound("bomb_splash", bomb.x, bomb.z);
						splash_at(bomb.mesh.position.x, bomb.mesh.position.z, SPLASH_MEDIUM);
					}
				}
			}
			
			if(bomb.alive){
				bomb.mesh.position.x = bomb.x;
				bomb.mesh.position.z = bomb.z;
				let angle = get_angle(0, 0, bomb.kx, -bomb.kz);
				bomb.mesh.rotation.z = (angle+180)*(Math.PI/180.0);
			}
			
			if(frameNumber()-bomb.frame_created > bomb.fusetime){
				bomb.alive = false;
				//bomb.mesh.visible = false;
				scene.remove(bombs[i].mesh);
				
				play_sound("explosion_bomb", bomb.x, bomb.z);
				explode_at(bomb.mesh.position.x, bomb.mesh.position.z, explosion_type_round, explosion_size, true, explosion_color);
			}
		}
	} // bombs
	
	
	
	

	if(turrets_enabled){
		for(var i = 0; i < turrets.length; i++){
			let turret = turrets[i];
			turret.trajectory_mesh.visible = false; // hide mesh before updating it below.
			turret.trajectory_real_mesh.visible = false; // hide mesh before updating it below.
	
			if(turret.alive){
				let can_shoot = false;
				if(turret.type == TURRET_ANTIAIR){
					if(frameTime()-turret.shoot_start > 150+randiff(20)){
						can_shoot = true;
					}
				}else if(turret.type == TURRET_BOMBER){
					if(frameTime()-turret.shoot_start > 3000+randiff(200)){
						can_shoot = true;
					}
				}
				
				
				//let curplayer = players[myPlayer];
				
				let target_x = curplayer.x;
				let target_z = curplayer.z;
				
				let dist = get_dist_2d(turret.x, turret.z, target_x, target_z);
				
				if(dist < turret.range){
				
					//console.warn(dist+" < "+turret.range);
					
					// put dist to function so we dont need to calculate it again;
					shoot_turret(turret, OWNER_AI, can_shoot, dist);
				}
			}
		} // turrets
	}
	
	
	for(let i = 0; i < portals.length; i++){
		let portal = portals[i];
		if(portal.alive){
			// do nothing... atm.
		}
	} // portals
	
	function player_intersect_portal(player){
		let dire = new get_kxy_angle(player.angle);

		for(let i = 0; i < portals.length; i++){
			let portal = portals[i];
			let size = portal.size;
			let hsize = size/2;
			
			if(portal.alive){
			
				let maxindex = portal.points.length-1;
				
				for(let p = 0; p <= maxindex; p++){
					let opposite = maxindex-p; // opposite portal index.
					
					let tangle = portal.points[p].angle;
					
					let tx = portal.points[p].x;
					let tz = portal.points[p].y;
					
					let otangle = portal.points[opposite].angle;
					let otx = portal.points[opposite].x;
					let otz = portal.points[opposite].y;
					
					// create player line:
					let px1 = player.x;
					let pz1 = player.z;
					let px2 = px1 + dire.x*player.speed;
					let pz2 = pz1 + dire.z*player.speed;
					
					// create portal start point line:
					let k = new get_kxy_angle(tangle);
					let tx1 = tx-k.x*hsize;
					let tz1 = tz-k.z*hsize;
					let tx2 = tx+k.x*hsize;
					let tz2 = tz+k.z*hsize;
					
					
					// create portal end point line:
					let ok = new get_kxy_angle(otangle);
					let otx1 = otx-k.x*hsize;
					let otz1 = otz-k.z*hsize;
					let otx2 = otx+k.x*hsize;
					let otz2 = otz+k.z*hsize;
					
					// intersects to current portal point?
					let isect = line_intersect_line(
						px1, pz1, px2, pz2,
						tx1, tz1, tx2, tz2
					);
					
					if(isect !== null){
						// get distance to first point of portal line:
						let d = new get_kxy(px1, pz1, tx1, tz1);
						// interpolate to opposite point by this distance:
						let newpos = {
							'x' : otx2+d.x,
							'z' : otz2+d.z,
						};
						let newangle = player.angle - (tangle - otangle);
						return {
							'portal_index': i, 
							'sub_index': p, 
							'opposite_index': opposite,
							'pos': {'x': isect[0], 'z': isect[1]}, 
							'newpos': newpos, 
							'newangle': newangle,
						};
					}
				}
			}
		}
		
		return null;
	}
	

	for(var i = 0; i < bombers.length; i++){
		let bomber = bombers[i];
		
		if(bomber.alive){
			let angle;
			
			bomber.prev_x = bomber.x;
			bomber.prev_z = bomber.z;
			
			let framesX = 1;

			let startX = 0;
			let startY = 0;
			
			let maxFrames = 2; // debug value.
			
			if(bomber.type == PLANE_BOMBER){
				startX = 0;
				startY = 0;
				maxFrames = 1;
			}else if(bomber.type == PLANE_HORNET){
				startX = 0;
				startY = 1;
				maxFrames = 1;
			}else if(bomber.type == PLANE_UFO){
				startX = 0;
				startY = 2;
				maxFrames = 1;
			}
			
			if(GRAVITY.style == GRAVITY_CIRCULAR){
				// on point gravity mode bombers cant fall down (since they actually orbit earth and are thus falling already).
				let dirmulti = (bomber.direction == 1) ? -1 : 1;
				let dire = new get_kxy_angle((dirmulti*frameNumber()/100)*bomber.speed);
				bomber.x = dire.x*bomber.distance;
				bomber.z = dire.z*bomber.distance;

				angle = 180+180-get_angle(bomber.prev_x, bomber.prev_z, bomber.x, bomber.z);
			}else{
				// default to linear gravity.
				bomber.x += bomber.kx;
				bomber.z += bomber.kz;
				if(bomber.falling){
					//bomber.kx *= 0.995;
					bomber.kz += 0.02;
				}
				angle = get_angle(0, 0, bomber.kx, -bomber.kz);
			}
			
			
			

			
			// teleport from edges:
			apply_edge_rules(bomber);

		
			let ground_found = is_ground(bomber.x, bomber.z);
			let underwater = is_underwater(bomber);
			if(ground_found || underwater){
				bomber.alive = false;
				bomber.mesh.visible = false;
				
				if(ground_found){
					play_sound("explosion_bomb", bomber.x, bomber.z);
					
					explode_bomber(i, EXPLOSION_FLAT);
				}else if(underwater){
					play_sound("plane_splash", bomber.x, bomber.z);
					
					splash_at(bomber.x, bomber.z, SPLASH_HUGE2);
					explode_bomber(i, EXPLOSION_FLAT);
				}
			}
			

			if(bomber.bombing_start_time != -1){
				if(frameTime() - bomber.bombing_start_time < 2000){
					if(frameTime() - bomber.last_bomb_time > 250){
						let dire = new get_kxy_angle(angle);
						let speed = bomber.kx;
						drop_bomb(bomber.owner, bomber.x, bomber.z+33, dire, speed, true);
						bomber.last_bomb_time = frameTime();
					}
				}else{
					bomber.bombing_start_time = -1;
					bomber.last_bomb_time = -1;
				}
			}else{
				if(Math.random() < 0.002){
					bomber.bombing_start_time = frameTime();
					bomber.last_bomb_time = -1;
				}
			}


			bomber.mesh.position.x = bomber.x;
			bomber.mesh.position.z = bomber.z;


			if(frameNumber() % 3 == 0){
				bomber.frame++;
			}
			if(bomber.frame > maxFrames-1){
				bomber.frame = 0;
			}

			let frameY = startY+Math.floor(bomber.frame/framesX);
			let frameX = startX+bomber.frame % framesX;
		
			bomber.texture.offset.x = (frameX*1024)/1024;
			bomber.texture.offset.y = (frameY*256)/256;
			
			if(bomber.hit_time != -1){
				bomber.mesh.material.color.set(0xFF8888);
				if(frameTime() - bomber.hit_time > 50){
					bomber.mesh.material.color.set(0xFFFFFF);
					bomber.hit_time = -1;
				}
			}
			
			
			bomber.mesh.rotation.z = (angle+180)*(Math.PI/180.0);
			
			//let dire = new get_kxy_angle(angle);
			//if(dire.x < 0){
			if(bomber.direction == 0){
				bomber.mesh.scale.y = -1;
			}else{
				bomber.mesh.scale.y = 1;
			}
			
			if(bomber.falling){
				//bomber.mesh.material.color.set(0xFF00FF);
			}
			
		}
	} // bombers






	for(var i = 0; i < explosions.length; i++){
		let explosion = explosions[i];
		
		if(explosion.alive){
			let framesX;
			let frame_w;
			let frame_h;
			let startX;
			let startY;
			let maxFrames;
			let tex_w;
			let tex_h;
			let frame_step;
			
			if(explosion.type == EXPLOSION_ROUND){
				startX = 0; // top-left corner where in the sheet the animation sequence is.
				startY = 0;
				maxFrames = 45;//20;
				framesX = 8;
				frame_w = 240;
				frame_h = 240;
				tex_w = 2048;
				tex_h = 2048;
				frame_step = 1;
			}else if(explosion.type == EXPLOSION_ROUND_SMALL){
				startX = 0; // top-left corner where in the sheet the animation sequence is.
				startY = 0;
				maxFrames = 45;//20;
				framesX = 8;
				frame_w = 240/4;
				frame_h = 240/4;
				tex_w = 512;
				tex_h = 512;
				frame_step = 1;
			}else if(explosion.type == EXPLOSION_ROUND_LASER){
				startX = 0; // top-left corner where in the sheet the animation sequence is.
				startY = 0;
				maxFrames = 45;//20;
				framesX = 8;
				frame_w = 240;
				frame_h = 240;
				tex_w = 2048;
				tex_h = 2048;
				frame_step = 1;
			}else if(explosion.type == EXPLOSION_FLAT){
				startX = 0; // top-left corner where in the sheet the animation sequence is.
				startY = 3;
				maxFrames = 24;
				framesX = 8;
				frame_w = 128;
				frame_h = 128;
				tex_w = 1024;
				tex_h = 1024;
				frame_step = 3;
			}



			if(frameNumber() % frame_step == 0){
				explosion.frame++;
			}
			if(explosion.frame > maxFrames-1){
				explosion.frame = 0;
				explosion.alive = false;
				explosion.mesh.visible = false;
				//scene.remove(explosions[i].mesh);
			}

			let frameY = startY+Math.floor(explosion.frame/framesX);
			let frameX = startX+explosion.frame % framesX;
		
			explosion.texture.offset.x = (frameX*frame_w)/tex_w;
			explosion.texture.offset.y = (frameY*frame_h)/tex_h;
			
			if(explosion.speed > 0){
				explosion.x += explosion.kx;
				explosion.z += explosion.kz;
				
				explosion.kx *= 0.95;
				
				explosion.mesh.position.x = explosion.x;
				explosion.mesh.position.z = explosion.z;
			}
		}
	} // explosions





	for(var i = 0; i < lights.length; i++){
		let light = lights[i];
		
		if(light.alive){
			let framesX = 8;
			
			let startX = 0;
			let startY = 0;
			let maxFrames = 2; // debug value.
			
			if(light.type == EXPLOSION_ROUND){
				startX = 0;
				startY = 0;
				maxFrames = 20;
			}else if(light.type == EXPLOSION_FLAT){
				startX = 0;
				startY = 3;
				maxFrames = 24;
			}
			
			if(frameNumber() % 3 == 0){
				light.frame++;
			}
			
			//light.mesh.material.opacity = 1-(light.frame/(maxFrames-1));
			light.mesh.intensity = (1-(light.frame/(maxFrames-1)))*light.brightness;
			
			if(light.frame > maxFrames-1){
				light.frame = 0;
				light.alive = false;
				light.mesh.visible = false;
			}
		}
	} // lights



	for(var i = 0; i < visuals.length; i++){
		let visual = visuals[i];
		
		if(visual.alive){
			let framesX = 8;
			
			let startX = 0;
			let startY = 0;
			let maxFrames = 2; // debug value.
			
			if(visual.type == EXPLOSION_ROUND){
				startX = 0;
				startY = 0;
				maxFrames = 20;
			}else if(visual.type == EXPLOSION_ROUND_LASER){
				startX = 0;
				startY = 0;
				maxFrames = 30;
			}else if(visual.type == EXPLOSION_FLAT){
				startX = 0;
				startY = 3;
				maxFrames = 24;
			}
			maxFrames = Math.round(maxFrames*1.3+1);
			
			if(frameNumber() % 3 == 0){
				visual.frame++;
			}
			
			visual.mesh.material.opacity = 1-(visual.frame/(maxFrames-1));
			
			if(visual.frame > maxFrames-1){
				visual.frame = 0;
				visual.alive = false;
				visual.mesh.visible = false;
				//scene.remove(explosions[i].mesh);
			}
		}
	} // visuals


	for(var i = 0; i < splashes.length; i++){
		let splash = splashes[i];
		
		if(splash.alive){
			if(frameNumber() % 3 == 0){
				splash.frame++;
			}
			if(splash.frame >= 14-1){
				splash.frame = 0;
				splash.alive = false;
				splash.mesh.visible = false;
				//scene.remove(splashes[i].mesh);
			}
			let framesX = 4;
			

			let frameY = Math.floor(splash.frame/framesX);
			let frameX = splash.frame % framesX;
			splash.texture.offset.x = (frameX*128)/512;
			splash.texture.offset.y = (frameY*128)/512;
		}
	} // splashes





	for(var i = 0; i < players.length; i++){
		let player = players[i];
		
		if(!gameEnded){
		
			// handle lane changes:
			
			let virtual_y = player.y;
			
			if(player.lane == 1){
				virtual_y = Z_MAP_COLLISION_FRONT;
			}else if(player.lane == -1){
				virtual_y = Z_MAP_BEHIND_FRONT;
			}else{
				// lane "0" (collision layer)
				if(player.type == TYPE_SOLDIER){
					virtual_y = Z_SOLDIER;
				}else{
					virtual_y = Z_PLANE;
				}
			}
			
			virtual_y += player.y_offset;

			
			let dir = 1;

			
			if(player.type == TYPE_HELI){
				player.x += player.speed_x;
				player.z += player.speed_z;
				
				if(player.speed_x < 0){
					dir = -1;
				}
			}else if(player.type == TYPE_SOLDIER){
				let dire = new get_kxy_angle(player.angle);
			
				player.x += dire.x*player.speed;
				player.z += dire.z*player.speed;
				
				//if(dire.x < 0){
				//	dir = -1;
				//}
				
			}else{
				let dire = new get_kxy_angle(player.angle);
			
				player.x += dire.x*player.speed;
				player.z += dire.z*player.speed;
				
				if(dire.x < 0){
					dir = -1;
				}
			}


			let isect = player_intersect_portal(player);
			if(isect !== null){
				//let isect_index = isect[0];
				//let isect_pos = {'x': isect[1][0], 'z': isect[1][1]};
				
				//let portal = portals[isect_index];
				//let por_x = portal.points[]
				player.x = isect.newpos.x;
				player.z = isect.newpos.z;
				player.angle = isect.newangle;
			}
		
			
			// teleport from edges:
			apply_edge_rules(player);
			
			//if(player.z > MAP_H/2+edgePadY/2){
			//	player.z = -MAP_H-edgePadY;
			//}
			//if(player.z < -MAP_H-edgePadY){
			//	player.z = MAP_H/2+edgePadY/2;
			//}
			
			let splash_size = SPLASH_LARGE;
			let splash_offset_z = 0;
			
			if(player.type == TYPE_SOLDIER){
				splash_size = SPLASH_SMALL;
				splash_offset_z = 6;
			}
			
			// test if gets under water:
			if(WATER_ENABLED){
				if(is_underwater(player)){
					if(!player.underwater){
						play_sound("plane_splash", player.x, player.z);
						splash_at(player.x, player.z+splash_offset_z, splash_size);
						player.underwater = true;
						
						// dampen player speed:
						player.kx *= 0.3;
						player.kz *= 0.3;
						player.internal_speed *= 0.3;
						setSpeed(i, player.internal_speed);
						
					}
				}else{
					// test if gets out of water:
					
					if(player.underwater){
						play_sound("plane_splash", player.x, player.z);
						splash_at(player.x, player.z+splash_offset_z, splash_size);
						player.underwater = false;
						//player.kz *= 0.5;
					}
				}
			}

			
			if(player.type == TYPE_PLANE){
				// no flipping in x axis.
			}else{
				if(player.type == TYPE_HELI){
					if(dir < 0){
						//player.mesh.scale.x = -1;
					}else{
						//player.mesh.scale.x = 1;
					}
				}else{
					if(dir < 0){
						player.mesh.scale.y = 1;
					}else{
						player.mesh.scale.y = -1;
					}
				}
			}
			
			
			if(player.type == TYPE_SOLDIER){
				let ground_found = is_ground(player.x, player.z+18);
					
				if(ground_found){
					player.kx = 0;
					player.kz = 0;
				}else{
					player.x += player.kx;
					player.z += player.kz;
					
					if(WATER_ENABLED){
						if(player.underwater){
							if(player.z > MAP_H/2+10){
								player.kz -= BUOYANCY_CONSTANT*5;
								
							}
							// todo: make this work properly in spherical maps.
							player.kz *= WATER_RESISTANCE; // inertia caused by thick water.
							
						}else{
							//player.kz += GRAVITY.value;
							apply_gravity(player);
						}
					}else{
						apply_gravity(player);
					}
				}
			}
			
			let gangle = 180-get_gravity_angle(player.x, player.z);
			let angle_diff = (player.angle+180)-gangle;
			
			//player.angle += angle_diff/100;
			
			if(player.type == TYPE_HELI){
				let max_tilt_speed = 25;
				let max_tilt_angle = 60;
				let tilt_speed = player.speed_x*2;
				if(tilt_speed > max_tilt_speed) tilt_speed = max_tilt_speed;
				if(tilt_speed < -max_tilt_speed) tilt_speed = -max_tilt_speed;
				let tilt_angle = (-tilt_speed/max_tilt_speed)*max_tilt_angle;
				player.mesh.rotation.z = deg2rad(tilt_angle);
			}else{
				player.mesh.rotation.z = deg2rad(player.angle);
				//player.mesh.rotation.z = deg2rad(gangle);
			}
			


			//let light_on_time = 20;
			//let light_off_time = 50;
			if(player.mesh.material.emissiveMap){
			
				if(player.type == TYPE_PLANE){
					if(Math.round(frameNumber()/30) % 3 == 0){
						player.mesh.material.emissive.set(0x000000);
					}else{
						player.mesh.material.emissive.set(0xFFFF55);
					}
				}
			}
			
			
			if(WATER_ENABLED){
				if(player.underwater){
					player.internal_speed *= 0.96;
					if(player.internal_speed <= 0.01){
						player.internal_speed = 0;
						// blow it up? 
					}
					setSpeed(i, player.internal_speed);
				}
			}
			
			// get mesh size:
			//console.log(players[myPlayer].mesh.geometry.parameters.width);
			//console.log(players[myPlayer].mesh.geometry.parameters.height);
		
			
			player.mesh.position.x = player.x;
			player.mesh.position.y = virtual_y;
			player.mesh.position.z = player.z;
			
			player.trajectory_mesh.visible = false;
			player.trajectory_mesh2.visible = false;
			player.trajectory_mesh3.visible = false;
			player.trajectory_mesh4.visible = false;
			player.trajectory_mesh5.visible = false;
		}
	} // players
	
	
	
	
	if(player_trajectories_enabled){
		// the real trajectory where all gravitys affects:
		
		let player = players[myPlayer];
		let trajectory_points = get_trajectory_points();
		
		let edge_points = create_edge_points(trajectory_points, 1);
		let edge_points2 = create_edge_points(trajectory_points, 1.2*2);
		
		// doesnt really affect performance 1 or 5 lines.
		update_trajectory(player.trajectory_mesh4, edge_points2.left);
		update_trajectory(player.trajectory_mesh2, edge_points.left);
		update_trajectory(player.trajectory_mesh, trajectory_points);
		update_trajectory(player.trajectory_mesh3, edge_points.right);
		update_trajectory(player.trajectory_mesh5, edge_points2.right);
	}





	{
		let speedAdd = 1;
		ufoFrameIndex += speedAdd;
		
		let sprite_name = 'ufo_spin';
		let animation_name = 'spin';
		let anim_frames = SPRITES[sprite_name]['anims'][animation_name].length;

		if(ufoFrameIndex >= anim_frames){
			ufoFrameIndex = ufoFrameIndex - Math.floor(ufoFrameIndex/anim_frames)*anim_frames;
		}

		let pos = frame_offset(sprite_name, animation_name, Math.floor(ufoFrameIndex));

		ufoTex.offset.x = pos.x;
		ufoTex.offset.y = pos.y;
		
		ufoEmissiveTex.offset.x = pos.x;
		ufoEmissiveTex.offset.y = pos.y;
	}


	{

		// if night enabled: nightmode night_mode
		if(night_fade_dir){
		
			if(night_fade_dir == 1){
				// disable night
				light_grad_percent += night_fade_speed;
				if(light_grad_percent > 1) light_grad_percent = 1;

			}else if(night_fade_dir == 2){
				// enable night
				light_grad_percent -= night_fade_speed;
				if(light_grad_percent < 0) light_grad_percent = 0;
			}
		
			if(NIGHTSKY_STYLE == 0){
				// black sky
				
				if(night_fade_dir == 1){
					// disable night
					clouds_opacity += night_fade_speed;
					if(clouds_opacity >= 1){
						clouds_opacity = 1;
					}
				}else if(night_fade_dir == 2){
					// enable night (remove cloudsBackMesh)
					clouds_opacity -= night_fade_speed;
					if(clouds_opacity <= 0){
						clouds_opacity = 0;
					}
				}
				
				
				if(clouds_back_enabled){
					cloudsBackMesh.material.opacity = clouds_opacity;
					cloudsBackMesh.visible = (cloudsBackMesh.material.opacity > 0);
				}
				if(clouds_front_enabled){
					if(clouds_opacity < min_cloud_front_opa){
						cloudsFrontMesh.material.opacity = min_cloud_front_opa;
					}else{
						cloudsFrontMesh.material.opacity = clouds_opacity;
					}
					cloudsFrontMesh.visible = (cloudsFrontMesh.material.opacity > 0);
				}
				
				let color = decodeRGBA(colorBetweenRGBA(light_night, light_day, light_grad_percent));
			
				ambient.color.r = color.r/255;
				ambient.color.g = color.g/255;
				ambient.color.b = color.b/255;
			
			}else if(NIGHTSKY_STYLE == 1){
				// yellow sky
				
				let color = decodeRGBA(colorBetweenRGBA(light_sunset, light_day, light_grad_percent));
					
				ambient.color.r = color.r/255;
				ambient.color.g = color.g/255;
				ambient.color.b = color.b/255;
				
				let skycolor = colorBetweenRGBA(light_sunset_sky, light_day, light_grad_percent);
				let skyc = decodeRGBA(skycolor);
				
				if(clouds_front_enabled){
					cloudsFrontMesh.material.color.set(skycolor);
				}
				if(clouds_back_enabled){
					cloudsBackMesh.material.color.r = skyc.r/255*2;
					cloudsBackMesh.material.color.g = skyc.g/255*2;
					cloudsBackMesh.material.color.b = skyc.b/255*2;
				}
			}
			

		
			
			if(behindMeshes.length > 0){
			
				// animate behind.png lightmap color:
				let opa = 1-clouds_opacity;
				let bounce_opacity = true;
				let color_opa = 1-clouds_opacity;
				if(bounce_opacity){
					color_opa = (Math.sin(frameNumber()/30)+1)/2;
				}
				
				let color = colorBetweenRGBA_array([0xFF0000, 0xFFFF00, 0x00FF00, 0x00FFFF, 0x0000FF, 0xFF00FF, 0xFF0000], color_opa);
				
				for(let i = 0; i < behindMeshes.length; i++){
					behindMeshes[i].material.emissiveIntensity = opa;
					behindMeshes[i].material.emissive.set(color);
				}
			
			}
			
			
			if(WATER_ENABLED){
			
				
				let waterFadePercent = 1-clouds_opacity; // 1 = day, 0 = night
				
				let refopaFrom = 0.2;
				let refopaTo = 0.5;
				
				mapMeshFlipped.material.opacity = waterFadePercent*(refopaTo-refopaFrom)+refopaFrom;
			
				let waterColorFrom = 0xDDDDDD;
				let waterColorTo = 0x666666;
		
				waterDownBack.material.color.set(colorBetweenRGBA(waterColorFrom, waterColorTo, waterFadePercent));
				waterDownFront.material.color.set(colorBetweenRGBA(waterColorFrom, waterColorTo, waterFadePercent));
			}
			
		}
		

		if(fade_dir){
			if(fade_dir == 1){ // disable rain
				rain_opacity -= rain_fade_speed;
				if(rain_opacity <= 0){
					rain_opacity = 0;
					fade_dir = 0;
				}
				
				raindrops_opacity -= rain_fade_speed;
				if(raindrops_opacity <= 0){
					raindrops_opacity = 0;
				}
			}else if(fade_dir == 2){ // enable rain
				rain_opacity += rain_fade_speed;
				if(rain_opacity >= rainMaxOpacity){
					rain_opacity = rainMaxOpacity;
					fade_dir = 0;
				}
				
				raindrops_opacity += rain_fade_speed;
				if(raindrops_opacity >= raindropsMaxOpacity){
					raindrops_opacity = raindropsMaxOpacity;
				}
			}
			
			
			if(WATER_ENABLED){
				rainfallMesh.material.opacity = rain_opacity;
				waterdropsMesh.material.opacity = raindrops_opacity;
				
				if(rain_opacity <= 0){
					rainfallMesh.visible = false;
				}
				if(raindrops_opacity <= 0){
					waterdropsMesh.visible = false;
				}
			}
		
			// interpolate cloud colors:
			let cloudFadePercent = rain_opacity/rainMaxOpacity;
			
			if(clouds_front_enabled){
				cloudsFrontMesh.material.color.set(
					colorBetweenRGBA(cloudColorFrom, cloudColorTo, cloudFadePercent)
				);
			}
			if(clouds_back_enabled){
				cloudsBackMesh.material.color.set(
					colorBetweenRGBA(skyboxColorFrom, skyboxColorTo, cloudFadePercent)
				);
			}
		}
	}
	
	
	

	{
	
		let px = players[myPlayer].x;
		let pz = players[myPlayer].z;
		
		let scrollFrameNum = frameNumber()*0.5;

		let mul = 0.8;
		if(clouds_back_enabled){
			mapCloudsBackTex.offset.x = ((-px/(0.5*mul))/MAP_W)+scrollFrameNum/1000*.3;
			mapCloudsBackTex.offset.y = ((pz/(3*mul))/MAP_H);
		}

		let aspect = CANVAS_W/CANVAS_H;
		if(SKYBOX_REPEAT){
			mapNightskyTex.offset.x = ((px/SKYBOX_DISTANCE*aspect)/CANVAS_W);
			mapNightskyTex.offset.y = ((-pz/SKYBOX_DISTANCE)/CANVAS_H);
		}

		if(mapParallaxTex !== null){
			mapParallaxTex.offset.x = ((px/10)/MAP_W);
			mapParallaxTex.offset.y = ((-pz/15)/MAP_H);
		}
		
		if(clouds_front_enabled){
			mapCloudsFrontTex.offset.x = ((px/5)/MAP_W)+scrollFrameNum/1500;
			mapCloudsFrontTex.offset.y = ((-pz/20)/MAP_H);
		}


		
	

		if(plane_flipping){
		
			if(players[myPlayer].type == TYPE_PLANE){

				let speedAdd = 0.5;
				planeFrameIndex += speedAdd;
				
				let sprite_name = 'plane_spin';
				
				//let animations = ['spin_to_down', 'spin_to_up'];
				let animations = ['to_90', 'to_180', 'to_270', 'to_360'];
				let animation_name = animations[plane_current_flip_dir];
				
				let anim_frames = SPRITES[sprite_name]['anims'][animation_name].length;

				if(planeFrameIndex >= anim_frames){
					if(animations.length > 1){
						// if ran out of frames, set ready to continue from next animation:
						planeFrameIndex = 0;
						//plane_current_flip_dir ^= 1;
						plane_current_flip_dir++;
						if(plane_current_flip_dir > animations.length-1){
							plane_current_flip_dir = 0;
						}
						plane_flipping = 0;
						
						animation_name = animations[plane_current_flip_dir];
					}else{
						// cut the frame index to start with offset, if its too large:
						planeFrameIndex = planeFrameIndex - Math.floor(planeFrameIndex/anim_frames)*anim_frames;
					}
				}

				let pos = frame_offset(sprite_name, animation_name, Math.floor(planeFrameIndex));

				planeTex.offset.x = pos.x;
				planeTex.offset.y = pos.y;
				
				planeEmissiveTex.offset.x = pos.x;
				planeEmissiveTex.offset.y = pos.y;
				
			}else if(players[myPlayer].type == TYPE_HELI){
			

				let speedAdd = 0.5;
				heliFrameIndex += speedAdd;
				
				let sprite_name = 'heli_spin';

				let animations = ['to_90', 'to_180', 'from_180', 'from_90'];
				let animation_name = animations[heli_current_flip_dir];
				
				let anim_frames = SPRITES[sprite_name]['anims'][animation_name].length;

				if(heliFrameIndex >= anim_frames){
					if(animations.length > 1){
						// if ran out of frames, set ready to continue from next animation:
						heliFrameIndex = 0;
						//heli_current_flip_dir ^= 1;
						heli_current_flip_dir++;
						if(heli_current_flip_dir > animations.length-1){
							heli_current_flip_dir = 0;
						}
						plane_flipping = 0;
						
						animation_name = animations[heli_current_flip_dir];
					}else{
						// cut the frame index to start with offset, if its too large:
						heliFrameIndex = heliFrameIndex - Math.floor(heliFrameIndex/anim_frames)*anim_frames;
					}
				}

				let pos = frame_offset(sprite_name, animation_name, Math.floor(heliFrameIndex));

				helicopterTex.offset.x = pos.x;
				helicopterTex.offset.y = pos.y;
				
				helicopterEmissiveTex.offset.x = pos.x;
				helicopterEmissiveTex.offset.y = pos.y;

			}
		}
		



	
		if(WATER_ENABLED){
			mapWaterTex.offset.x = scrollFrameNum/1600*waterSpeed*1.5;
			mapWaterTex.offset.y = scrollFrameNum/250*waterSpeed;
			
			mapWaterdropsTex.offset.x = scrollFrameNum/15;
			
			mapRainfallTex.offset.x+=0.002*rainSpeed;
			mapRainfallTex.offset.y+=0.01*rainSpeed;
		}




		{

			let speedAdd = players[santaPlayer].speed/15;
			santaFrameIndex += speedAdd;
			
			let sprite_name = 'santa_sleigh';
			let animation_name = 'moving';
			
			let anim_frames = SPRITES[sprite_name]['anims'][animation_name].length;
			
			if(santaFrameIndex >= anim_frames){
				// cut the frame index if its too large:
				santaFrameIndex = santaFrameIndex - Math.floor(santaFrameIndex/anim_frames)*anim_frames;
			}
			
			let pos = frame_offset(sprite_name, animation_name, Math.floor(santaFrameIndex));
			santaSpriteTest.offset.x = pos.x;
			santaSpriteTest.offset.y = pos.y;
			
			//santaEmissiveTex.offset.x = pos.x;
			//santaEmissiveTex.offset.y = pos.y;
		}
		
		
		
		{
			// TYPE_SOLDIER animation: soldier player animation:
			let thisplayer = players[soldierPlayer];
			
			let speedAdd = thisplayer.speed/15;
			soldierFrameIndex += speedAdd;
			
			let sprite_name = 'soldier';
			let animation_name = 'stand_idle';
			
			if(thisplayer.underwater){
				animation_name = 'basic_swim';
			}else{
				animation_name = 'running';
			}
			
			let anim_frames = SPRITES[sprite_name]['anims'][animation_name].length;
			
			if(soldierFrameIndex >= anim_frames){
				// cut the frame index if its too large:
				soldierFrameIndex = soldierFrameIndex - Math.floor(soldierFrameIndex/anim_frames)*anim_frames;
			}

			let pos = frame_offset(sprite_name, animation_name, Math.floor(soldierFrameIndex));
			soldierSpriteTest.offset.x = pos.x;
			soldierSpriteTest.offset.y = pos.y;
						
		}
		
	}






	if(PLANET_GRAVITY){
			
		// apply gravity:
		for(let i = 0; i < PLANETS.length; i++){
			apply_gravity_to_planet(i);
		}
		
		// apply movement:
		for(let i = 0; i < PLANETS.length; i++){
			let planet = PLANETS[i];
			let collisionData = COLLISION_DATA['MAP_DATA'][i];
			let behindMesh = behindMeshes[i];
			let collisionMesh = collisionMeshes[i];			

			planet.x += planet.kx;
			planet.z += planet.kz;
			
			// update all objects positions linked to planets:
			collisionData.x = planet.x;
			collisionData.z = planet.z;
			GRAVITY.points[i].x = planet.x;
			GRAVITY.points[i].z = planet.z;
			behindMesh.position.x = planet.x;
			behindMesh.position.z = planet.z;
			collisionMesh.position.x = planet.x;
			collisionMesh.position.z = planet.z;
		}
		
		// apply collisions:
		for(let i = 0; i < PLANETS.length; i++){
			let planet = PLANETS[i];
			let planet_test_radius = planet.minradius*2; // 2x planet radius for collision detection.
			
			for(let ii = 0; ii < PLANETS.length; ii++){
				if(ii != i){
					if(point_inside_circle(planet.x, planet.z, PLANETS[ii].x, PLANETS[ii].z, planet_test_radius)){
						planet.kx = -planet.kx;
						planet.kz = -planet.kz;
						//PLANETS[ii].kx = -PLANETS[ii].kx;
						//PLANETS[ii].kz = -PLANETS[ii].kz;
						break;
					}
				}
			}
		}

	}
	
	
	
	

	if(camstyle == 0){
		/////////////////
		// 3D style:
		let cpx = players[myPlayer].x;
		let cpy = players[myPlayer].y;
		let cpz = players[myPlayer].z;
		
		camera.position.x = cpx+MOUSE_OFFSET_X;
		camera.position.y = cpy+500;
		camera.position.z = cpz+MOUSE_OFFSET_Y;
		
		//camera.lookAt( scene.position );
		camera.lookAt(
			cpx + MOUSE_OFFSET_X, 
			cpy, 
			cpz + MOUSE_OFFSET_Y
		);
		cameraCube.rotation.copy( camera.rotation );
	}else{
		/////////////////
		// 2D style:
		let cpx = players[myPlayer].x;
		let cpy = players[myPlayer].y;
		let cpz = players[myPlayer].z;
		
		let gangle = get_gravity_angle(cpx, cpz);
		let a = 360-gangle;
		
		// adjust offset for mouse seeking:
		let gangle2 = gangle;
		if(!rotate_camera_to_gravity){
			gangle2 = 0;
		}
		let gdir = new get_kxy_angle(180-gangle2+MOUSE_ANGLE);
		let tempzoom = camera.zoom;
		if(tempzoom < 0.1) tempzoom = 0.1;
		if(tempzoom > 10) tempzoom = 10;
		let dist = (MOUSE_DIST*3)/tempzoom;
		let off_x = -gdir.x*dist;
		let off_z = -gdir.z*dist;
		
		
		camera.position.x = cpx+off_x;
		camera.position.y = cpy+2000;
		camera.position.z = cpz+off_z;
		
		camera.lookAt(
			cpx + off_x,
			cpy, 
			cpz + off_z
		);

		// must be set after lookAt(), and as fixed value rather than addition/substraction.
		// no idea why needs 90 degree change..
		if(rotate_camera_to_gravity){
			camera.rotation.z = deg2rad(a);
		}
	}
	
	renderer.render(scene, camera);
}






function find_free_light(){
	for(let i = 0; i < lights.length; i++){
		let light = lights[i];
		if(!light.alive){
			return i;
		}
	}
	return -1;
}



function find_free_visual(type){
	for(let i = 0; i < visuals.length; i++){
		let visual = visuals[i];
		if(!visual.alive && visual.type == type){
			return i;
		}
	}
	return -1;
}


function find_free_explosion(type){
	for(let i = 0; i < explosions.length; i++){
		let explosion = explosions[i];
		if(!explosion.alive && explosion.type == type){
			return i;
		}
	}
	return -1;
}




function find_free_splash(){
	for(let i = 0; i < splashes.length; i++){
		let splash = splashes[i];
		if(!splash.alive){
			return i;
		}
	}
	return -1;
}


function total_bombers_alive(){
	let total = 0;
	for(let i = 0; i < bombers.length; i++){
		if(bombers[i].alive){
			total++;
		}
	}
	return total;
}

function find_free_bomber(){
	for(let i = 0; i < bombers.length; i++){
		let bomber = bombers[i];
		if(!bomber.alive){
			return i;
		}
	}
	return -1;
}




function explode_at(x, z, type, size, glowing, glowcolor){

	if(typeof glowing === "undefined"){
		glowing = true;
	}
	
	// spawn glowing...
	if(glowing){
		glow_at(x, z, type, size, glowcolor);
		//light_at(x, z, type, size);
		
		//light_at(x, z, type, 500, 4);
	}
	
	let frame;
	let random_rotation;
	
	if(type == EXPLOSION_ROUND ||
		type == EXPLOSION_ROUND_SMALL ||
		type == EXPLOSION_ROUND_LASER)
	{
		// only round explosions can be rotated around their center point.
		random_rotation = true;
		frame = 5; // skip first frames.
	}else{
		random_rotation = false;
		frame = 0;
	}

	let mscale = 1; // default EXPLOSION_MEDIUM.
	if(size == EXPLOSION_SHOTGUN){
		mscale = 1/8;
	}else if(size == EXPLOSION_TINY){
		mscale = 1/4;
	}else if(size == EXPLOSION_SMALL){
		mscale = 1/2;
	}else if(size == EXPLOSION_MEDIUM){
		mscale = 1;
	}else if(size == EXPLOSION_LARGE){
		mscale = 1*2;
	}else if(size == EXPLOSION_HUGE){
		mscale = 1*3;
	}else if(size == EXPLOSION_HUGE2){
		mscale = 1*5;
	}else if(size == EXPLOSION_HUGE3){
		mscale = 1*6;
	}


	let w = 128;
	let h = 128;
	
	let foundIndex = find_free_explosion(type);
	
	let mesh;
	let texture;

	if(foundIndex == -1){
		if(type == EXPLOSION_ROUND){
			texture = explosionRoundTex.clone();
		}else if(type == EXPLOSION_ROUND_SMALL){
			texture = explosionRoundSmallTex.clone();
		}else if(type == EXPLOSION_ROUND_LASER){
			texture = explosionRoundLaserTex.clone();
		}else{
			texture = explosionSpriteTest.clone();
		}
		texture.needsUpdate = true;

		let geometry = new THREE.PlaneGeometry(w, h);
		let material = new THREE.MeshBasicMaterial({map: texture, color: 0xFFFFFF});
		material.color.set(0xFFFFFF);
		material.transparent = true;
		material.opacity = 1;
		material.side = THREE.DoubleSide;
		//material.blending = THREE.AdditiveBlending;

		mesh = new THREE.Mesh(geometry, material);
	}else{
		mesh = explosions[foundIndex].mesh;
		mesh.visible = true;
	}
	
	let gangle = get_gravity_angle(x,z);
	
	mesh.rotation.x = Math.PI/2;
	if(random_rotation){
		mesh.rotation.z = Math.random()*Math.PI*2;
	}else{
		
		mesh.rotation.z = deg2rad(gangle);
	}

	
	mesh.position.y = randomized_y(Z_MAP_EXPLOSIONS);
	
	if(type == EXPLOSION_FLAT){
		// centered to bottom of the image.
		let gdir = new get_kxy_angle(90-gangle);
		let dist = Math.round(h*(mscale/2)*0.7);
		mesh.position.x = x-gdir.x*dist;
		mesh.position.z = z-gdir.z*dist;
	}else{
		mesh.position.x = x;
		mesh.position.z = z; // default as fully centered to image.
	}
	
	mesh.scale.set(mscale,mscale,mscale);


	
	
	
	if(foundIndex == -1){
		let explosion = {
			'x': x,
			'z': z,
			'kx': 0,
			'kz': 0,
			'speed': 0,
			'frame': frame,
			'alive': true,
			'mesh': mesh,
			'type': type,
			'size': size,
			'scale': mscale,
			'texture': texture,
		};
		explosions.push(explosion);
		scene.add(explosions[explosions.length-1].mesh);
	}else{
		explosions[foundIndex].frame = 0;
		explosions[foundIndex].alive = true;
	}
}



function light_at(x, z, type, size, brightness){

	let foundIndex = find_free_light();
	let mesh;
	if(foundIndex == -1){
		mesh = new THREE.PointLight(0xffee88, brightness, size, 1);
	}else{
		mesh = lights[foundIndex].mesh;
		mesh.visible = true;
	}
	
	mesh.position.x = x;
	mesh.position.y = Z_MAP_VISUALS+150;
	mesh.position.z = z;
	

	if(foundIndex == -1){
		let light = {
			'frame': 0,
			'alive': true,
			'type': type,
			'brightness': brightness,
			'size': size,
			'time': 2000,
			'mesh': mesh,
		};
		lights.push(light);
		scene.add(lights[lights.length-1].mesh);
	}else{
		lights[foundIndex].frame = 0;
		lights[foundIndex].alive = true;
	}
}



// flash_at
function glow_at(x, z, type, size, color){

	let mscale = 1; // default EXPLOSION_MEDIUM.
	
	if(size == EXPLOSION_SHOTGUN){
		mscale = 1/8;
	}else if(size == EXPLOSION_TINY){
		mscale = 1/4;
	}else if(size == EXPLOSION_SMALL){
		mscale = 1/2;
	}else if(size == EXPLOSION_MEDIUM){
		mscale = 1;
	}else if(size == EXPLOSION_LARGE){
		mscale = 1*2;
	}else if(size == EXPLOSION_HUGE){
		mscale = 1*3;
	}else if(size == EXPLOSION_HUGE2){
		mscale = 1*5;
	}else if(size == EXPLOSION_HUGE3){
		mscale = 1*6;
	}
	mscale *= 3; // double the size relative to explosion size.


	if(typeof color === "undefined"){
		color = 0x555555;
	}

	let w = 128;
	let h = 128;

	let foundIndex = find_free_visual(type);

	let mesh;
	let texture;

	if(foundIndex == -1){
		texture = glowspriteTex.clone();
		texture.needsUpdate = true;

		let geometry = new THREE.PlaneGeometry(w, h);
		let material = new THREE.MeshBasicMaterial({map: texture});
		material.color.set(color);
		material.transparent = true;
		//material.opacity = 1; // fades out after it is created.
		material.side = THREE.DoubleSide;
		material.blending = THREE.AdditiveBlending;

		mesh = new THREE.Mesh(geometry, material);
	}else{
		mesh = visuals[foundIndex].mesh;
		mesh.visible = true;
		mesh.material.color.set(color);
	}
	
	mesh.rotation.x = Math.PI/2;
	mesh.rotation.z = Math.random()*Math.PI*2; // random rotation.

	mesh.position.x = x;
	mesh.position.y = randomized_y(Z_MAP_VISUALS);
	mesh.position.z = z; // default as fully centered to image.
	
	mesh.scale.set(mscale,mscale,mscale);

	if(foundIndex == -1){
		let visual = {
			'x': x,
			'z': z,
			'kx': 0,
			'kz': 0,
			'speed': 0,
			'frame': 0,
			'alive': true,
			'mesh': mesh,
			'type': type,
			'size': size,
			'scale': mscale,
			'texture': texture,
		};
		visuals.push(visual);
		scene.add(visuals[visuals.length-1].mesh);
	}else{
		visuals[foundIndex].frame = 0;
		visuals[foundIndex].alive = true;
	}
}






function splash_at(x, z, size){
	let mscale = 1;
	
	if(size == SPLASH_TINY){
		mscale = 1/8;
	}else if(size == SPLASH_SMALL){
		mscale = 1/4;
	}else if(size == SPLASH_MEDIUM){
		mscale = 1/2;
	}else if(size == SPLASH_LARGE){
		mscale = 1;
	}else if(size == SPLASH_HUGE){
		mscale = 1*2;
	}else if(size == SPLASH_HUGE2){
		mscale = 1*5;
	}

	let w = 128;
	let h = 128;
	
	let foundIndex = find_free_splash();
	
	let mesh;
	let texture;

	if(foundIndex == -1){
		texture = splashSpriteTest.clone();
		texture.needsUpdate = true;

		let geometry = new THREE.PlaneGeometry(w, h);
		let material = new THREE.MeshPhongMaterial({map: texture, color: 0xFFFFFF});  			
		material.color.set(0xFFFFFF);
		material.transparent = true;
		material.opacity = 1;
		material.side = THREE.DoubleSide;
		//material.blending = THREE.AdditiveBlending;

		mesh = new THREE.Mesh(geometry, material);
	}else{
		mesh = splashes[foundIndex].mesh;
		mesh.visible = true;
	}
	

	mesh.rotation.x = Math.PI/2;

	mesh.position.x = x;
	mesh.position.y = Z_MAP_SPLASHES;
	mesh.position.z = z-8;
	
	mesh.scale.set(mscale,mscale,mscale);

	if(foundIndex == -1){
		let splash = {
			'x': x,
			'z': z,
			'frame': 0,
			'alive': true,
			'mesh': mesh,
			'scale': mscale,
			'texture': texture,
		};
		splashes.push(splash);
		scene.add(splashes[splashes.length-1].mesh);
	}else{
		splashes[foundIndex].frame = 0;
		splashes[foundIndex].alive = true;
	}
}








// flying_angle 0 = left, 180 = right.
function spawn_bomber(owner, x, z, direction, speed, type, size){

	let mscale = 1;
	
	let distance = z; // used in point gravity mode.
	
	if(GRAVITY.style == GRAVITY_PLANAR){
		z = -z;
	}
	
	if(typeof direction === "undefined"){
		direction = 1;
	}
	if(typeof speed === "undefined"){
		speed = 10;
	}
	if(typeof type === "undefined"){
		type = PLANE_BOMBER;
	}
	if(typeof size !== "undefined"){
		mscale = size;
	}
	

	let w = 1024;
	let h = 256;
	
	let foundIndex = find_free_bomber(x, z);
	
	let mesh;
	let texture;

	if(foundIndex == -1){
		texture = bomberSpriteTest.clone();
		texture.needsUpdate = true;

		let geometry = new THREE.PlaneGeometry(w, h);
		let material = new THREE.MeshPhongMaterial({map: texture, color: 0xFFFFFF});  			
		material.color.set(0xFFFFFF);
		material.transparent = true;
		material.opacity = 1;
		material.side = THREE.DoubleSide;
		material.emissive.set(0xFFFFFF);
		material.emissiveMap = bomberEmissiveTex;
		material.emissiveIntensity = 1.2;

		mesh = new THREE.Mesh(geometry, material);
	}else{
		mesh = bombers[foundIndex].mesh;
		mesh.visible = true;
		mesh.material.color.set(0xFFFFFF);
	}
	

	mesh.rotation.x = Math.PI/2;

	mesh.position.x = x;
	mesh.position.y = randomized_y(Z_BOMBER);
	mesh.position.z = z;
	
	mesh.scale.set(mscale,mscale,mscale);
	
	let kx;
	let kz;
	
	if(GRAVITY.style == GRAVITY_CIRCULAR){
		kx = speed; // circular movement, so kx/ky is not even needed. but making it this way it could be used.
		kz = 0;
	}else{
		// default to linear gravity.
		let direction_angle = (direction == 1) ? 180 : 0;
		let dire = new get_kxy_angle(direction_angle);
		kx = dire.x*speed;
		kz = dire.z*speed;
	}
	let health = 1000;
	let health_smokestart = 500;
	let health_falling = 200;

	if(foundIndex == -1){
		let bomber = {
			'x': x,
			'z': z,
			'kx': kx,
			'kz': kz,
			'speed': speed,
			'hit_time': -1,
			'explode_time': -1,
			'direction': direction, // 0 = left/counterclockwise, 1 = right/clockwise.
			'distance': distance,

			'health': health,
			'health_smokestart': health_smokestart, // hp when bomber starts to fall down.
			'health_falling': health_falling, // hp when bomber starts to fall down.
			'falling': false,
			
			'frame': 0,
			'alive': true,
			
			'mesh': mesh,
			'scale': mscale,
			'texture': texture,
			'type': type,
			'bombing_start_time': -1,
			'last_bomb_time': -1,
			'owner': owner,
		};
		bombers.push(bomber);
		scene.add(bombers[bombers.length-1].mesh);
	}else{
		let bomber = bombers[foundIndex];
		bomber.frame = 0;
		bomber.alive = true;
		bomber.x = x;
		bomber.z = z;
		bomber.kx = kx;
		bomber.kz = kz;
		bomber.speed = speed;
		bomber.hit_time = -1;
		bomber.explode_time = -1;
		bomber.falling = false;
		bomber.health = health;
		bomber.health_smokestart = health_smokestart;
		bomber.health_falling = health_falling;
		bomber.scale = mscale;
		bomber.type = type;
		bomber.bombing_start_time = -1;
		bomber.last_bomb_time = -1;
		bomber.owner = owner;
	}
	
}



function spawn_bombers(){
	// 1 = to right, 0 = to left.
	spawn_bomber(OWNER_AI, -MAP_W/2, 3500+Math.random()*800, 1, Math.random()*10+5);
	spawn_bomber(OWNER_AI,  MAP_W/2, 3500+Math.random()*800, 0, Math.random()*10+5);
}




function find_free_turret(type){
	for(let i = 0; i < turrets.length; i++){
		if(!turrets[i].alive && turrets[i].type == type){
			return i;
		}
	}
	return -1;
}

function turret_type_to_idleframe(type){
	if(type == TURRET_ANTIAIR){
		return "aa_idle";
	}else if(type == TURRET_BOMBER){
		return "bomber_idle";
	}
	return "aa_idle";
}
function turret_type_to_deadframe(type){
	if(type == TURRET_ANTIAIR){
		return "aa_dead";
	}else if(type == TURRET_BOMBER){
		return "bomber_dead";
	}
	return "aa_dead";
}




function spawn_turret(unit){
	let mscale = 1;
	
	
	let owner = unit.owner;
	let x = unit.x;
	let z = unit.y;
	
	if(unit.hasOwnProperty("d")){
		if(unit.hasOwnProperty("a")){
			let dire = new get_kxy_angle(270-unit.a);
			x = dire.x*unit.d;
			z = dire.z*unit.d;
		}
	}

	let range;
	let type;
	
	if(unit.type == "antiair"){
		type = TURRET_ANTIAIR;
	}else if(unit.type == "bomber"){
		type = TURRET_BOMBER;
	}else{
		console.error("invalid turret type: '"+unit.type+"', defaulting to antiair.");
		type = TURRET_ANTIAIR;
	}
	
	if(type == TURRET_ANTIAIR){
		range = TURRET_ANTIAIR_RANGE;
	}else if(type == TURRET_BOMBER){
		range = TURRET_BOMBER_RANGE;
	}else{
		console.error("should not happened.");
		alert("should not happened.");
	}



	let sprite = SPRITES['turret'];


	let rotation = get_gravity_angle_debug(x,z);


	let foundIndex = find_free_turret(type);
	
	let mesh;
	let barrel_mesh;
	let texture;
	let turret = {};
	let trajectory_mesh;
	let trajectory_real_mesh;
	
	if(foundIndex == -1){
		texture = turretSpriteTest.clone();
		texture.needsUpdate = true;

		let geometry = new THREE.PlaneGeometry(sprite.w, sprite.h);
		let material = new THREE.MeshPhongMaterial({map: texture, color: 0xFFFFFF});  			
		material.color.set(0xFFFFFF);
		material.transparent = true;
		material.opacity = 1;
		material.side = THREE.DoubleSide;

		mesh = new THREE.Mesh(geometry, material);
		
		// create barrel:
		{
			// create size of 1 and then scale it to correct size, so translate works easier.
			let geometry = new THREE.PlaneGeometry(1, 1);
			let material = new THREE.MeshPhongMaterial();
			material.color.set(0x000000);
			material.transparent = false;
			material.opacity = 1;
			material.side = THREE.DoubleSide;
			
			// move pipe from middle to left a bit:
			geometry.translate(0.2, 0, 0.5);
			barrel_mesh = new THREE.Mesh(geometry, material);
			let barrel_length = 50;
			barrel_mesh.scale.set(barrel_length, 3, 1);
		}
		
		trajectory_mesh = create_trajectory_mesh(0xFFFF00);
		trajectory_real_mesh = create_trajectory_mesh(0xFF00FF);
		
	}else{
		turret = turrets[foundIndex];
		mesh = turret.mesh;
		mesh.visible = true;
		mesh.material.color.set(0xFFFFFF); // needed if the unit has "hit flash" effect (red).
		texture = turret.texture;
		barrel_mesh = turret.barrel_mesh;
		barrel_mesh.visible = true;
		trajectory_mesh = turret.trajectory_mesh;
		trajectory_real_mesh = turret.trajectory_real_mesh;
	}
	
	trajectory_mesh.visible = false; // hide before using it.
	trajectory_real_mesh.visible = false; // hide before using it.
	
	// set correct frame:
	let framename = turret_type_to_idleframe(type);
	let pos = frame_offset('turret', framename, 0);
	texture.offset.x = pos.x;
	texture.offset.y = pos.y;
	
	mesh.rotation.x = Math.PI/2;
	mesh.rotation.z = deg2rad(rotation);

	mesh.position.x = x;
	mesh.position.y = Z_TURRET;
	mesh.position.z = z;
	
	mesh.scale.set(mscale,mscale,mscale);
	
	
	barrel_mesh.rotation.x = Math.PI/2;
	barrel_mesh.rotation.z = deg2rad(rotation);
	
	
	
	if(type == TURRET_ANTIAIR){
		barrel_mesh.position.x = x+1.5;
		barrel_mesh.position.z = z-15;
	}else if(type == TURRET_BOMBER){
		barrel_mesh.position.x = x;
		barrel_mesh.position.z = z-19.5;
	}
	barrel_mesh.position.y = Z_TURRET_BARREL;

	// initialize data:
	turret['frame'] = 0;
	turret['alive'] = true;
	turret['x'] = x;
	turret['z'] = z;
	turret['rotation'] = rotation;
	turret['ammo'] = 1000;
	turret['shoot_start'] = -1;
	turret['health'] = 400;
	turret['health_smokestart'] = 100;
	turret['scale'] = mscale;
	turret['type'] = type;
	turret['owner'] = owner;
	turret['smokestart'] = false;
	turret['explode_time'] = -1;
	turret['range'] = range;
	turret['real_shot_angle'] = null;
	
	// if was new turret, update mesh/texture too, and add to array/scene:
	if(foundIndex == -1){
		turret['mesh'] = mesh;
		turret['texture'] = texture;
		turret['barrel_mesh'] = barrel_mesh;
		turret['trajectory_mesh'] = trajectory_mesh;
		turret['trajectory_real_mesh'] = trajectory_real_mesh;
		
		turrets.push(turret);
		scene.add(turrets[turrets.length-1].mesh);
		scene.add(turrets[turrets.length-1].barrel_mesh);
		scene.add(turrets[turrets.length-1].trajectory_mesh);
		scene.add(turrets[turrets.length-1].trajectory_real_mesh);
	}
	
	//console.warn(turret);
	
}











function drop_bomb(owner, x, z, dire, speed, owned_by_ai, custom_fusetime, type){

	if(typeof owned_by_ai === "undefined"){
		owned_by_ai = false;
	}
	
	let fusetime;
	
	if(typeof custom_fusetime !== "undefined"){
		fusetime = custom_fusetime;
	}else{
		fusetime = BOMB_FUSETIME;
	}
		
	if(typeof type === "undefined"){
		type = WEAPON_BOMB;
	}
	
	//play_sound("bomb_drop", x, z);
	
	
	let w = 25;
	let h = 17;
	
	let geometry = new THREE.PlaneGeometry(w, h);
	let material = new THREE.MeshPhongMaterial({map: bombSpriteTest, color: 0xFFFFFF});  			
	material.color.set(0xFFFFFF);
	material.transparent = true;
	material.opacity = 1;
	material.side = THREE.DoubleSide;

	let mesh = new THREE.Mesh(geometry, material);
	let mscale = 1;

	let angle = get_angle(0, 0, dire.x, dire.z);
	mesh.rotation.x = Math.PI/2;
	mesh.rotation.z = (180-angle)*(Math.PI/180.0);
	
	mesh.scale.set(mscale,mscale,mscale);
	
	mesh.position.x = x;
	mesh.position.y = randomized_y(Z_MAP_BOMBS);
	mesh.position.z = z;
	
	let bomb = {
		'x': x,
		'z': z,
		'kx': dire.x*speed,
		'kz': dire.z*speed,
		'alive': true,
		'mesh': mesh,
		'whistling': false,
		'owned_by_ai': owned_by_ai,
		'owner': owner,
		'time': getTimeMillis(),
		'frame_created': frameNumber(),
		'fusetime': fusetime, // time in ms when projectile dies.
		'type': type,
	};
	bombs.push(bomb);
	scene.add(bombs[bombs.length-1].mesh);
	
	return angle;
}



// random value -range to range
function randiff(range){
	return (((Math.random()-0.5)*2)*range);
}



function deepClone(obj){
	return JSON.parse(JSON.stringify(obj));
}


// ported to js from pete's python code for solving trajectory equation.
// x0,y0 = from
// x1,y1 = to
function get_angles_for_target(x0, y0, x1, y1, v){
	let delta_x = x1 - x0;
	let delta_y = y1 - y0;
	if(delta_x == 0){
		if(delta_y > 0){
			return [rad2deg(Math.PI/2), null]; // shoot straight down
		}else{
			return [rad2deg(-Math.PI/2), null]; // shoot straight up
		}
	}
	let k = delta_y/delta_x;

	let c = (k - 2*GRAVITY.value*(delta_x/(2*v*v)))/Math.sqrt(1+k*k);
	let alpha = Math.atan(-k);
	let beta = Math.asin(c);

	let theta_1 = (beta - alpha) / 2;
	let theta_2 = (-beta + Math.PI - alpha) / 2;
	
	let solutions = [theta_1-Math.PI, theta_2-Math.PI, theta_1, theta_2];
		
	let min_t = 666666.0;
	let min_theta = null;
	let max_theta = null;
	
	let ts = [];

	for(let i = 0; i < 4; i++){
		let theta = solutions[i];
		let t = delta_x/(Math.cos(theta)*v);		
		if(t > 0){
			ts.push([t, theta]);
		}
	}
	
	if(ts.length == 1){
		min_theta = ts[0][1];
	}else if(ts.length == 2){
		// find min/max of first 2 values
		if(ts[0][0] > ts[1][0]){
			// if first value of t is larger, set max_theta as t's theta value.
			min_theta = ts[1][1];
			max_theta = ts[0][1];
		}else{
			min_theta = ts[0][1];
			max_theta = ts[1][1];
		}
	}

	let min_a = (min_theta !== null) ? rad2deg(min_theta) : null; // straight shot
	let max_a = (max_theta !== null) ? rad2deg(max_theta) : null; // ballistic shot (longer)
	
	return [min_a, max_a];
}




function create_trajectory_mesh(color){
	// create initial points that will be updated when trajectory should be updated:
	let points = [];
	for(let i = 0; i < PROJECTILE_MAX_FRAMES; i++){
		points.push(new THREE.Vector3(0,Z_RAIN,0));
	}
	
	let geometry = new THREE.BufferGeometry().setFromPoints(points);
	// LineBasicMaterial or LineDashedMaterial
	let material = new THREE.LineBasicMaterial({color: color});
	// dashed doesnt seem to work at all:
	//let material = new THREE.LineDashedMaterial({color: color, linewidth: 1, scale: 1, dashSize: 3, gapSize: 1});
	
	//There are three hints for how frequently the user will be changing the buffer's data.
	//STATIC: The user will set the data once.
	//DYNAMIC: The user will set the data occasionally.
	//STREAM: The user will be changing the data after every use. Or almost every use.
	geometry.attributes.position.setUsage(THREE.StreamDrawUsage);
	//material.opacity = 0.8; // dont use -> low opacity looks bad but is useful, and high opacity looks good but is useless.
	//material.transparent = true;
	
	//material.linewidth = 4; // only size 1 is supported on most browsers.
	// see https://threejs.org/examples/webgl_lines_fat for thicker lines.
	let line = new THREE.Line(geometry, material);
	//line.name = random_str(20);
	return line;
}


function change_player_trajectory_colors(weaponcolors){
	let myplayer = players[myPlayer];
	let trajs = [
		[myplayer.trajectory_mesh4, weaponcolors.edge2],
		[myplayer.trajectory_mesh2, weaponcolors.edge],
		[myplayer.trajectory_mesh, weaponcolors.middle],
		[myplayer.trajectory_mesh3, weaponcolors.edge],
		[myplayer.trajectory_mesh5, weaponcolors.edge2],
	];
	for(let i = 0; i < trajs.length; i++){
		trajs[i][0].material.color = new THREE.Color(trajs[i][1]);
		trajs[i][0].material.needsUpdate = true;
	}
}


function update_trajectory(trajectory_mesh, new_points){
	let vertices = trajectory_mesh.geometry.attributes.position.array;
	
	let last_point = new_points[new_points.length-1];
	
	trajectory_mesh.geometry.attributes.position.count = vertices.length/3;
	
	for(let v = 0, p = 0; v <= vertices.length; v+=3, p++){
		if(p > new_points.length-1){
			// put remaining points in the last point position, 
			//   so we can draw shorter lines than max line length.
			vertices[v+0] = last_point.x;
			vertices[v+1] = last_point.y;
			vertices[v+2] = last_point.z;
			trajectory_mesh.geometry.attributes.position.count = p;
			break;
		}else{
			if(p < new_points.length){
				vertices[v+0] = new_points[p].x;
				vertices[v+1] = new_points[p].y;
				vertices[v+2] = new_points[p].z;
			}else{
				console.error("points overflowed.");
			}
		}
	}
	
	//console.log(trajectory_mesh.geometry.attributes);
	
	trajectory_mesh.geometry.attributes.position.needsUpdate = true;
	trajectory_mesh.visible = true; // show mesh.
}






function shoot_turret(turret, owner, shot_allowed, dist){
	//let angle = -(Math.random()*(160-20)+20); // -20 to -160
	
	//let pred_amount = 200;
	//let hpred = Math.round(pred_amount/2);
	let curplayer = players[myPlayer];
	
	let target_x = curplayer.x;
	let target_z = curplayer.z;
	
	//let dist = get_dist_2d(turret.x, turret.z, target_x, target_z);
	
	//let shot_minimum_acceptable_distance = 50;
	


	let shot_start_x = turret.x;
	//let shot_start_z = turret.z-17;
	let shot_start_z = turret.z-17;
	
	let bullet_speed = 20; // speed 1 = 1*0.1+20 (lol)
	let max_frames_per_dist = 30*(turret.range*2)/bullet_speed; // double in case needed

	// add prediction of player movement in the future:
	let max_frames = Math.floor((dist/bullet_speed));
	let dire = new get_kxy_angle(curplayer.angle);
	let pspeed = curplayer.speed * max_frames;
	let add_x = dire.x*pspeed;
	let add_z = dire.z*pspeed;
	//target_x = curplayer.x + add_x;
	//target_z = curplayer.z + add_z;
	
	target_x = curplayer.x;
	target_z = curplayer.z;
	
	/*
	
	let targeting_angle = get_angle(shot_start_x, shot_start_z, target_x, target_z);

	let best_angle = 999;
	let frames_used = 0;
	let found_target = false;
	
	
	// simulate bullet movement beforehand:
	{
		let min_dist = 999999;
		let min_frames_used = 999999;
		let total_grounds_found = 0;
		
		// alter the angle to find best angle:
		//for(let a = -hpred; a <= hpred; a++){
		for(let a = -hpred; a <= hpred; a++){
			let astep = a*2.0;
			let cur_angle = targeting_angle + astep;
			let dire_bullet = new get_kxy_angle(cur_angle);
			
			let shot = {
				'x': shot_start_x,
				'z': shot_start_z,
				'kx': dire_bullet.x*bullet_speed,
				'kz': dire_bullet.z*bullet_speed,
			};
						
			// find shortest distance to target at first shot:
			for(let i = 0; i < max_frames_per_dist; i++){
				shot.x += shot.kx;
				shot.z += shot.kz;
				shot.kx *= AIR_RESISTANCE;
				shot.kz += GRAVITY.value;
				
				let ground_found = is_ground(shot.x, shot.z);
				if(ground_found){
					total_grounds_found++;
					break;
				}
				
				let shot_dist = get_dist_2d(shot.x, shot.z, target_x, target_z);
				if(shot_dist < shot_minimum_acceptable_distance){
					frames_used = i+1;
					if(shot_dist < min_dist){
						min_dist = shot_dist;
						min_frames_used = frames_used;
						best_angle = cur_angle;
						found_target = true;
					}
				}
			}
		}
		
		//console.log("total_grounds_found = "+total_grounds_found);
	}
	*/
	

	target_x += add_x;
	target_z += add_z;
	
	let best_angles = get_angles_for_target(shot_start_x, shot_start_z, target_x, target_z, bullet_speed);
	let found_angle = null;

	
	for(let p = 0; p < best_angles.length; p++){
		let cur_angle = best_angles[p];
		if(cur_angle !== null){

			let dire_bullet = new get_kxy_angle(cur_angle);
			
			let shot = {
				'x': shot_start_x,
				'z': shot_start_z,
				'kx': dire_bullet.x*bullet_speed,
				'kz': dire_bullet.z*bullet_speed,
			};
						
			// simulate bullet movement:
			let hit_ground = false;
			//let maxframes = PROJECTILE_MAX_FRAMES;//60*10; // 10 secs max calculation.
			let prev_shot_dist = null;
			let prev_shot_dist_diff = 0;
			for(let i = 0; i < PROJECTILE_MAX_FRAMES; i++){
				
				shot.x += shot.kx;
				shot.z += shot.kz;
				
				
				//shot.kx *= AIR_RESISTANCE;
				shot.kz += GRAVITY.value;
				
				let shot_dist = get_dist_2d(shot.x, shot.z, target_x, target_z);
				
				if(prev_shot_dist !== null){
					let shot_dist_diff = shot_dist-prev_shot_dist;
					if(shot_dist_diff-prev_shot_dist_diff > 0){
						// todo: clean up code.
						// TODO: fix this so bomber turret could shoot further...
						break; // bullet started to get further from target.
					}
					
					prev_shot_dist_diff = shot_dist_diff;
				}

				if(is_ground(shot.x, shot.z)){
					//console.log("cur_angle = "+cur_angle.toFixed(2)+" hits ground");
					hit_ground = true;
					break;
				}
				
				prev_shot_dist = shot_dist;
			}
			if(!hit_ground){
				// found a way which didnt hit ground; use it:
				found_angle = cur_angle;
				break;
			}
		}
	}
	

	//console.log("found_angle = "+found_angle);
	
	if(found_angle !== null){
	
		let trajectory_points = [];
		let trajectory_real_points = [];
		
		
		if(turret_trajectories_enabled){
			//console.log(trajectory_points);
			

			
			// trajectory that turret uses to aim at:
			{
				let dire_bullet = new get_kxy_angle(found_angle);
			
				let shot = {
					'x': shot_start_x,
					'z': shot_start_z,
					'kx': dire_bullet.x*bullet_speed,
					'kz': dire_bullet.z*bullet_speed,
				};
				
				let maxframes = 0;
				if(turret.type == TURRET_ANTIAIR){
					maxframes = TURRET_ANTIAIR_FUSETIME;
				}else if(turret.type == TURRET_BOMBER){
					maxframes = TURRET_BOMBER_FUSETIME;
				}
				
				for(let i = 0; i < maxframes; i++){
					trajectory_points.push({
						'x': shot.x, 
						'y': Z_RAIN, 
						'z': shot.z,
					});
					
					shot.x += shot.kx;
					shot.z += shot.kz;
					
					
					//shot.kx *= AIR_RESISTANCE;
					shot.kz += GRAVITY.value;
					
					
				}
				
				update_trajectory(turret.trajectory_mesh, trajectory_points);
			}
			
			
			
		}
		
		//console.log("max_frames = "+max_frames+", frames_used = "+frames_used);
		
		//let random_spread = 0;//(Math.random()-0.5)*1.5; //1.5 degree spread.
		// NOTE: random spread is set just before object is created! unknown at this point.
		let shot_angle = found_angle;// + random_spread;
	
		// always rotate turret to the correct rotation:
		turret.barrel_mesh.rotation.z = (180-shot_angle)*(Math.PI/180.0);
		

		// check shooting very last: we want turret to target the enemy even if it cant shoot atm due to reloading.
		if(shot_allowed){
			let real_shot_angle = shoot_turret_from(owner, shot_start_x, shot_start_z, shot_angle, turret.type);
			turret.shoot_start = getTimeMillis();
			turret.real_shot_angle = real_shot_angle;
		}
		
		if(turret.real_shot_angle !== null){

			if(turret_trajectories_enabled){
				// the real trajectory where all gravitys affects:
				
				let dire_bullet = new get_kxy_angle(turret.real_shot_angle);
			
				let shot = {
					'x': shot_start_x,
					'z': shot_start_z,
					'kx': dire_bullet.x*bullet_speed,
					'kz': dire_bullet.z*bullet_speed,
				};
				
				let maxframes = 0;
				if(turret.type == TURRET_ANTIAIR){
					maxframes = TURRET_ANTIAIR_FUSETIME;
				}else if(turret.type == TURRET_BOMBER){
					maxframes = TURRET_BOMBER_FUSETIME;
				}
				
				for(let i = 0; i < maxframes; i++){
					trajectory_real_points.push({
						'x': shot.x, 
						'y': Z_RAIN, 
						'z': shot.z,
					});
					
					shot.x += shot.kx;
					shot.z += shot.kz;
					
					apply_gravity(shot);
					
				
				}
				
				update_trajectory(turret.trajectory_real_mesh, trajectory_real_points);
			
			}

		}
		
		//console.log("shoot turret from "+owner);
	}

}




function shoot_turret_from(owner, x, z, angle, type){
	let shot_angle = null;
	
	if(type == TURRET_ANTIAIR){
		play_sound("antiair_gun", x, z);
		shot_angle = shoot_planegun_nosound(owner, x, z, angle, 0, WEAPON_PLANEGUN, TURRET_ANTIAIR_FUSETIME);
		
	}else if(type == TURRET_BOMBER){
		play_sound("explosion_bullet", x, z);

		let dire = new get_kxy_angle(angle);
		let speed = 20;
		
		shot_angle = drop_bomb(owner, x, z, dire, speed, true, TURRET_BOMBER_FUSETIME);
	}
	
	return shot_angle;
}






function shoot_from_myplayer(){
	let curplayer = players[myPlayer];
	if(curplayer.weapons1[curplayer.current1] == WEAPON_PLANEGUN){
		shoot_planegun(
			curplayer.owner,
			curplayer.x,
			curplayer.z,
			curplayer.shoot_angle,
			curplayer.speed*curplayer.shot_speed_multi
		);
	}else if(curplayer.weapons1[curplayer.current1] == WEAPON_SHOTGUN){
		play_sound("plane_machinegun", curplayer.x, curplayer.z);
	
		for(let i = 0; i < 10; i++){
			shoot_planegun_nosound(
				curplayer.owner,
				curplayer.x,
				curplayer.z,
				curplayer.shoot_angle+(Math.random()-0.5)*6,
				(curplayer.speed*curplayer.shot_speed_multi)+(Math.random()-0.5)*12,
				WEAPON_SHOTGUN
			);
		}
	}else if(curplayer.weapons1[curplayer.current1] == WEAPON_BOMB){
		let x = curplayer.x;
		let z = curplayer.z;
		let object_speed = curplayer.speed;
		let bullet_angle = curplayer.shoot_angle;
		//bullet_angle += (Math.random()-0.5)*shooting_imprecision;
		let dire = new get_kxy_angle(bullet_angle);
		let speed = object_speed+20*curplayer.shot_speed_multi;
		
		drop_bomb(players[myPlayer].owner, x, z, dire, speed);
	}else if(curplayer.weapons1[curplayer.current1] == WEAPON_BOMB_LASER){
		let speed = 10;//*curplayer.shot_speed_multi;
		
		let trajectory_points = get_trajectory_points();
		
		let point = trajectory_points[trajectory_points.length-2]; // take second last point.
		let next_point = trajectory_points[trajectory_points.length-1]; // take second last point.
		let x = point.x;
		let z = point.z;
		let dire = new get_kxy(x, z, next_point.x, next_point.z);

		drop_bomb(players[myPlayer].owner, x, z, dire, speed, false, BOMB_LASER_FUSETIME, WEAPON_BOMB_LASER);
	}
}




function shoot_planegun(owner, x, z, bullet_angle, object_speed){
	play_sound("plane_machinegun", x, z);
	shoot_planegun_nosound(owner, x, z, bullet_angle, object_speed, WEAPON_PLANEGUN);
}



function shoot_planegun_nosound(owner, x, z, bullet_angle, object_speed, type, custom_fusetime){
	let w = 64;
	let h = 6;
	
	let fusetime = SHOT_FUSETIME;
	
	if(typeof custom_fusetime !== "undefined"){
		fusetime = custom_fusetime;
	}
	
	let geometry = new THREE.PlaneGeometry(w, h);
	geometry.translate(-w/2, 0, 0);
	let material = new THREE.MeshPhongMaterial({map: shotSpriteTest, color: 0xFFFFFF});  			
	material.color.set(0xFFFFFF);
	material.transparent = true;
	material.opacity = 1;
	material.side = THREE.DoubleSide;
	
	material.emissive.set(0xFFFF00);
	material.emissiveMap = shotlightsTex;
	material.emissiveIntensity = 0.7;
	//material.blending = THREE.AdditiveBlending;

	let mesh = new THREE.Mesh(geometry, material);
	let mscale = 1;
	if(DEV_MODE == 1){
		mscale = 5; // for testing.
	}else if(DEV_MODE == 2){
		mscale = 20; // for testing.
	}else if(DEV_MODE == 3){
		mscale = 100; // for testing.
	}
	mesh.position.x = x;
	mesh.position.y = randomized_y(Z_MAP_SHOTS);
	mesh.position.z = z;

	mesh.rotation.x = Math.PI/2;
	mesh.rotation.z = (180-bullet_angle)*(Math.PI/180.0);
	
	mesh.scale.set(mscale,mscale,mscale);
	
	bullet_angle += (Math.random()-0.5)*shooting_imprecision;
	let dire = new get_kxy_angle(bullet_angle);
	let speed = object_speed+20;

	let shot = {
		'x': x,
		'z': z,
		'kx': dire.x*speed,
		'kz': dire.z*speed,
		'alive': true,
		'mesh': mesh,
		'owner': owner,
		'type': type,
		'time': getTimeMillis(),
		'frame_created': frameNumber(),
		'fusetime': fusetime, // time in ms when projectile dies.
	};
	shots.push(shot);
	scene.add(shots[shots.length-1].mesh);
	
	return bullet_angle;
}











function change_player(playerIndex){
	if(playerIndex >= 0 && playerIndex < players.length){
		myPlayer = playerIndex;
	}else{
		console.log("player "+playerIndex+" does not exist");
	}
}






// keys
document.addEventListener("keyup", onDocumentKeyUp, false);
function onDocumentKeyUp(event) {
	KEYS[event.which] = false;
	
	var keyCode = event.which;
	//console.log("keyup = "+keyCode);
	
	if(keyCode == 32){ // 'space'
		//rotatePlayer = 0;
		bombingStarted = false;
		bombStartTime = 0;
		prevBombTime = 0;
		
	}else if(keyCode == 68){ // 'S'
		//rotatePlayer = 0;
	}
}


let global_scale = -1;
let global_rot = -1;

// keys
document.addEventListener("keydown", onDocumentKeyDown, false);
function onDocumentKeyDown(event){
	var keyCode = event.which;
	
	if(!game_paused && gameLoadedVar){
		KEYS[event.which] = true;
		
		console.log("keydown = "+keyCode);
		
		let curplayer = players[myPlayer];

		if(keyCode == 113){
			// download sounds sound data:
			download_all_sounds();
		}else if(keyCode == 66){ // 'B'
			spawn_bombers();
			
		}else if(keyCode == 76){ // 'L'
			turret_trajectories_enabled ^= 1;

		}else if(keyCode == 79){ // 'O'
			PLANET_GRAVITY ^= 1;

		}else if(keyCode == 82){ // 'R'
			curplayer.shot_speed_multi *= 1.008;
			console.log("shot_speed_multi = "+curplayer.shot_speed_multi);

		}else if(keyCode == 70){ // 'F'
			curplayer.shot_speed_multi /= 1.008;
			console.log("shot_speed_multi = "+curplayer.shot_speed_multi);

		}else if(keyCode == 80){ // 'P'
			// toggle turrets
			turrets_enabled ^= 1;
			//if(turrets_enabled){
				for(let i = 0; i < turrets.length; i++){
					respawn_turret(i);
				}
			//}

		}else if(keyCode == 103){ // numpad 7
			global_scale -= 0.1;
			players[myPlayer].mesh.scale.set(global_scale,1,1);
			console.log("scale = "+global_scale);
	
		}else if(keyCode == 104){ // numpad 8
			global_scale += 0.1;
			players[myPlayer].mesh.scale.set(global_scale,1,1);
			console.log("scale = "+global_scale);
	
		}else if(keyCode == 105){ // numpad 9
			
		}else if(keyCode == 100){ // numpad 4
			global_rot -= 0.1;
			players[myPlayer].mesh.rotation.x = (Math.PI/2)*global_rot;
			console.log("rotation = "+global_rot);
			
		}else if(keyCode == 101){ // numpad 5
			global_rot += 0.1;
			players[myPlayer].mesh.rotation.x = (Math.PI/2)*global_rot;
			console.log("rotation = "+global_rot);
			
		}else if(keyCode == 102){ // numpad 6
			
		}else if(keyCode == 97){ // numpad 1
			
		}else if(keyCode == 98){ // numpad 2
			
		}else if(keyCode == 99){ // numpad 3
			
		}else if(keyCode == 96){ // numpad 0
			
		}else if(keyCode == 110){ // numpad ','/'del'
			
		}else if(keyCode == 69){ // 'E'
			curplayer.lane++;
			if(curplayer.lane > 1){
				curplayer.lane = 1;
			}

		}else if(keyCode == 81){ // 'Q'
			curplayer.lane--;
			if(curplayer.lane < -1){
				curplayer.lane = -1;
			}
			
		}else if(keyCode == 82){

		}else if(keyCode == 70){

		}else if(keyCode == 87){ // 'W'
			// jump
			
			
		}else if(keyCode == 83){ // 'S'
			// prone
			
			
		}else if(keyCode == 65){ // 'A'
			// turn left
			
			//rotatePlayer = 2;
			
		}else if(keyCode == 68){ // 'D'
			// turn right
			
			//rotatePlayer = -2;
			
		}else if(keyCode == 89){ // 'Y'
			// youtube element
			//var group = new THREE.Group();
			//group.add(new YoutubeEmbed('bmfudW7rbG0', 0, Z_RAIN, 0, -Math.PI/2));
			//scene2.add(group);
		
		}else if(keyCode == 32){ // 'space	'

			
		}else if(keyCode == 115){ // 'F4'
			guivisible ^= 1;
			
			if(guivisible){
				$("#gui").show();
			}else{
				$("#gui").hide();
			}
			
		}else if(keyCode == 49){ // '1'
			change_player(keyCode-49);

		}else if(keyCode == 50){ // '2'
			change_player(keyCode-49);
			
		}else if(keyCode == 51){ // '3'
			change_player(keyCode-49);
			
		}else if(keyCode == 52){ // '4'
			change_player(keyCode-49);
			
		}else if(keyCode == 53){ // '5'
			change_player(keyCode-49);
			
		}else if(keyCode == 54){ // '6'
			change_player(keyCode-49);
			
		}else if(keyCode == 55){ // '7'
			DEV_MODE--;
			if(DEV_MODE < 0){
				DEV_MODE = MAX_DEV_MODE;
			}
			
		}else if(keyCode == 56){ // '8'
			DEV_MODE++;
			if(DEV_MODE > MAX_DEV_MODE){
				DEV_MODE = 0;
			}
			
		}else if(keyCode == 57){ // '9'
			SHOW_RAIN_BG ^= 1;
			
			if(SHOW_RAIN_BG){
				if(WATER_ENABLED){
					rainfallMesh.visible = true;
					waterdropsMesh.visible = true;
				}
				fade_dir = 2; // enable
			}else{
				fade_dir = 1; // disable
			}
			
		}else if(keyCode == 78){ // 'N'
			SHOW_NIGHTSKY_BG ^= 1;
			NIGHTSKY_STYLE = 0;
			
			// night_enabled night enabled
			if(SHOW_NIGHTSKY_BG){
				night_fade_dir = 2; // enable night
				// todo: add textures/clouds/sunset.png for sunset night mode.
			}else{
				if(clouds_back_enabled){
					cloudsBackMesh.visible = true;
				}
				night_fade_dir = 1; // disable night
			}
			
		}else if(keyCode == 77){ // 'M'
			//change mode to sunset
			SHOW_NIGHTSKY_BG ^= 1;
			NIGHTSKY_STYLE = 1;
			
			// sunset enable sunset
			if(SHOW_NIGHTSKY_BG){
				night_fade_dir = 2; // enable night
				// todo: add textures/clouds/sunset.png for sunset night mode.
			}else{
				if(clouds_back_enabled){
					cloudsBackMesh.visible = true;
				}
				night_fade_dir = 1; // disable night
			}
		
		}else if(keyCode == 48){ // '0'
			SHOW_WAVE_BG ^= 1;
			
			// show bumpy sky:
			terrain.visible = !!SHOW_WAVE_BG;
			
			// hide "real" sky:
			if(clouds_back_enabled){
				cloudsBackMesh.visible = !SHOW_WAVE_BG;
			}
			if(clouds_front_enabled){
				cloudsFrontMesh.visible = !SHOW_WAVE_BG;
			}
		}else if(keyCode == 13){ // 'enter'
			rotate_camera_to_gravity ^= 1;
		}else if(keyCode == 190){ // '.'
			let angle = players[myPlayer].angle;
			let gangle = get_gravity_angle(players[myPlayer].x, players[myPlayer].z);
			console.warn(gangle.toFixed(3)+" / "+angle.toFixed(3));
		}
	} // !game_paused
	
	// allow pause button to work at all times:
	if(keyCode == 27){ // 'esc'
		if(gameLoadedVar){
			game_paused ^= 1;
			game_paused_by_enter = game_paused;
			play_sound("_blip");
			update_pause_screen();
		}
	}
}




function update_pause_screen(){
	if(game_paused){
		if(game_paused_by_enter){
			$("#by_enter").show();
			$("#by_click").hide();
		}else{
			$("#by_enter").hide();
			$("#by_click").show();
		}
		$("#pause_container").css("display", "table");
	}else{
		$("#pause_container").css("display", "none");
	}
}





$(window).bind('beforeunload', function(){
	return null; // disabled for dev mode...
	return 'Are you sure you want to leave?'; // modern browsers will show their own message instead of this.
});





// onmousemove
document.addEventListener("mousemove", onDocumentMouseMove, false);
function onDocumentMouseMove(event){
	if(!game_paused && gameLoadedVar){
		// update mouse pos only if not pressing SHIFT key.
		// NOTE: DONT USE CTRL IN ANY COMBINATIONS SINCE CTRL+W QUITS PAGE.
		// this way you can stop camera following mouse.
		// todo: fix pointing direction being wrong if player not in middle of screen.
		//if(!key_down(16)){ // if not 'SHIFT'
			MOUSE_X = event.clientX; // integers.
			MOUSE_Y = event.clientY;
					
			MOUSE_OFFSET_X = (MOUSE_X-SCREEN_MID_X)*2;
			MOUSE_OFFSET_Y = (MOUSE_Y-SCREEN_MID_Y)*2;
			
			MOUSE_ANGLE = get_angle(SCREEN_MID_X, SCREEN_MID_Y, MOUSE_X, MOUSE_Y);
			
			MOUSE_DIST = get_dist_2d(SCREEN_MID_X, SCREEN_MID_Y, MOUSE_X, MOUSE_Y);
		//}

	

		if(!players.length){
			console.log("players not initialized yet");
		}else{
			setShootAngle(myPlayer);
		}
	}
}




function stopEvent(event){
	if(typeof event.preventDefault !== "undefined"){
		event.preventDefault();
	}
	if(typeof event.stopPropagation !== "undefined"){
		event.stopPropagation();
	}
}




window.addEventListener("contextmenu", function(event){
	if(!contextmenu_enabled){
		event.preventDefault();
	}
});




// if val distance to target is less or equal range.
function is_near(val, target){
	let range = 0.01;
	return (Math.abs(val-target) <= range);
}



// middle mouse middle button middle mouse button mousewheel scroll button
document.addEventListener('wheel', onDocumentWheel, {passive: false});
function onDocumentWheel(event){
	if(!game_paused){
		if(event.deltaY < 0){
			// UP:
			INTERNAL_ZOOM *= ZOOM_MULTI;
		}else{
			// DOWN:
			INTERNAL_ZOOM /= ZOOM_MULTI;
		}

		// lock zoom to special multipliers (powers of two basically).
		let tempzoom = INTERNAL_ZOOM;
		let mults   = [0.25, 0.5, 1, 2, 3, 4];
		let multstr = ["1/4", "1/2", "1x", "2x", "3x", "4x"];
		for(let i = 0; i < mults.length; i++){
			if(is_near(tempzoom, mults[i])){
				tempzoom = mults[i];
				console.log("zoom is exactly "+tempzoom);
				push_message("Zoom is exactly "+multstr[i], true);
				break;
			}
		}

		camera.zoom = tempzoom;
		camera.updateProjectionMatrix();
	}
}


function get_current_weaponinfo(){
	if(players.length > 0){
		let myplayer = players[myPlayer];
		return WEAPON_INFO[myplayer.weapons1[myplayer.current1]];
	}else{
		return null;
	}
}


document.addEventListener("mousedown", onDocumentMouseDown, false);
function onDocumentMouseDown(event){
	if(!game_paused && gameLoadedVar && players.length > 0){
		let myplayer = players[myPlayer];
		
		if(event.button == 0){ // left click leftclick
			shoot_from_myplayer();
			prevShootTime = getTimeMillis();
			shooting_started = true;
			prevShootStartTime = getTimeMillis();

			//push_message("Clicked at: "+MOUSE_X+", "+MOUSE_Y);
		
		}else if(event.button == 1){ // middle click
			// change primary weapon:

			myplayer.current1++;
			if(myplayer.current1 >= myplayer.weapons1.length){
				myplayer.current1 = 0;
			}
			
			let weaponinfo = get_current_weaponinfo();
			push_message("Weapon: "+weaponinfo.visible_name);
			change_player_trajectory_colors(weaponinfo.colors);

		}else if(event.button == 2){ // right click
			// flip plane:

			if(myplayer.type == TYPE_PLANE || myplayer.type == TYPE_HELI){
				if(!plane_flipping){
					plane_flipping = 1;
				
					play_sound("plane_flip", myplayer.x, myplayer.z);
				}
			}
		}
	}
	
	stopEvent(event); // prevent any other handling of these events by browser.
}




document.addEventListener("mouseup", onDocumentMouseUp, false);
function onDocumentMouseUp(event){
	// dont check paused here or keys can get stuck after unpausing.
	if(gameLoadedVar){
		if(event.button == 0){ // left click
			shooting_started = false;
			can_shoot = false;
		}else if(event.button == 1){ // middle click
			
		}else if(event.button == 2){ // right click
			
		}
	}
}



</script>


</body>
</html>